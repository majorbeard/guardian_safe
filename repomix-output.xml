This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
frontend/.gitignore
frontend/index.html
frontend/package.json
frontend/public/.well-known/assetlinks.json
frontend/public/vite.svg
frontend/src/app.tsx
frontend/src/components/AdminDashboard.tsx
frontend/src/components/ChangePasswordModal.tsx
frontend/src/components/CreateSafeModal.tsx
frontend/src/components/CreateTripModal.tsx
frontend/src/components/CreateUserModal.tsx
frontend/src/components/CustomerTrackingPage.tsx
frontend/src/components/DashboardLayout.tsx
frontend/src/components/ErrorBoundary.tsx
frontend/src/components/LiveTracking.tsx
frontend/src/components/LoadingSpinner.tsx
frontend/src/components/LoginPage.tsx
frontend/src/components/OwnerDashboard.tsx
frontend/src/components/SafesList.tsx
frontend/src/components/StatsCards.tsx
frontend/src/components/Toast.tsx
frontend/src/components/TripsList.tsx
frontend/src/components/TripTrackingModal.tsx
frontend/src/components/UsersList.tsx
frontend/src/index.css
frontend/src/lib/supabase.ts
frontend/src/main.tsx
frontend/src/services/auth.ts
frontend/src/services/data.ts
frontend/src/services/mobileUsers.ts
frontend/src/services/tracknetics.ts
frontend/src/store/auth.ts
frontend/src/store/data.ts
frontend/src/types/index.ts
frontend/src/utils/leafletHelpers.ts
frontend/src/utils/logger.ts
frontend/src/utils/networkHelpers.ts
frontend/src/utils/performance.ts
frontend/src/utils/requestHelpers.ts
frontend/src/utils/validation.ts
frontend/src/vite-env.d.ts
frontend/tsconfig.app.json
frontend/tsconfig.json
frontend/tsconfig.node.json
frontend/vercel.json
frontend/vite.config.ts
mobile/.gitignore
mobile/android/.gitignore
mobile/android/app/.gitignore
mobile/android/app/build.gradle
mobile/android/app/capacitor.build.gradle
mobile/android/app/proguard-rules.pro
mobile/android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java
mobile/android/app/src/main/AndroidManifest.xml
mobile/android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java
mobile/android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml
mobile/android/app/src/main/res/drawable/ic_launcher_background.xml
mobile/android/app/src/main/res/layout/activity_main.xml
mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
mobile/android/app/src/main/res/values/ic_launcher_background.xml
mobile/android/app/src/main/res/values/strings.xml
mobile/android/app/src/main/res/values/styles.xml
mobile/android/app/src/main/res/xml/file_paths.xml
mobile/android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java
mobile/android/build.gradle
mobile/android/capacitor.settings.gradle
mobile/android/gradle.properties
mobile/android/gradle/wrapper/gradle-wrapper.properties
mobile/android/gradlew
mobile/android/gradlew.bat
mobile/android/settings.gradle
mobile/android/variables.gradle
mobile/capacitor.config.ts
mobile/index.html
mobile/package.json
mobile/public/vite.svg
mobile/src/app.tsx
mobile/src/components/LoadingSpinner.tsx
mobile/src/components/OTPGenerator.tsx
mobile/src/components/TripCard.tsx
mobile/src/index.css
mobile/src/main.tsx
mobile/src/screens/DashboardScreen.tsx
mobile/src/screens/DeliveryScreen.tsx
mobile/src/screens/LoginScreen.tsx
mobile/src/services/audit.ts
mobile/src/services/auth.ts
mobile/src/services/bluetooth.ts
mobile/src/services/geolocation.ts
mobile/src/services/otp.ts
mobile/src/services/supabase.ts
mobile/src/services/tracknetics.ts
mobile/src/services/trips.ts
mobile/src/store/auth.ts
mobile/src/store/trips.ts
mobile/src/types/index.ts
mobile/src/utils/validation.ts
mobile/src/vite-env.d.ts
mobile/tsconfig.app.json
mobile/tsconfig.json
mobile/tsconfig.node.json
mobile/vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="frontend/public/.well-known/assetlinks.json">
[
  {
    "relation": ["delegate_permission/common.handle_all_urls"],
    "target": {
      "namespace": "android_app",
      "package_name": "com.guardiansafe.mobile",
      "sha256_cert_fingerprints": [
        "22:62:0C:FA:D3:84:89:42:C1:3F:C0:89:EA:65:FF:CE:FC:55:6B:3F:A8:BC:B6:C5:B2:D9:DE:D9:67:DA:2D:48"
      ]
    }
  }
]
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/components/ChangePasswordModal.tsx">
import { useState } from "preact/hooks";
import { Lock, Eye, EyeOff } from "lucide-preact";
import { authService } from "../services/auth";
import { LoadingSpinner } from "./LoadingSpinner";

export function ChangePasswordModal() {
  const [newPassword, setNewPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleSubmit = async (e: Event) => {
    e.preventDefault();
    setError("");

    if (newPassword.length < 8) {
      setError("Password must be at least 8 characters long");
      return;
    }

    if (newPassword !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    setLoading(true);

    try {
      const result = await authService.changePassword(newPassword);

      if (!result.success) {
        setError(result.error || "Failed to change password");
      }
      // Success will update auth state and close modal
    } catch (err) {
      setError("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex items-center space-x-3 mb-6">
          <div className="bg-yellow-100 rounded-full p-2">
            <Lock className="h-6 w-6 text-yellow-600" />
          </div>
          <div>
            <h2 className="text-xl font-bold text-gray-900">Change Password</h2>
            <p className="text-sm text-gray-600">
              You must change your password to continue
            </p>
          </div>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded text-sm">
              {error}
            </div>
          )}

          <div>
            <label
              htmlFor="newPassword"
              className="block text-sm font-medium text-gray-700"
            >
              New Password
            </label>
            <div className="mt-1 relative">
              <input
                id="newPassword"
                type={showPassword ? "text" : "password"}
                required
                className="input pr-10"
                placeholder="Enter new password"
                value={newPassword}
                onInput={(e) =>
                  setNewPassword((e.target as HTMLInputElement).value)
                }
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                onClick={() => setShowPassword(!showPassword)}
              >
                {showPassword ? (
                  <EyeOff className="h-5 w-5" />
                ) : (
                  <Eye className="h-5 w-5" />
                )}
              </button>
            </div>
          </div>

          <div>
            <label
              htmlFor="confirmPassword"
              className="block text-sm font-medium text-gray-700"
            >
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type={showPassword ? "text" : "password"}
              required
              className="mt-1 input"
              placeholder="Confirm new password"
              value={confirmPassword}
              onInput={(e) =>
                setConfirmPassword((e.target as HTMLInputElement).value)
              }
            />
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded p-3 text-sm text-blue-700">
            <p className="font-medium">Password requirements:</p>
            <ul className="mt-1 space-y-1">
              <li>• At least 8 characters long</li>
              <li>• Should contain letters and numbers</li>
              <li>• Avoid common passwords</li>
            </ul>
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full btn btn-primary"
          >
            {loading ? (
              <>
                <LoadingSpinner size="small" className="mr-2" />
                Changing Password...
              </>
            ) : (
              "Change Password"
            )}
          </button>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/ErrorBoundary.tsx">
import { Component } from "preact";
import { AlertTriangle, RefreshCw, Home } from "lucide-preact";

interface ErrorBoundaryProps {
  children: preact.ComponentChildren;
  fallback?: (error: Error, reset: () => void) => preact.ComponentChildren;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
  errorInfo: any;
}

export class ErrorBoundary extends Component<
  ErrorBoundaryProps,
  ErrorBoundaryState
> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
    };
  }

  static getDerivedStateFromError(error: Error): Partial<ErrorBoundaryState> {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: any) {
    console.error("Error caught by boundary:", error, errorInfo);

    this.setState({
      error,
      errorInfo,
    });

    // Log to external service (add Sentry, LogRocket, etc. here)
    this.logErrorToService(error, errorInfo);
  }

  logErrorToService(error: Error, errorInfo: any) {
    // TODO: Send to error tracking service
    // Example: Sentry.captureException(error, { extra: errorInfo });

    // For now, just log locally
    const errorLog = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo?.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
    };

    console.error("Error logged:", errorLog);
  }

  handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
    });
  };

  handleGoHome = () => {
    window.location.href = "/";
  };

  render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback(this.state.error!, this.handleReset);
      }

      return (
        <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
          <div className="max-w-md w-full">
            <div className="bg-white rounded-lg shadow-lg p-8">
              <div className="flex items-center justify-center w-16 h-16 bg-red-100 rounded-full mx-auto mb-4">
                <AlertTriangle className="h-8 w-8 text-red-600" />
              </div>

              <h1 className="text-2xl font-bold text-gray-900 text-center mb-2">
                Something went wrong
              </h1>

              <p className="text-gray-600 text-center mb-6">
                We're sorry, but something unexpected happened. The error has
                been logged and we'll look into it.
              </p>

              {process.env.NODE_ENV === "development" && this.state.error && (
                <div className="mb-6 p-4 bg-gray-100 rounded-lg">
                  <p className="text-sm font-mono text-red-600 break-all">
                    {this.state.error.message}
                  </p>
                  {this.state.error.stack && (
                    <details className="mt-2">
                      <summary className="text-xs text-gray-600 cursor-pointer hover:text-gray-800">
                        Stack trace
                      </summary>
                      <pre className="mt-2 text-xs text-gray-700 overflow-x-auto">
                        {this.state.error.stack}
                      </pre>
                    </details>
                  )}
                </div>
              )}

              <div className="flex flex-col sm:flex-row gap-3">
                <button
                  onClick={this.handleReset}
                  className="flex-1 btn btn-primary"
                >
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Try Again
                </button>

                <button
                  onClick={this.handleGoHome}
                  className="flex-1 btn btn-secondary"
                >
                  <Home className="h-4 w-4 mr-2" />
                  Go Home
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
</file>

<file path="frontend/src/components/Toast.tsx">
import {
  X,
  CheckCircle,
  AlertTriangle,
  AlertCircle,
  Info,
} from "lucide-preact";
import { signal } from "@preact/signals";

export type ToastType = "success" | "error" | "warning" | "info";

export interface Toast {
  id: string;
  type: ToastType;
  message: string;
  duration?: number;
}

export const toasts = signal<Toast[]>([]);

export const toast = {
  success: (message: string, duration = 5000) => {
    addToast({ type: "success", message, duration });
  },
  error: (message: string, duration = 7000) => {
    addToast({ type: "error", message, duration });
  },
  warning: (message: string, duration = 6000) => {
    addToast({ type: "warning", message, duration });
  },
  info: (message: string, duration = 5000) => {
    addToast({ type: "info", message, duration });
  },
};

function addToast(toast: Omit<Toast, "id">) {
  const id = crypto.randomUUID();
  const newToast = { ...toast, id };

  toasts.value = [...toasts.value, newToast];

  if (toast.duration) {
    setTimeout(() => removeToast(id), toast.duration);
  }
}

function removeToast(id: string) {
  toasts.value = toasts.value.filter((t) => t.id !== id);
}

export function ToastContainer() {
  return (
    <div className="fixed top-4 right-4 z-50 space-y-2 max-w-md w-full pointer-events-none">
      {toasts.value.map((toast) => (
        <ToastItem key={toast.id} toast={toast} />
      ))}
    </div>
  );
}

function ToastItem({ toast: toastItem }: { toast: Toast }) {
  const getIcon = () => {
    switch (toastItem.type) {
      case "success":
        return <CheckCircle className="h-5 w-5 text-green-600" />;
      case "error":
        return <AlertCircle className="h-5 w-5 text-red-600" />;
      case "warning":
        return <AlertTriangle className="h-5 w-5 text-yellow-600" />;
      case "info":
        return <Info className="h-5 w-5 text-blue-600" />;
    }
  };

  const getStyles = () => {
    switch (toastItem.type) {
      case "success":
        return "bg-green-50 border-green-200 text-green-800";
      case "error":
        return "bg-red-50 border-red-200 text-red-800";
      case "warning":
        return "bg-yellow-50 border-yellow-200 text-yellow-800";
      case "info":
        return "bg-blue-50 border-blue-200 text-blue-800";
    }
  };

  return (
    <div
      className={`pointer-events-auto flex items-start p-4 rounded-lg border shadow-lg ${getStyles()} animate-slide-in`}
    >
      <div className="flex-shrink-0">{getIcon()}</div>
      <div className="ml-3 flex-1">
        <p className="text-sm font-medium">{toastItem.message}</p>
      </div>
      <button
        onClick={() => removeToast(toastItem.id)}
        className="ml-4 flex-shrink-0 text-current opacity-70 hover:opacity-100"
      >
        <X className="h-4 w-4" />
      </button>
    </div>
  );
}
</file>

<file path="frontend/src/store/data.ts">
import { signal } from "@preact/signals";
import type { Safe, Trip } from "../types";

// Data signals
export const safes = signal<Safe[]>([]);
export const trips = signal<Trip[]>([]);
export const loading = signal<boolean>(false);

// Data actions
export const dataActions = {
  setSafes: (newSafes: Safe[]) => {
    safes.value = newSafes;
  },

  addSafe: (safe: Safe) => {
    safes.value = [...safes.value, safe];
  },

  updateSafe: (safeId: string, updates: Partial<Safe>) => {
    safes.value = safes.value.map((safe) =>
      safe.id === safeId ? { ...safe, ...updates } : safe
    );
  },

  setTrips: (newTrips: Trip[]) => {
    trips.value = newTrips;
  },

  addTrip: (trip: Trip) => {
    trips.value = [...trips.value, trip];
  },

  updateTrip: (tripId: string, updates: Partial<Trip>) => {
    trips.value = trips.value.map((trip) =>
      trip.id === tripId ? { ...trip, ...updates } : trip
    );
  },

  setLoading: (isLoading: boolean) => {
    loading.value = isLoading;
  },
};
</file>

<file path="frontend/src/utils/leafletHelpers.ts">
import L from "leaflet";

// Fix Leaflet default marker icons (they break in bundlers)
export const fixLeafletIcons = () => {
  delete (L.Icon.Default.prototype as any)._getIconUrl;
  L.Icon.Default.mergeOptions({
    iconRetinaUrl:
      "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png",
    iconUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png",
    shadowUrl: "https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png",
  });
};

// Create custom colored markers
export const createCustomIcon = (color: string) => {
  return L.divIcon({
    className: "custom-div-icon",
    html: `
      <div style="
        background-color: ${color};
        width: 24px;
        height: 24px;
        border-radius: 50% 50% 50% 0;
        border: 2px solid white;
        transform: rotate(-45deg);
        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      ">
        <div style="
          width: 10px;
          height: 10px;
          background-color: white;
          border-radius: 50%;
          position: absolute;
          top: 5px;
          left: 5px;
        "></div>
      </div>
    `,
    iconSize: [24, 24],
    iconAnchor: [12, 24],
  });
};

// Create arrow marker for moving vehicle
export const createArrowIcon = (color: string, rotation: number = 0) => {
  return L.divIcon({
    className: "custom-arrow-icon",
    html: `
      <div style="
        width: 0;
        height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-bottom: 20px solid ${color};
        filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4));
        transform: rotate(${rotation}deg);
      "></div>
    `,
    iconSize: [24, 24],
    iconAnchor: [12, 20],
  });
};

// Initialize OpenStreetMap tile layer
export const getOpenStreetMapLayer = () => {
  return L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution:
      '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 19,
  });
};

// Alternative: Satellite imagery (if you want satellite view option)
export const getSatelliteLayer = () => {
  return L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "© Esri, Maxar, Earthstar Geographics",
      maxZoom: 19,
    }
  );
};
</file>

<file path="frontend/src/utils/logger.ts">
type LogLevel = "debug" | "info" | "warn" | "error";

interface LogEntry {
  level: LogLevel;
  message: string;
  timestamp: string;
  data?: any;
  userId?: string;
  url?: string;
}

class Logger {
  private isDevelopment = import.meta.env.DEV;
  private logs: LogEntry[] = [];
  private maxLogs = 100;

  private createEntry(level: LogLevel, message: string, data?: any): LogEntry {
    return {
      level,
      message,
      timestamp: new Date().toISOString(),
      data,
      url: window.location.href,
    };
  }

  private addLog(entry: LogEntry) {
    this.logs.push(entry);

    // Keep only last 100 logs
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
  }

  debug(message: string, data?: any) {
    if (this.isDevelopment) {
      console.debug(message, data);
    }
    this.addLog(this.createEntry("debug", message, data));
  }

  info(message: string, data?: any) {
    console.info(message, data);
    this.addLog(this.createEntry("info", message, data));
  }

  warn(message: string, data?: any) {
    console.warn(message, data);
    this.addLog(this.createEntry("warn", message, data));
  }

  error(message: string, error?: any) {
    console.error(message, error);

    const entry = this.createEntry("error", message, {
      error: error?.message || error,
      stack: error?.stack,
    });

    this.addLog(entry);

    // TODO:
    // Send to error tracking service
    this.reportError(entry);
  }

  private reportError(entry: LogEntry) {
    // TODO:
    // Send to error tracking service
    if (!this.isDevelopment) {
      // Sentry.captureMessage(entry.message, { level: 'error', extra: entry.data });
      console.log("Would report error to monitoring service:", entry);
    }
  }

  getLogs(level?: LogLevel): LogEntry[] {
    if (level) {
      return this.logs.filter((log) => log.level === level);
    }
    return [...this.logs];
  }

  clearLogs() {
    this.logs = [];
  }

  // Download logs as JSON
  downloadLogs() {
    const dataStr = JSON.stringify(this.logs, null, 2);
    const dataBlob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `guardian-safe-logs-${Date.now()}.json`;
    link.click();
    URL.revokeObjectURL(url);
  }
}

export const logger = new Logger();
</file>

<file path="frontend/src/utils/networkHelpers.ts">
import { toast } from "../components/Toast";

export interface RetryConfig {
  maxRetries?: number;
  delayMs?: number;
  backoff?: boolean;
  onRetry?: (attempt: number) => void;
}

export async function retryRequest<T>(
  fn: () => Promise<T>,
  config: RetryConfig = {}
): Promise<T> {
  const { maxRetries = 3, delayMs = 1000, backoff = true, onRetry } = config;

  let lastError: any;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error: any) {
      lastError = error;

      // Don't retry on auth errors or client errors (4xx)
      if (
        error.status === 401 ||
        error.status === 403 ||
        error.status === 404 ||
        (error.status >= 400 && error.status < 500)
      ) {
        throw error;
      }

      // Don't retry if no more attempts left
      if (attempt === maxRetries) {
        break;
      }

      // Calculate delay with optional exponential backoff
      const delay = backoff ? delayMs * Math.pow(2, attempt) : delayMs;

      console.log(
        `Request failed, retrying in ${delay}ms (attempt ${
          attempt + 1
        }/${maxRetries})`
      );

      if (onRetry) {
        onRetry(attempt + 1);
      }

      // Wait before retrying
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }

  // All retries failed
  console.error("All retry attempts failed:", lastError);
  throw lastError;
}

export function isOnline(): boolean {
  return navigator.onLine;
}

export function setupNetworkListeners() {
  window.addEventListener("online", () => {
    console.log("Network connection restored");
    toast.success("Connection restored");
  });

  window.addEventListener("offline", () => {
    console.log("Network connection lost");
    toast.error("No internet connection");
  });
}

export async function waitForNetwork(
  timeoutMs: number = 30000
): Promise<boolean> {
  if (isOnline()) {
    return true;
  }

  return new Promise((resolve) => {
    const timeout = setTimeout(() => {
      window.removeEventListener("online", onOnline);
      resolve(false);
    }, timeoutMs);

    const onOnline = () => {
      clearTimeout(timeout);
      window.removeEventListener("online", onOnline);
      resolve(true);
    };

    window.addEventListener("online", onOnline);
  });
}
</file>

<file path="frontend/src/utils/performance.ts">
import { logger } from "./logger";

export function measurePerformance<T>(
  name: string,
  fn: () => T | Promise<T>
): T | Promise<T> {
  const start = performance.now();

  const result = fn();

  if (result instanceof Promise) {
    return result.finally(() => {
      const duration = performance.now() - start;
      logger.debug(`Performance: ${name}`, {
        duration: `${duration.toFixed(2)}ms`,
      });

      // Warn if slow
      if (duration > 3000) {
        logger.warn(`Slow operation: ${name}`, {
          duration: `${duration.toFixed(2)}ms`,
        });
      }
    }) as T;
  } else {
    const duration = performance.now() - start;
    logger.debug(`Performance: ${name}`, {
      duration: `${duration.toFixed(2)}ms`,
    });
    return result;
  }
}

export function trackPageLoad() {
  if (typeof window === "undefined") return;

  window.addEventListener("load", () => {
    const perfData = performance.getEntriesByType(
      "navigation"
    )[0] as PerformanceNavigationTiming;

    if (perfData) {
      logger.info("Page load metrics", {
        dns: perfData.domainLookupEnd - perfData.domainLookupStart,
        tcp: perfData.connectEnd - perfData.connectStart,
        request: perfData.responseStart - perfData.requestStart,
        response: perfData.responseEnd - perfData.responseStart,
        dom:
          perfData.domContentLoadedEventEnd -
          perfData.domContentLoadedEventStart,
        total: perfData.loadEventEnd - perfData.fetchStart,
      });
    }
  });
}
</file>

<file path="frontend/src/utils/requestHelpers.ts">
import { toast } from "../components/Toast";

export interface RequestOptions {
  timeoutMs?: number;
  onTimeout?: () => void;
  showErrorToast?: boolean;
}

export async function withTimeout<T>(
  promise: Promise<T>,
  options: RequestOptions = {}
): Promise<T> {
  const { timeoutMs = 30000, onTimeout, showErrorToast = true } = options;

  const controller = new AbortController();

  const timeoutId = setTimeout(() => {
    controller.abort();
    if (onTimeout) {
      onTimeout();
    }
  }, timeoutMs);

  try {
    const result = await promise;
    clearTimeout(timeoutId);
    return result;
  } catch (error: any) {
    clearTimeout(timeoutId);

    if (error.name === "AbortError" || error.message?.includes("aborted")) {
      const message = "Request timed out. Please check your connection.";
      if (showErrorToast) {
        toast.error(message);
      }
      throw new Error(message);
    }

    throw error;
  }
}

export function createAbortController(timeoutMs: number = 30000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  return {
    controller,
    cleanup: () => clearTimeout(timeoutId),
  };
}
</file>

<file path="frontend/src/utils/validation.ts">
// Email validation
export function validateEmail(email: string): {
  valid: boolean;
  error?: string;
} {
  if (!email || typeof email !== "string") {
    return { valid: false, error: "Email is required" };
  }

  const trimmed = email.trim();

  if (trimmed.length === 0) {
    return { valid: false, error: "Email cannot be empty" };
  }

  if (trimmed.length > 254) {
    return { valid: false, error: "Email is too long" };
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(trimmed)) {
    return { valid: false, error: "Invalid email format" };
  }

  return { valid: true };
}

// Phone validation (South African numbers)
export function validatePhone(phone: string): {
  valid: boolean;
  error?: string;
} {
  if (!phone || typeof phone !== "string") {
    return { valid: false, error: "Phone number is required" };
  }

  const cleaned = phone.replace(/[\s\-\(\)]/g, "");

  const southAfricanPatterns = [
    /^0[7-8][0-9]\d{7}$/,
    /^0[1-6]\d{8}$/,
    /^\+27[7-8][0-9]\d{7}$/,
    /^\+27[1-6]\d{8}$/,
    /^27[7-8][0-9]\d{7}$/,
    /^27[1-6]\d{8}$/,
  ];

  const isValid = southAfricanPatterns.some((pattern) => pattern.test(cleaned));

  if (!isValid) {
    return { valid: false, error: "Invalid South African phone number" };
  }

  return { valid: true };
}

// Username validation
export function validateUsername(username: string): {
  valid: boolean;
  error?: string;
} {
  if (!username || typeof username !== "string") {
    return { valid: false, error: "Username is required" };
  }

  const trimmed = username.trim();

  if (trimmed.length < 3) {
    return { valid: false, error: "Username must be at least 3 characters" };
  }

  if (trimmed.length > 30) {
    return { valid: false, error: "Username must be less than 30 characters" };
  }

  if (!/^[a-zA-Z0-9_-]+$/.test(trimmed)) {
    return {
      valid: false,
      error:
        "Username can only contain letters, numbers, underscores and hyphens",
    };
  }

  return { valid: true };
}

// Password validation
export function validatePassword(password: string): {
  valid: boolean;
  error?: string;
} {
  if (!password || typeof password !== "string") {
    return { valid: false, error: "Password is required" };
  }

  if (password.length < 8) {
    return { valid: false, error: "Password must be at least 8 characters" };
  }

  if (password.length > 128) {
    return { valid: false, error: "Password is too long" };
  }

  const hasLetter = /[a-zA-Z]/.test(password);
  const hasNumber = /[0-9]/.test(password);

  if (!hasLetter || !hasNumber) {
    return {
      valid: false,
      error: "Password must contain both letters and numbers",
    };
  }

  const commonPasswords = [
    "password",
    "12345678",
    "qwerty",
    "abc12345",
    "password123",
  ];

  if (commonPasswords.includes(password.toLowerCase())) {
    return { valid: false, error: "Password is too common" };
  }

  return { valid: true };
}

// Safe serial number validation
export function validateSerialNumber(serial: string): {
  valid: boolean;
  error?: string;
} {
  if (!serial || typeof serial !== "string") {
    return { valid: false, error: "Serial number is required" };
  }

  const trimmed = serial.trim().toUpperCase();

  if (trimmed.length < 3 || trimmed.length > 50) {
    return {
      valid: false,
      error: "Serial number must be between 3 and 50 characters",
    };
  }

  if (!/^[A-Z0-9-_]+$/.test(trimmed)) {
    return {
      valid: false,
      error:
        "Serial number can only contain letters, numbers, hyphens and underscores",
    };
  }

  return { valid: true };
}

// Address validation
export function validateAddress(address: string): {
  valid: boolean;
  error?: string;
} {
  if (!address || typeof address !== "string") {
    return { valid: false, error: "Address is required" };
  }

  const trimmed = address.trim();

  if (trimmed.length < 10) {
    return {
      valid: false,
      error: "Address is too short (minimum 10 characters)",
    };
  }

  if (trimmed.length > 500) {
    return {
      valid: false,
      error: "Address is too long (maximum 500 characters)",
    };
  }

  return { valid: true };
}

// Generic text sanitization
export function sanitizeText(text: string, maxLength: number = 1000): string {
  if (!text || typeof text !== "string") {
    return "";
  }

  return text.trim().slice(0, maxLength).replace(/[<>]/g, ""); // Remove angle brackets to prevent XSS
}

// Date validation
export function validateDateTime(dateString: string): {
  valid: boolean;
  error?: string;
} {
  if (!dateString || typeof dateString !== "string") {
    return { valid: false, error: "Date is required" };
  }

  const date = new Date(dateString);

  if (isNaN(date.getTime())) {
    return { valid: false, error: "Invalid date format" };
  }

  // Check if date is too far in the past (more than 1 year)
  const oneYearAgo = new Date();
  oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);

  if (date < oneYearAgo) {
    return {
      valid: false,
      error: "Date cannot be more than 1 year in the past",
    };
  }

  // Check if date is too far in the future (more than 1 year)
  const oneYearFromNow = new Date();
  oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);

  if (date > oneYearFromNow) {
    return {
      valid: false,
      error: "Date cannot be more than 1 year in the future",
    };
  }

  return { valid: true };
}

// UUID validation
export function validateUUID(uuid: string): { valid: boolean; error?: string } {
  if (!uuid || typeof uuid !== "string") {
    return { valid: false, error: "ID is required" };
  }

  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

  if (!uuidRegex.test(uuid)) {
    return { valid: false, error: "Invalid ID format" };
  }

  return { valid: true };
}

// Comprehensive validation for trip creation
export interface TripValidationErrors {
  safe_id?: string;
  client_name?: string;
  client_email?: string;
  client_phone?: string;
  pickup_address?: string;
  delivery_address?: string;
  scheduled_pickup?: string;
  scheduled_delivery?: string;
  recipient_email?: string;
}

export function validateTripData(data: any): {
  valid: boolean;
  errors: TripValidationErrors;
  sanitized?: any;
} {
  const errors: TripValidationErrors = {};

  // Validate safe_id
  const safeIdValidation = validateUUID(data.safe_id);
  if (!safeIdValidation.valid) {
    errors.safe_id = safeIdValidation.error;
  }

  // Validate client_name
  if (!data.client_name || data.client_name.trim().length < 2) {
    errors.client_name = "Client name must be at least 2 characters";
  }

  // Validate client_email (optional but must be valid if provided)
  if (data.client_email) {
    const emailValidation = validateEmail(data.client_email);
    if (!emailValidation.valid) {
      errors.client_email = emailValidation.error;
    }
  }

  // Validate client_phone (optional but must be valid if provided)
  if (data.client_phone) {
    const phoneValidation = validatePhone(data.client_phone);
    if (!phoneValidation.valid) {
      errors.client_phone = phoneValidation.error;
    }
  }

  // Validate addresses
  const pickupValidation = validateAddress(data.pickup_address);
  if (!pickupValidation.valid) {
    errors.pickup_address = pickupValidation.error;
  }

  const deliveryValidation = validateAddress(data.delivery_address);
  if (!deliveryValidation.valid) {
    errors.delivery_address = deliveryValidation.error;
  }

  // Validate dates
  const pickupDateValidation = validateDateTime(data.scheduled_pickup);
  if (!pickupDateValidation.valid) {
    errors.scheduled_pickup = pickupDateValidation.error;
  }

  const deliveryDateValidation = validateDateTime(data.scheduled_delivery);
  if (!deliveryDateValidation.valid) {
    errors.scheduled_delivery = deliveryDateValidation.error;
  }

  // Validate pickup is before delivery
  if (pickupDateValidation.valid && deliveryDateValidation.valid) {
    const pickupDate = new Date(data.scheduled_pickup);
    const deliveryDate = new Date(data.scheduled_delivery);

    if (deliveryDate <= pickupDate) {
      errors.scheduled_delivery = "Delivery time must be after pickup time";
    }

    const minDuration = 30 * 60 * 1000; // 30 minutes
    if (deliveryDate.getTime() - pickupDate.getTime() < minDuration) {
      errors.scheduled_delivery = "Minimum trip duration is 30 minutes";
    }
  }

  // Validate recipient email if provided
  if (!data.recipient_is_client && data.recipient_email) {
    const recipientEmailValidation = validateEmail(data.recipient_email);
    if (!recipientEmailValidation.valid) {
      errors.recipient_email = recipientEmailValidation.error;
    }
  }

  const valid = Object.keys(errors).length === 0;

  // Return sanitized data if valid
  if (valid) {
    return {
      valid: true,
      errors: {},
      sanitized: {
        ...data,
        client_name: sanitizeText(data.client_name, 100),
        client_email: data.client_email?.trim().toLowerCase(),
        client_phone: data.client_phone?.replace(/[\s\-\(\)]/g, ""),
        pickup_address: sanitizeText(data.pickup_address, 500),
        delivery_address: sanitizeText(data.delivery_address, 500),
        special_instructions: sanitizeText(
          data.special_instructions || "",
          1000
        ),
        delivery_notes: sanitizeText(data.delivery_notes || "", 500),
        pickup_contact_name: sanitizeText(data.pickup_contact_name || "", 100),
        delivery_contact_name: sanitizeText(
          data.delivery_contact_name || "",
          100
        ),
        recipient_name: sanitizeText(data.recipient_name || "", 100),
        recipient_email: data.recipient_email?.trim().toLowerCase(),
      },
    };
  }

  return { valid, errors };
}
</file>

<file path="frontend/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="frontend/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="frontend/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="frontend/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/vercel.json">
{
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
</file>

<file path="frontend/vite.config.ts">
import { defineConfig } from "vite";
import preact from "@preact/preset-vite";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact(), tailwindcss()],
});
</file>

<file path="mobile/android/.gitignore">
# Using Android gitignore template: https://github.com/github/gitignore/blob/HEAD/Android.gitignore

# Built application files
*.apk
*.aar
*.ap_
*.aab

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
#  Uncomment the following line in case you need and you don't have the release build type files in your app
# release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Navigation Editor is relevant for you
.idea/navEditor.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Android Profiling
*.hprof

# Cordova plugins for Capacitor
capacitor-cordova-android-plugins

# Copied web assets
app/src/main/assets/public

# Generated Config files
app/src/main/assets/capacitor.config.json
app/src/main/assets/capacitor.plugins.json
app/src/main/res/xml/config.xml
</file>

<file path="mobile/android/app/.gitignore">
/build/*
!/build/.npmkeep
</file>

<file path="mobile/android/app/build.gradle">
apply plugin: 'com.android.application'

android {
    namespace "com.guardiansafe.mobile"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "com.guardiansafe.mobile"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}
</file>

<file path="mobile/android/app/capacitor.build.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_21
      targetCompatibility JavaVersion.VERSION_21
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-community-bluetooth-le')
    implementation project(':capacitor-geolocation')
    implementation project(':capacitor-haptics')
    implementation project(':capacitor-status-bar')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
</file>

<file path="mobile/android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="mobile/android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}
</file>

<file path="mobile/android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java">
package com.guardiansafe.mobile;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {}
</file>

<file path="mobile/android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>
</file>

<file path="mobile/android/app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
</file>

<file path="mobile/android/app/src/main/res/values/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>
</file>

<file path="mobile/android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>
</file>

<file path="mobile/android/app/src/main/res/xml/file_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>
</file>

<file path="mobile/android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="mobile/android/build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.2'
        classpath 'com.google.gms:google-services:4.4.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="mobile/android/capacitor.settings.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-community-bluetooth-le'
project(':capacitor-community-bluetooth-le').projectDir = new File('../node_modules/@capacitor-community/bluetooth-le/android')

include ':capacitor-geolocation'
project(':capacitor-geolocation').projectDir = new File('../node_modules/@capacitor/geolocation/android')

include ':capacitor-haptics'
project(':capacitor-haptics').projectDir = new File('../node_modules/@capacitor/haptics/android')

include ':capacitor-status-bar'
project(':capacitor-status-bar').projectDir = new File('../node_modules/@capacitor/status-bar/android')
</file>

<file path="mobile/android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
</file>

<file path="mobile/android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="mobile/android/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="mobile/android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="mobile/android/settings.gradle">
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
</file>

<file path="mobile/android/variables.gradle">
ext {
    minSdkVersion = 23
    compileSdkVersion = 35
    targetSdkVersion = 35
    androidxActivityVersion = '1.9.2'
    androidxAppCompatVersion = '1.7.0'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.15.0'
    androidxFragmentVersion = '1.8.4'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.12.1'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.2.1'
    androidxEspressoCoreVersion = '3.6.1'
    cordovaAndroidVersion = '10.1.1'
}
</file>

<file path="mobile/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guardian Safe - Mobile</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="mobile/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="mobile/src/components/LoadingSpinner.tsx">
import { clsx } from "clsx";

interface LoadingSpinnerProps {
  size?: "small" | "medium" | "large";
  className?: string;
}

export function LoadingSpinner({
  size = "medium",
  className,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    small: "w-4 h-4",
    medium: "w-6 h-6",
    large: "w-8 h-8",
  };

  return (
    <div
      className={clsx(
        "animate-spin rounded-full border-2 border-gray-300 border-t-blue-600",
        sizeClasses[size],
        className
      )}
    />
  );
}
</file>

<file path="mobile/src/services/audit.ts">
import { supabase } from "./supabase";
import { currentUser, currentSafe } from "../store/auth";

class AuditService {
  async log(
    event: string,
    details: string,
    success: boolean = true,
    tripId?: string
  ) {
    try {
      await supabase.from("activity_log").insert({
        event,
        user_type: "driver",
        user_id: currentUser.value?.username || "unknown",
        safe_id: currentSafe.value?.id,
        trip_id: tripId,
        details,
        success,
        created_at: new Date().toISOString(),
      });

      console.log(`Logged: ${event} - ${details}`);
    } catch (err) {
      console.error("Audit log failed:", err);
      // Don't block on logging failures
    }
  }
}

export const auditService = new AuditService();
</file>

<file path="mobile/src/services/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables");
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
  },
});
</file>

<file path="mobile/src/types/index.ts">
export type UserRole = "owner" | "admin";

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
}

export interface Safe {
  id: string;
  serial_number: string;
  device_hash: string;
  status: "active" | "inactive" | "maintenance" | "offline";
  battery_level: number;
  is_locked: boolean;
  tracking_device_id?: string;
  assigned_to: string;
  last_update?: string;
}

export interface Trip {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  tracking_token?: string;
  customer_tracking_enabled?: boolean;
  created_by: string;
  created_at: string;
}

// Mobile-specific types
export interface BluetoothDevice {
  deviceId: string;
  name: string;
  connected: boolean;
}

export interface OTPRequest {
  trip_id: string;
  location: {
    latitude: number;
    longitude: number;
    accuracy: number;
  };
  timestamp: string;
}

export interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}
</file>

<file path="mobile/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="mobile/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="mobile/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="mobile/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="frontend/.gitignore">
# Environment variables
.env
.env.local
.env.production

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guardian Safe</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="frontend/src/components/AdminDashboard.tsx">
import { useState } from "preact/hooks";
import { Plus, Shield, Package, MapPin, Activity } from "lucide-preact";
import { DashboardLayout } from "./DashboardLayout";
import { CreateTripModal } from "./CreateTripModal";
import { SafesList } from "./SafesList";
import { TripsList } from "./TripsList";
import { StatsCards } from "./StatsCards";
import { LiveTracking } from "./LiveTracking";
import { safes, trips } from "../store/data";
import { currentUser } from "../store/auth";

export function AdminDashboard() {
  const [showCreateTrip, setShowCreateTrip] = useState(false);
  const [activeTab, setActiveTab] = useState<
    "overview" | "safes" | "trips" | "tracking"
  >("overview");

  const user = currentUser.value;
  const userSafes = safes.value.filter((safe) => safe.assigned_to === user?.id);
  const userTrips = trips.value;

  // Filter specifically for active trips to determine tab visibility
  const activeTripsList = userTrips.filter((t) => t.status === "in_transit");
  const hasActiveTrips = activeTripsList.length > 0;

  // Get only the safes that are currently on a trip
  const activeSafeIds = activeTripsList.map((t) => t.safe_id);
  const safesInTransit = userSafes.filter((s) => activeSafeIds.includes(s.id));

  const stats = {
    totalSafes: userSafes.length,
    activeSafes: userSafes.filter((s) => s.status === "active").length,
    totalTrips: userTrips.length,
    activeTrips: activeTripsList.length,
  };

  const actions = (
    <button
      onClick={() => setShowCreateTrip(true)}
      className="btn btn-primary"
      disabled={userSafes.length === 0}
    >
      <Plus className="h-4 w-4 mr-2" />
      Book Trip
    </button>
  );

  // Define tabs - Logic prevents 'tracking' from appearing if no active trips
  const tabs = [
    {
      id: "overview",
      label: "Overview",
      icon: Activity,
      isActive: activeTab === "overview",
      onClick: () => setActiveTab("overview"),
    },
    {
      id: "safes",
      label: "My Safes",
      icon: Shield,
      isActive: activeTab === "safes",
      onClick: () => setActiveTab("safes"),
    },
    {
      id: "trips",
      label: "My Trips",
      icon: Package,
      isActive: activeTab === "trips",
      onClick: () => setActiveTab("trips"),
    },
  ];

  // Only add Live Tracking tab if there are active trips
  if (hasActiveTrips) {
    tabs.push({
      id: "tracking",
      label: "Live Tracking",
      icon: MapPin,
      isActive: activeTab === "tracking",
      onClick: () => setActiveTab("tracking"),
    });
  }

  return (
    <>
      <DashboardLayout tabs={tabs as any} actions={actions}>
        {/* Overview Tab */}
        {activeTab === "overview" && (
          <div className="space-y-8 animate-fade-in">
            <StatsCards stats={stats} />

            {userSafes.length === 0 ? (
              <div className="text-center py-12 bg-white rounded-lg border border-dashed border-gray-300">
                <Shield className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 mb-2">
                  No Safes Assigned
                </h3>
                <p className="text-gray-500">
                  Contact your administrator to get safes assigned to your
                  account.
                </p>
              </div>
            ) : (
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div className="card">
                  <div className="flex items-center justify-between mb-6">
                    <h3 className="text-lg font-medium text-gray-900">
                      My Safes
                    </h3>
                    <button
                      onClick={() => setActiveTab("safes")}
                      className="text-sm text-brand hover:text-brand-hover"
                    >
                      View all
                    </button>
                  </div>
                  <SafesList limit={5} showActions={false} />
                </div>

                <div className="card">
                  <div className="flex items-center justify-between mb-6">
                    <h3 className="text-lg font-medium text-gray-900">
                      Recent Trips
                    </h3>
                    <button
                      onClick={() => setActiveTab("trips")}
                      className="text-sm text-brand hover:text-brand-hover"
                    >
                      View all
                    </button>
                  </div>
                  <TripsList limit={5} showActions={false} />
                </div>
              </div>
            )}
          </div>
        )}

        {/* Other Tabs */}
        {activeTab === "safes" && (
          <div className="animate-fade-in">
            <SafesList />
          </div>
        )}
        {activeTab === "trips" && (
          <div className="animate-fade-in">
            <TripsList />
          </div>
        )}

        {/* Live Tracking - Only shows safes currently in transit */}
        {activeTab === "tracking" && hasActiveTrips && (
          <div className="animate-fade-in">
            <div className="mb-4 bg-blue-50 border border-blue-100 text-blue-800 px-4 py-3 rounded-md text-sm flex items-center">
              <MapPin className="h-4 w-4 mr-2" />
              Showing {safesInTransit.length} safe
              {safesInTransit.length !== 1 ? "s" : ""} currently in transit.
            </div>
            <LiveTracking safes={safesInTransit} />
          </div>
        )}
      </DashboardLayout>

      {/* Modals */}
      {showCreateTrip && (
        <CreateTripModal
          onClose={() => setShowCreateTrip(false)}
          availableSafes={userSafes.filter((safe) => safe.status === "active")}
        />
      )}
    </>
  );
}
</file>

<file path="frontend/src/components/CreateUserModal.tsx">
import { useState } from "preact/hooks";
import { X, User, Mail, Key } from "lucide-preact";
import { authService } from "../services/auth";
import { currentUser } from "../store/auth";
import { LoadingSpinner } from "./LoadingSpinner";

interface CreateUserModalProps {
  onClose: () => void;
}

export function CreateUserModal({ onClose }: CreateUserModalProps) {
  const [formData, setFormData] = useState({
    email: "",
    username: "",
    password: "",
    role: "admin" as "admin",
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [showCredentials] = useState(false);
  const [createdUser] = useState<any>(null);

  const user = currentUser.value;

  const generatePassword = () => {
    const chars =
      "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789!@#$%^&*";
    let password = "";
    for (let i = 0; i < 12; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    setFormData((prev) => ({ ...prev, password }));
  };

  const handleSubmit = async (e: Event) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const result = await authService.createUser({
        ...formData,
        created_by: user?.id,
      });

      if (result.success && result.user) {
        // Show success message instead of credentials screen
        alert(result.message || "User created successfully!");
        onClose();
      } else {
        setError(result.error || "Failed to create user");
      }
    } catch (err) {
      setError("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const handleClose = () => {
    onClose();
  };

  if (showCredentials && createdUser) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-bold text-gray-900">
              User Created Successfully
            </h2>
            <button
              onClick={handleClose}
              className="text-gray-400 hover:text-gray-600"
            >
              <X className="h-6 w-6" />
            </button>
          </div>

          <div className="space-y-4">
            <div className="bg-green-50 border border-green-200 rounded-lg p-4">
              <div className="flex items-center space-x-2 mb-3">
                <div className="bg-green-500 rounded-full p-1">
                  <User className="h-4 w-4 text-white" />
                </div>
                <h3 className="font-medium text-green-800">Account Details</h3>
              </div>

              <div className="space-y-2 text-sm">
                <div className="flex justify-between">
                  <span className="text-green-700">Email:</span>
                  <span className="font-mono text-green-900">
                    {formData.email}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-green-700">Username:</span>
                  <span className="font-mono text-green-900">
                    {formData.username}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-green-700">Password:</span>
                  <span className="font-mono text-green-900">
                    {formData.password}
                  </span>
                </div>
              </div>
            </div>

            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
              <p className="text-sm text-yellow-800">
                <strong>Important:</strong> Share these credentials securely
                with the user. They will be required to change their password on
                first login.
              </p>
            </div>

            <button onClick={handleClose} className="w-full btn btn-primary">
              Done
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-bold text-gray-900">Create New User</h2>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600"
          >
            <X className="h-6 w-6" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {error && (
            <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded text-sm">
              {error}
            </div>
          )}

          <div>
            <label className="block text-sm font-medium text-gray-700">
              Email Address *
            </label>
            <div className="mt-1 relative">
              <input
                type="email"
                required
                className="input pl-10"
                placeholder="user@example.com"
                value={formData.email}
                onInput={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    email: (e.target as HTMLInputElement).value,
                  }))
                }
              />
              <Mail className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              Username *
            </label>
            <div className="mt-1 relative">
              <input
                type="text"
                required
                className="input pl-10"
                placeholder="Enter username"
                value={formData.username}
                onInput={(e) =>
                  setFormData((prev) => ({
                    ...prev,
                    username: (e.target as HTMLInputElement).value,
                  }))
                }
              />
              <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">
              Temporary Password *
            </label>
            <div className="mt-1 flex space-x-2">
              <div className="flex-1 relative">
                <input
                  type="text"
                  required
                  className="input pl-10"
                  placeholder="Generated password"
                  value={formData.password}
                  onInput={(e) =>
                    setFormData((prev) => ({
                      ...prev,
                      password: (e.target as HTMLInputElement).value,
                    }))
                  }
                />
                <Key className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              </div>
              <button
                type="button"
                onClick={generatePassword}
                className="btn btn-secondary"
              >
                Generate
              </button>
            </div>
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded p-3 text-sm text-blue-700">
            <p className="font-medium">Note:</p>
            <p>
              The user will be required to change their password on first login.
            </p>
          </div>

          <div className="flex justify-end space-x-3 pt-4 border-t">
            <button
              type="button"
              onClick={onClose}
              className="btn btn-secondary"
              disabled={loading}
            >
              Cancel
            </button>
            <button
              type="submit"
              className="btn btn-primary"
              disabled={loading}
            >
              {loading ? (
                <>
                  <LoadingSpinner size="small" className="mr-2" />
                  Creating...
                </>
              ) : (
                "Create User"
              )}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/DashboardLayout.tsx">
import { LogOut, User, Shield } from "lucide-preact";
import { authService } from "../services/auth";
import { currentUser } from "../store/auth";

interface DashboardLayoutProps {
  title?: string;
  children: preact.ComponentChildren;
  actions?: preact.ComponentChildren;
  tabs?: {
    id: string;
    label: string;
    icon: any;
    isActive: boolean;
    onClick: () => void;
  }[];
}

export function DashboardLayout({
  children,
  actions,
  tabs,
}: DashboardLayoutProps) {
  const user = currentUser.value;

  const handleLogout = async () => {
    await authService.logout();
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Global Header */}
      <header className="bg-white border-b border-gray-200 sticky top-0 z-30">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            {/* Logo Area */}
            <div className="flex items-center gap-4">
              <div className="flex items-center gap-2">
                <div className="bg-gray-900 text-brand p-1.5 rounded-md">
                  <Shield className="h-5 w-5" />
                </div>
                <span className="text-lg font-semibold tracking-tight text-gray-900">
                  Khluys
                </span>
              </div>
              <span className="h-6 w-px bg-gray-200 mx-2"></span>
              <span className="text-xs font-medium text-gray-500 bg-gray-100 px-2 py-1 rounded border border-gray-200 uppercase tracking-wide">
                {user?.role} Dashboard
              </span>
            </div>

            {/* Right Actions */}
            <div className="flex items-center gap-4">
              <div className="flex items-center gap-3 border-r border-gray-200 pr-4">
                <div className="text-right hidden sm:block">
                  <p className="text-sm font-medium text-gray-900">
                    {user?.username}
                  </p>
                </div>
                <div className="bg-gray-100 p-1.5 rounded-full border border-gray-200">
                  <User className="h-4 w-4 text-gray-500" />
                </div>
              </div>

              <button
                onClick={handleLogout}
                className="text-gray-400 hover:text-red-600 transition-colors p-1"
                title="Sign Out"
              >
                <LogOut className="h-5 w-5" />
              </button>
            </div>
          </div>
        </div>

        {/* Navigation Tabs (Sub-header) */}
        {tabs && tabs.length > 0 && (
          <div className="border-t border-gray-100 bg-white">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
              <nav className="-mb-px flex space-x-8" aria-label="Tabs">
                {tabs.map((tab) => {
                  const Icon = tab.icon;
                  return (
                    <button
                      key={tab.id}
                      onClick={tab.onClick}
                      className={`
                        group inline-flex items-center py-3 px-1 border-b-2 font-medium text-sm transition-all duration-200
                        ${
                          tab.isActive
                            ? "border-brand text-gray-900"
                            : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300"
                        }
                      `}
                    >
                      <Icon
                        className={`
                        -ml-0.5 mr-2 h-4 w-4
                        ${
                          tab.isActive
                            ? "text-brand"
                            : "text-gray-400 group-hover:text-gray-500"
                        }
                      `}
                      />
                      {tab.label}
                    </button>
                  );
                })}
              </nav>
            </div>
          </div>
        )}
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto py-8 px-4 sm:px-6 lg:px-8 animate-fade-in">
        {actions && <div className="mb-6 flex justify-end">{actions}</div>}
        {children}
      </main>
    </div>
  );
}
</file>

<file path="frontend/src/components/LoadingSpinner.tsx">
import { clsx } from "clsx";

interface LoadingSpinnerProps {
  size?: "small" | "medium" | "large";
  className?: string;
}

export function LoadingSpinner({
  size = "medium",
  className,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    small: "w-4 h-4",
    medium: "w-6 h-6",
    large: "w-8 h-8",
  };

  return (
    <div
      className={clsx(
        "animate-spin rounded-full border-2 border-gray-300 border-t-blue-600",
        sizeClasses[size],
        className
      )}
    />
  );
}
</file>

<file path="frontend/src/components/LoginPage.tsx">
import { useState } from "preact/hooks";
import { Shield, Eye, EyeOff, ArrowRight, Lock } from "lucide-preact";
import { authService } from "../services/auth";
import { LoadingSpinner } from "./LoadingSpinner";

export function LoginPage() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleLogin = async (e: Event) => {
    e.preventDefault();
    setError("");
    setLoading(true);
    try {
      const result = await authService.login(email, password);
      if (!result.success) setError(result.error || "Login failed");
    } catch (err) {
      setError("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      {/* Brand Header */}
      <div className="sm:mx-auto sm:w-full sm:max-w-md text-center">
        <div className="mx-auto h-12 w-12 bg-gray-900 rounded-lg flex items-center justify-center shadow-sm">
          <Shield className="h-6 w-6 text-brand" />
        </div>
        <h2 className="mt-6 text-3xl font-medium tracking-tight text-gray-900">
          Khluys
        </h2>
        <p className="mt-2 text-sm text-gray-500">Premium Secure Logistics</p>
      </div>

      {/* Login Card */}
      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white py-8 px-4 shadow-sm border border-gray-200 sm:rounded-lg sm:px-10 animate-slide-up">
          <form className="space-y-6" onSubmit={handleLogin}>
            {error && (
              <div className="bg-red-50 border border-red-100 text-red-600 px-4 py-3 rounded-md text-sm flex items-center">
                <Lock className="h-4 w-4 mr-2" />
                {error}
              </div>
            )}

            <div>
              <label htmlFor="email" className="label">
                Email address
              </label>
              <input
                id="email"
                type="email"
                required
                className="input"
                placeholder="name@company.com"
                value={email}
                onInput={(e) => setEmail((e.target as HTMLInputElement).value)}
              />
            </div>

            <div>
              <label htmlFor="password" className="label">
                Password
              </label>
              <div className="relative">
                <input
                  id="password"
                  type={showPassword ? "text" : "password"}
                  required
                  className="input pr-10"
                  value={password}
                  onInput={(e) =>
                    setPassword((e.target as HTMLInputElement).value)
                  }
                />
                <button
                  type="button"
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600 transition-colors"
                  onClick={() => setShowPassword(!showPassword)}
                >
                  {showPassword ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full btn btn-primary group"
            >
              {loading ? (
                <LoadingSpinner
                  size="small"
                  className="mr-2 text-white border-white"
                />
              ) : (
                <>
                  Sign in securely
                  <ArrowRight className="ml-2 h-4 w-4 opacity-0 -translate-x-2 group-hover:opacity-100 group-hover:translate-x-0 transition-all" />
                </>
              )}
            </button>
          </form>
        </div>

        <p className="mt-6 text-center text-xs text-gray-400">
          © 2025 Khluys Security Services.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/SafesList.tsx">
import { useState } from "preact/hooks";
import {
  Shield,
  Battery,
  Lock,
  Unlock,
  MapPin,
  Activity,
  // MoreHorizontal,
} from "lucide-preact";
import { safes } from "../store/data";
import { currentUser, isOwner } from "../store/auth";
import { dataService } from "../services/data";
import { LoadingSpinner } from "./LoadingSpinner";
import { formatDistanceToNow } from "date-fns";

interface SafesListProps {
  limit?: number;
  showActions?: boolean;
}

export function SafesList({ limit, showActions = true }: SafesListProps) {
  const [updatingStatus, setUpdatingStatus] = useState<string | null>(null);
  const user = currentUser.value;
  const isOwnerRole = isOwner.value;

  let safesList = safes.value;
  if (!isOwnerRole && user) {
    safesList = safesList.filter((safe) => safe.assigned_to === user.id);
  }
  if (limit) safesList = safesList.slice(0, limit);

  const handleStatusChange = async (safeId: string, newStatus: string) => {
    if (!isOwnerRole) return;
    setUpdatingStatus(safeId);
    try {
      await dataService.updateSafeStatus(safeId, { status: newStatus as any });
    } finally {
      setUpdatingStatus(null);
    }
  };

  const getBatteryColor = (level: number) => {
    if (level > 50) return "text-green-600";
    if (level > 20) return "text-yellow-600";
    return "text-red-600";
  };

  if (safesList.length === 0) {
    return (
      <div className="text-center py-12 bg-gray-50 rounded-lg border border-dashed border-gray-300">
        <Shield className="h-10 w-10 text-gray-400 mx-auto mb-3" />
        <h3 className="text-sm font-medium text-gray-900">No safes found</h3>
        <p className="text-sm text-gray-500 mt-1">
          Register a new safe to start tracking.
        </p>
      </div>
    );
  }

  return (
    <div className="overflow-hidden border border-gray-200 rounded-lg">
      <ul className="divide-y divide-gray-100 bg-white">
        {safesList.map((safe) => (
          <li
            key={safe.id}
            className="hover:bg-gray-50 transition-colors duration-150 p-4 sm:px-6"
          >
            <div className="flex items-center justify-between gap-4">
              {/* Left: Identity */}
              <div className="flex items-center gap-4 min-w-0">
                <div
                  className={`p-2 rounded-md ${
                    safe.status === "active"
                      ? "bg-green-50 text-green-600"
                      : "bg-gray-100 text-gray-500"
                  }`}
                >
                  <Shield className="h-5 w-5" />
                </div>
                <div>
                  <div className="flex items-center gap-2">
                    <h4 className="text-sm font-medium text-gray-900">
                      {safe.serial_number}
                    </h4>
                    <span
                      className={`badge ${
                        safe.status === "active"
                          ? "badge-success"
                          : safe.status === "offline"
                          ? "badge-error"
                          : "badge-neutral"
                      }`}
                    >
                      {safe.status}
                    </span>
                  </div>
                  <div className="flex items-center gap-3 mt-1 text-xs text-gray-500">
                    <span className="font-mono text-gray-400">
                      ID: {safe.id.slice(-8)}
                    </span>
                    {safe.tracking_device_id && (
                      <span className="flex items-center gap-1">
                        <MapPin className="h-3 w-3" /> Tracked
                      </span>
                    )}
                  </div>
                </div>
              </div>

              {/* Middle: Telemetry (Hidden on small mobile) */}
              <div className="hidden sm:flex items-center gap-6 text-sm">
                <div
                  className="flex items-center gap-1.5"
                  title="Battery Level"
                >
                  <Battery
                    className={`h-4 w-4 ${getBatteryColor(safe.battery_level)}`}
                  />
                  <span className="font-medium text-gray-700">
                    {safe.battery_level}%
                  </span>
                </div>
                <div className="flex items-center gap-1.5" title="Lock Status">
                  {safe.is_locked ? (
                    <Lock className="h-4 w-4 text-gray-400" />
                  ) : (
                    <Unlock className="h-4 w-4 text-brand" />
                  )}
                  <span className="text-gray-600">
                    {safe.is_locked ? "Locked" : "Open"}
                  </span>
                </div>
                <div className="flex items-center gap-1.5 text-gray-400">
                  <Activity className="h-3 w-3" />
                  <span className="text-xs">
                    {safe.last_update
                      ? formatDistanceToNow(new Date(safe.last_update))
                      : "Never"}
                  </span>
                </div>
              </div>

              {/* Right: Actions */}
              {showActions && isOwnerRole && (
                <div className="flex items-center">
                  {updatingStatus === safe.id ? (
                    <LoadingSpinner size="small" />
                  ) : (
                    <div className="flex gap-2">
                      {safe.status === "inactive" && (
                        <button
                          onClick={() => handleStatusChange(safe.id, "active")}
                          className="btn btn-secondary text-xs h-8 py-0"
                        >
                          Activate
                        </button>
                      )}
                      {safe.status === "active" && (
                        <button
                          onClick={() =>
                            handleStatusChange(safe.id, "maintenance")
                          }
                          className="btn btn-ghost text-xs"
                        >
                          Maintenance
                        </button>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
</file>

<file path="frontend/src/components/StatsCards.tsx">
import { Shield, Package, Activity, TrendingUp } from "lucide-preact";

interface StatsCardsProps {
  stats: {
    totalSafes: number;
    activeSafes: number;
    totalTrips: number;
    activeTrips: number;
  };
}

export function StatsCards({ stats }: StatsCardsProps) {
  const cards = [
    { label: "Total Safes", value: stats.totalSafes, icon: Shield },
    {
      label: "Active Safes",
      value: stats.activeSafes,
      icon: Activity,
      active: true,
    },
    { label: "Total Trips", value: stats.totalTrips, icon: Package },
    {
      label: "In Transit",
      value: stats.activeTrips,
      icon: TrendingUp,
      active: true,
    },
  ];

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-6">
      {cards.map((card) => (
        <div
          key={card.label}
          className="bg-white rounded-lg border border-gray-200 p-5 hover:border-gray-300 transition-colors duration-200 shadow-sm"
        >
          <div className="flex justify-between items-start">
            <div>
              <p className="text-sm font-medium text-gray-500">{card.label}</p>
              <h3 className="mt-2 text-3xl font-medium text-gray-900 tracking-tight">
                {card.value}
              </h3>
            </div>
            <div
              className={`p-2 rounded-md ${
                card.active
                  ? "bg-brand-light text-brand"
                  : "bg-gray-50 text-gray-400"
              }`}
            >
              <card.icon className="h-5 w-5" />
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}
</file>

<file path="frontend/src/lib/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables");
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
  },
});

// Database types (will be auto-generated from Supabase CLI)
export type Database = {
  public: {
    Tables: {
      users: {
        Row: {
          id: string;
          email: string;
          username: string;
          role: "owner" | "admin";
          created_by: string | null;
          must_change_password: boolean;
          is_active: boolean;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          email: string;
          username: string;
          role: "owner" | "admin";
          created_by?: string | null;
          must_change_password?: boolean;
          is_active?: boolean;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          email?: string;
          username?: string;
          role?: "owner" | "admin";
          created_by?: string | null;
          must_change_password?: boolean;
          is_active?: boolean;
          created_at?: string;
          updated_at?: string;
        };
      };
      safes: {
        Row: {
          id: string;
          serial_number: string;
          device_hash: string;
          status: "active" | "inactive" | "maintenance" | "offline";
          battery_level: number;
          is_locked: boolean;
          tracking_device_id: string | null;
          assigned_to: string;
          last_update: string | null;
          created_at: string;
        };
        Insert: {
          id?: string;
          serial_number: string;
          device_hash: string;
          status?: "active" | "inactive" | "maintenance" | "offline";
          battery_level?: number;
          is_locked?: boolean;
          tracking_device_id?: string | null;
          assigned_to: string;
          last_update?: string | null;
          created_at?: string;
        };
        Update: {
          id?: string;
          serial_number?: string;
          device_hash?: string;
          status?: "active" | "inactive" | "maintenance" | "offline";
          battery_level?: number;
          is_locked?: boolean;
          tracking_device_id?: string | null;
          assigned_to?: string;
          last_update?: string | null;
          created_at?: string;
        };
      };
      trips: {
        Row: {
          id: string;
          safe_id: string;
          client_name: string;
          pickup_address: string;
          delivery_address: string;
          status: "pending" | "in_transit" | "delivered" | "cancelled";
          scheduled_pickup: string;
          scheduled_delivery: string;
          instructions: string | null;
          created_by: string;
          created_at: string;
          updated_at: string;
          tracking_token: string;
          customer_tracking_enabled: boolean;
          client_phone: string | null;
          client_email: string | null;
          pickup_contact_name: string | null;
          pickup_contact_phone: string | null;
          delivery_contact_name: string | null;
          delivery_contact_phone: string | null;
          priority: "low" | "normal" | "high" | "urgent" | null;
          special_instructions: string | null;
          delivery_notes: string | null;
          requires_signature: boolean | null;
          actual_pickup_time: string | null;
          actual_delivery_time: string | null;
          cancellation_reason: string | null;
          cancelled_at: string | null;
          recurring_config: any | null;
        };
        Insert: {
          id?: string;
          safe_id: string;
          client_name: string;
          pickup_address: string;
          delivery_address: string;
          status?: "pending" | "in_transit" | "delivered" | "cancelled";
          scheduled_pickup: string;
          scheduled_delivery: string;
          instructions?: string | null;
          created_by: string;
          created_at?: string;
          updated_at?: string;
          tracking_token?: string;
          customer_tracking_enabled?: boolean;
          client_phone?: string | null;
          client_email?: string | null;
          pickup_contact_name?: string | null;
          pickup_contact_phone?: string | null;
          delivery_contact_name?: string | null;
          delivery_contact_phone?: string | null;
          priority?: "low" | "normal" | "high" | "urgent" | null;
          special_instructions?: string | null;
          delivery_notes?: string | null;
          requires_signature?: boolean | null;
          actual_pickup_time?: string | null;
          actual_delivery_time?: string | null;
          cancellation_reason?: string | null;
          cancelled_at?: string | null;
          recurring_config?: any | null;
        };
        Update: {
          id?: string;
          safe_id?: string;
          client_name?: string;
          pickup_address?: string;
          delivery_address?: string;
          status?: "pending" | "in_transit" | "delivered" | "cancelled";
          scheduled_pickup?: string;
          scheduled_delivery?: string;
          instructions?: string | null;
          created_by?: string;
          created_at?: string;
          updated_at?: string;
          tracking_token?: string;
          customer_tracking_enabled?: boolean;
          client_phone?: string | null;
          client_email?: string | null;
          pickup_contact_name?: string | null;
          pickup_contact_phone?: string | null;
          delivery_contact_name?: string | null;
          delivery_contact_phone?: string | null;
          priority?: "low" | "normal" | "high" | "urgent" | null;
          special_instructions?: string | null;
          delivery_notes?: string | null;
          requires_signature?: boolean | null;
          actual_pickup_time?: string | null;
          actual_delivery_time?: string | null;
          cancellation_reason?: string | null;
          cancelled_at?: string | null;
          recurring_config?: any | null;
        };
      };
    };
  };
};
</file>

<file path="frontend/src/services/mobileUsers.ts">
import { supabase } from "../lib/supabase";

export interface CreateMobileUserData {
  safe_id: string;
  driver_name?: string;
}

export interface MobileUserCredentials {
  username: string;
  password: string;
}

class MobileUserService {
  generateUsername(serialNumber: string): string {
    return serialNumber.toLowerCase().replace(/[^a-z0-9]/g, "") + "_driver";
  }

  generatePassword(): string {
    const chars =
      "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$%^&*";
    let password = "";
    for (let i = 0; i < 12; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return password;
  }

  // Hash password using Edge Function
  private async hashPassword(password: string): Promise<string> {
    const {
      data: { session },
    } = await supabase.auth.getSession();

    if (!session) {
      throw new Error("Authentication required");
    }

    const { data, error } = await supabase.functions.invoke("hash-password", {
      headers: {
        Authorization: `Bearer ${session.access_token}`,
      },
      body: { password },
    });

    if (error || !data?.hash) {
      console.error("Password hashing failed:", error);
      throw new Error("Failed to hash password");
    }

    return data.hash;
  }

  async createMobileUser(
    safeId: string,
    serialNumber: string,
    driverName?: string
  ): Promise<{
    success: boolean;
    credentials?: MobileUserCredentials;
    error?: string;
  }> {
    try {
      const username = this.generateUsername(serialNumber);
      const password = this.generatePassword();

      // Hash password via Edge Function
      const passwordHash = await this.hashPassword(password);

      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) {
        return { success: false, error: "User not authenticated" };
      }

      const { error } = await supabase
        .from("mobile_users")
        .insert({
          safe_id: safeId,
          username,
          password_hash: passwordHash,
          driver_name: driverName,
          created_by: user.id,
        })
        .select()
        .single();

      if (error) {
        console.error("Failed to create mobile user:", error);
        return { success: false, error: error.message };
      }

      return {
        success: true,
        credentials: { username, password },
      };
    } catch (err) {
      console.error("Exception creating mobile user:", err);
      return { success: false, error: "Failed to create mobile user" };
    }
  }

  async deactivateMobileUser(
    safeId: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const { error } = await supabase
        .from("mobile_users")
        .update({
          is_active: false,
          updated_at: new Date().toISOString(),
        })
        .eq("safe_id", safeId);

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true };
    } catch (err) {
      return { success: false, error: "Failed to deactivate mobile user" };
    }
  }

  async getMobileUserBySafe(safeId: string) {
    try {
      const { data, error } = await supabase
        .from("mobile_users")
        .select("*")
        .eq("safe_id", safeId)
        .eq("is_active", true)
        .single();

      if (error && error.code !== "PGRST116") {
        console.error("Failed to get mobile user:", error);
        return null;
      }

      return data;
    } catch (err) {
      console.error("Exception getting mobile user:", err);
      return null;
    }
  }
}

export const mobileUserService = new MobileUserService();
</file>

<file path="frontend/src/store/auth.ts">
import { signal, computed } from "@preact/signals";
import type { User, AuthState } from "../types";

// Auth state signal
export const authState = signal<AuthState>({
  user: null,
  loading: true,
  isAuthenticated: false,
});

// Computed values
export const currentUser = computed(() => authState.value.user);
export const isOwner = computed(() => authState.value.user?.role === "owner");
export const isAdmin = computed(() => authState.value.user?.role === "admin");
export const isAuthenticated = computed(() => authState.value.isAuthenticated);
export const isLoading = computed(() => authState.value.loading);

// Auth actions
export const authActions = {
  setUser: (user: User | null) => {
    authState.value = {
      user,
      loading: false,
      isAuthenticated: !!user,
    };
  },

  setLoading: (loading: boolean) => {
    authState.value = {
      ...authState.value,
      loading,
    };
  },

  logout: () => {
    authState.value = {
      user: null,
      loading: false,
      isAuthenticated: false,
    };
  },

  updateUser: (updates: Partial<User>) => {
    if (authState.value.user) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          ...updates,
        },
      };
    }
  },
};
</file>

<file path="mobile/.gitignore">
# Environment variables
.env
.env.local
.env.production

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="mobile/android/app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>
</file>

<file path="mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="mobile/android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="mobile/android/app/src/main/res/values/strings.xml">
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">Khluys</string>
    <string name="title_activity_main">Khluys</string>
    <string name="package_name">com.khluys.mobile</string>
    <string name="custom_url_scheme">com.khluys.mobile</string>
</resources>
</file>

<file path="mobile/package.json">
{
  "name": "mobile",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@capacitor-community/bluetooth-le": "^7.2.0",
    "@capacitor/android": "^7.4.3",
    "@capacitor/core": "^7.4.3",
    "@capacitor/geolocation": "^7.1.5",
    "@capacitor/haptics": "^7.0.2",
    "@capacitor/status-bar": "^7.0.3",
    "@preact/signals": "^2.3.1",
    "@supabase/supabase-js": "^2.57.4",
    "@tailwindcss/vite": "^4.1.13",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-preact": "^0.544.0",
    "preact": "^10.26.5",
    "tailwindcss": "^4.1.13"
  },
  "devDependencies": {
    "@capacitor/cli": "^7.4.3",
    "@preact/preset-vite": "^2.10.1",
    "typescript": "~5.8.3",
    "vite": "^6.3.5"
  }
}
</file>

<file path="mobile/src/main.tsx">
import { render } from "preact";
import { App } from "./app.tsx";
import "./index.css";

render(<App />, document.getElementById("app")!);
</file>

<file path="mobile/src/store/auth.ts">
import { signal, computed } from "@preact/signals";

interface MobileUser {
  id: string;
  username: string;
  driver_name?: string;
  safe_id: string;
  safe: {
    id: string;
    serial_number: string;
    status: string;
    battery_level: number;
    is_locked: boolean;
    tracking_device_id?: string;
  } | null; // Allow null
  is_active: boolean;
  created_at: string;
}

interface MobileAuthState {
  user: MobileUser | null;
  loading: boolean;
  isAuthenticated: boolean;
}

// Auth state signal
export const authState = signal<MobileAuthState>({
  user: null,
  loading: true,
  isAuthenticated: false,
});

// Computed values
export const currentUser = computed(() => authState.value.user);
export const currentSafe = computed(() => authState.value.user?.safe || null);
export const isAuthenticated = computed(() => authState.value.isAuthenticated);
export const isLoading = computed(() => authState.value.loading);

// Auth actions
export const authActions = {
  setUser: (user: MobileUser | null) => {
    authState.value = {
      user,
      loading: false,
      isAuthenticated: !!user,
    };
  },

  setLoading: (loading: boolean) => {
    authState.value = {
      ...authState.value,
      loading,
    };
  },

  logout: () => {
    authState.value = {
      user: null,
      loading: false,
      isAuthenticated: false,
    };
  },

  updateUser: (updates: Partial<MobileUser>) => {
    if (authState.value.user) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          ...updates,
        },
      };
    }
  },

  updateSafe: (safeUpdates: Partial<NonNullable<MobileUser["safe"]>>) => {
    if (authState.value.user && authState.value.user.safe) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          safe: {
            ...authState.value.user.safe,
            ...safeUpdates,
          },
        },
      };
    }
  },
};
</file>

<file path="mobile/src/store/trips.ts">
import { signal, computed } from "@preact/signals";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

interface TripsState {
  trips: TripData[];
  loading: boolean;
  error: string | null;
  activeTrip: TripData | null;
}

// Trips state
export const tripsState = signal<TripsState>({
  trips: [],
  loading: false,
  error: null,
  activeTrip: null,
});

// Computed values
export const currentTrips = computed(() => tripsState.value.trips);
export const activeTrip = computed(() => tripsState.value.activeTrip);
export const isLoading = computed(() => tripsState.value.loading);
export const error = computed(() => tripsState.value.error);

// Get pending trips (not started yet)
export const pendingTrips = computed(() =>
  tripsState.value.trips.filter((trip) => trip.status === "pending")
);

// Get in-transit trip (should only be one)
export const inTransitTrip = computed(() =>
  tripsState.value.trips.find((trip) => trip.status === "in_transit")
);

// Actions
export const tripsActions = {
  setTrips: (trips: TripData[]) => {
    tripsState.value = {
      ...tripsState.value,
      trips,
      error: null,
      // Set active trip to in-transit or next pending
      activeTrip:
        trips.find((t) => t.status === "in_transit") ||
        trips.find((t) => t.status === "pending") ||
        null,
    };
  },

  addTrip: (trip: TripData) => {
    const newTrips = [...tripsState.value.trips, trip];
    tripsState.value = {
      ...tripsState.value,
      trips: newTrips,
      activeTrip:
        trip.status === "pending" && !tripsState.value.activeTrip
          ? trip
          : tripsState.value.activeTrip,
    };
  },

  updateTrip: (tripId: string, updates: Partial<TripData>) => {
    const updatedTrips = tripsState.value.trips.map((trip) =>
      trip.id === tripId ? { ...trip, ...updates } : trip
    );

    tripsState.value = {
      ...tripsState.value,
      trips: updatedTrips,
      activeTrip:
        tripsState.value.activeTrip?.id === tripId
          ? { ...tripsState.value.activeTrip, ...updates }
          : tripsState.value.activeTrip,
    };
  },

  setActiveTrip: (trip: TripData | null) => {
    tripsState.value = {
      ...tripsState.value,
      activeTrip: trip,
    };
  },

  setLoading: (loading: boolean) => {
    tripsState.value = {
      ...tripsState.value,
      loading,
    };
  },

  setError: (error: string | null) => {
    tripsState.value = {
      ...tripsState.value,
      error,
      loading: false,
    };
  },

  clearError: () => {
    tripsState.value = {
      ...tripsState.value,
      error: null,
    };
  },
};
</file>

<file path="mobile/src/utils/validation.ts">
// OTP validation
export function validateOTP(otp: string): { valid: boolean; error?: string } {
  if (!otp || typeof otp !== "string") {
    return { valid: false, error: "OTP is required" };
  }

  const cleaned = otp.trim();

  if (!/^\d{6}$/.test(cleaned)) {
    return { valid: false, error: "OTP must be exactly 6 digits" };
  }

  return { valid: true };
}

// Username validation
export function validateUsername(username: string): {
  valid: boolean;
  error?: string;
} {
  if (!username || typeof username !== "string") {
    return { valid: false, error: "Username is required" };
  }

  const trimmed = username.trim();

  if (trimmed.length < 3) {
    return { valid: false, error: "Username must be at least 3 characters" };
  }

  if (trimmed.length > 50) {
    return { valid: false, error: "Username is too long" };
  }

  return { valid: true };
}

// Password validation
export function validatePassword(password: string): {
  valid: boolean;
  error?: string;
} {
  if (!password || typeof password !== "string") {
    return { valid: false, error: "Password is required" };
  }

  if (password.length < 4) {
    return { valid: false, error: "Password must be at least 4 characters" };
  }

  if (password.length > 128) {
    return { valid: false, error: "Password is too long" };
  }

  return { valid: true };
}

// Sanitize text input
export function sanitizeText(text: string, maxLength: number = 500): string {
  if (!text || typeof text !== "string") {
    return "";
  }

  return text.trim().slice(0, maxLength).replace(/[<>]/g, ""); // Remove angle brackets
}
</file>

<file path="mobile/vite.config.ts">
import { defineConfig } from "vite";
import preact from "@preact/preset-vite";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact(), tailwindcss()],
  define: {
    global: "globalThis",
  },
  server: {
    host: "0.0.0.0",
    port: 5174,
  },
});
</file>

<file path="frontend/src/components/UsersList.tsx">
import { useState, useEffect } from "preact/hooks";
import { User, Shield } from "lucide-preact"; // Calendar, MoreVertical,
import { supabase } from "../lib/supabase";
import { LoadingSpinner } from "./LoadingSpinner";
import { format } from "date-fns";

interface UserData {
  id: string;
  username: string;
  role: string;
  is_active: boolean;
  created_at: string;
}

export function UsersList() {
  const [users, setUsers] = useState<UserData[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    try {
      const { data } = await supabase
        .from("profiles")
        .select("*")
        .order("created_at", { ascending: false });
      setUsers(data || []);
    } finally {
      setLoading(false);
    }
  };

  const toggleStatus = async (userId: string, current: boolean) => {
    await supabase
      .from("profiles")
      .update({ is_active: !current })
      .eq("id", userId);
    loadUsers();
  };

  if (loading)
    return (
      <div className="py-8 text-center">
        <LoadingSpinner />
      </div>
    );

  return (
    <div className="border border-gray-200 rounded-lg overflow-hidden bg-white">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              User
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Role
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Status
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
              Joined
            </th>
            <th className="relative px-6 py-3">
              <span className="sr-only">Actions</span>
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {users.map((user) => (
            <tr key={user.id} className="hover:bg-gray-50">
              <td className="px-6 py-4 whitespace-nowrap">
                <div className="flex items-center">
                  <div className="flex-shrink-0 h-8 w-8 rounded-full bg-gray-100 flex items-center justify-center text-gray-500">
                    <User className="h-4 w-4" />
                  </div>
                  <div className="ml-4">
                    <div className="text-sm font-medium text-gray-900">
                      {user.username}
                    </div>
                  </div>
                </div>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <div className="flex items-center text-sm text-gray-500 capitalize">
                  {user.role === "owner" && (
                    <Shield className="h-3 w-3 mr-1 text-purple-500" />
                  )}
                  {user.role}
                </div>
              </td>
              <td className="px-6 py-4 whitespace-nowrap">
                <span
                  className={`badge ${
                    user.is_active ? "badge-success" : "badge-neutral"
                  }`}
                >
                  {user.is_active ? "Active" : "Inactive"}
                </span>
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                {format(new Date(user.created_at), "MMM d, yyyy")}
              </td>
              <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <button
                  onClick={() => toggleStatus(user.id, user.is_active)}
                  className={`text-xs hover:underline ${
                    user.is_active ? "text-red-600" : "text-green-600"
                  }`}
                >
                  {user.is_active ? "Deactivate" : "Activate"}
                </button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  );
}
</file>

<file path="frontend/src/main.tsx">
import { render } from "preact";
import App from "./app.tsx";
import "./index.css";
import { trackPageLoad } from "./utils/performance";

trackPageLoad();

render(<App />, document.getElementById("app")!);
</file>

<file path="mobile/android/app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode|navigation"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <intent-filter android:autoVerify="true">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data android:scheme="https" />
                <data android:host="guardian-safe-1uv582r1n-majorbeards-projects.vercel.app" />
            </intent-filter>

        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"></meta-data>
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
</manifest>
</file>

<file path="mobile/src/components/TripCard.tsx">
import {
  // MapPin,
  Calendar,
  // Clock,
  AlertTriangle,
  ArrowRight,
} from "lucide-preact";
import { format, isPast } from "date-fns";

interface TripCardProps {
  trip: {
    id: string;
    client_name: string;
    pickup_address: string;
    delivery_address: string;
    status: string;
    scheduled_pickup: string;
    scheduled_delivery: string;
    priority?: string;
  };
  onStartTrip?: () => void;
  onViewDetails?: () => void;
  variant?: "default" | "active";
}

export function TripCard({
  trip,
  onStartTrip,
  onViewDetails,
  variant = "default",
}: TripCardProps) {
  const isOverdue =
    isPast(new Date(trip.scheduled_pickup)) && trip.status === "pending";
  const isHighPriority = trip.priority === "high" || trip.priority === "urgent";

  if (variant === "active") {
    return (
      <div className="bg-brand text-white rounded-xl p-5 shadow-lg shadow-brand/30 relative overflow-hidden">
        <div className="absolute top-0 right-0 -mt-4 -mr-4 w-24 h-24 bg-white/10 rounded-full blur-xl pointer-events-none"></div>

        <div className="relative z-10">
          <div className="flex justify-between items-start mb-4">
            <span className="bg-white/20 text-white text-[10px] font-bold px-2 py-1 rounded uppercase tracking-wider backdrop-blur-sm">
              In Progress
            </span>
            <span className="text-white/80 font-mono text-xs">
              #{trip.id.slice(-4)}
            </span>
          </div>

          <h3 className="text-xl font-bold mb-1 truncate">
            {trip.client_name}
          </h3>
          <p className="text-white/90 text-sm mb-6 line-clamp-2">
            {trip.delivery_address}
          </p>

          <button className="w-full bg-white text-brand font-bold py-3 rounded-lg shadow-sm flex items-center justify-center gap-2 active:scale-[0.98] transition-transform">
            Continue <ArrowRight className="h-4 w-4" />
          </button>
        </div>
      </div>
    );
  }

  return (
    <div
      onClick={onViewDetails}
      className="bg-white rounded-xl border border-gray-200 p-4 shadow-sm active:bg-gray-50 transition-colors relative overflow-hidden"
    >
      {/* Priority Stripe */}
      {isHighPriority && (
        <div className="absolute left-0 top-0 bottom-0 w-1 bg-red-500"></div>
      )}

      <div className="flex justify-between items-start mb-3 pl-2">
        <div>
          <h3 className="font-semibold text-gray-900">{trip.client_name}</h3>
          {isOverdue && (
            <div className="flex items-center gap-1 text-red-600 text-xs font-medium mt-0.5">
              <AlertTriangle className="h-3 w-3" /> Overdue
            </div>
          )}
        </div>
        <div className="text-right">
          <span className="text-xs font-mono text-gray-400">
            #{trip.id.slice(-4)}
          </span>
        </div>
      </div>

      <div className="space-y-2 pl-2 mb-4">
        <div className="flex items-start gap-2">
          <div className="mt-0.5 w-1.5 h-1.5 rounded-full bg-gray-300 flex-shrink-0"></div>
          <p className="text-xs text-gray-500 line-clamp-1">
            {trip.pickup_address}
          </p>
        </div>
        <div className="flex items-start gap-2">
          <div className="mt-0.5 w-1.5 h-1.5 rounded-full bg-brand flex-shrink-0"></div>
          <p className="text-xs text-gray-900 font-medium line-clamp-1">
            {trip.delivery_address}
          </p>
        </div>
      </div>

      <div className="flex items-center justify-between pl-2 pt-3 border-t border-gray-50">
        <div className="flex items-center gap-1.5 text-xs text-gray-500">
          <Calendar className="h-3.5 w-3.5" />
          {format(new Date(trip.scheduled_pickup), "MMM d, HH:mm")}
        </div>

        {onStartTrip && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onStartTrip();
            }}
            className="bg-gray-900 text-white text-xs font-medium px-3 py-1.5 rounded-md shadow-sm hover:bg-gray-800 transition-colors"
          >
            Start Trip
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="mobile/src/services/tracknetics.ts">
import { supabase } from "./supabase";

interface TrackneticsCredentials {
  username: string;
  password: string;
  apiKey?: string;
}

interface LoginResponse {
  state: string;
  userInfo?: {
    userID: string;
    userName: string;
    loginName: string;
    timeZone: string;
    address: string;
    cellPhone: string;
    key: string;
  };
}

interface DeviceInfo {
  id: string;
  sn: string; // IMEI
  name: string;
  status: string;
  speed?: string;
}

interface LocationData {
  state: string;
  positionTime?: string;
  lat?: string;
  lng?: string;
  speed?: string;
  course?: string;
  isStop?: string;
  stm?: string;
  isGPS?: string;
  status?: string;
}

class TrackneticsService {
  private credentials: TrackneticsCredentials;
  private currentSession: { userID?: string; key?: string } | null = null;

  constructor() {
    this.credentials = {
      username: import.meta.env.VITE_TRACKNETICS_USERNAME || "",
      password: import.meta.env.VITE_TRACKNETICS_PASSWORD || "",
      apiKey: import.meta.env.VITE_TRACKNETICS_API_KEY || "",
    };
  }

  // Make API call through Supabase Edge Function proxy
  private async apiCall(
    operation: string,
    params: Record<string, any> = {}
  ): Promise<any> {
    try {
      const { data, error } = await supabase.functions.invoke(
        "tracknetics-proxy",
        {
          body: {
            operation,
            params,
          },
        }
      );

      if (error) {
        console.error("Proxy call error:", error);
        throw new Error(`Proxy error: ${error.message}`);
      }

      return data;
    } catch (err) {
      console.error("API call failed:", err);
      throw err;
    }
  }

  // Login and get authentication key
  async login(): Promise<{ success: boolean; error?: string }> {
    try {
      const data: LoginResponse = await this.apiCall("Login", {
        name: this.credentials.username,
        pass: this.credentials.password,
      });

      if (data.state === "0" && data.userInfo) {
        this.currentSession = {
          userID: data.userInfo.userID,
          key: data.userInfo.key,
        };
        return { success: true };
      } else {
        console.error("Tracknetics login failed:", data);
        const errorMessage = this.getErrorMessage(data.state);
        return { success: false, error: `Login failed: ${errorMessage}` };
      }
    } catch (error: any) {
      console.error("Tracknetics login error:", error);
      return {
        success: false,
        error: error.message || "Network error during login",
      };
    }
  }

  // Ensure we have a valid session
  private async ensureAuthenticated(): Promise<boolean> {
    if (!this.currentSession?.key) {
      const loginResult = await this.login();
      return loginResult.success;
    }
    return true;
  }

  // Get list of devices
  async getDeviceList(): Promise<{
    success: boolean;
    devices?: DeviceInfo[];
    error?: string;
  }> {
    if (
      !(await this.ensureAuthenticated()) ||
      !this.currentSession?.userID ||
      !this.currentSession?.key
    ) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceList", {
        ID: this.currentSession.userID,
        PageNo: 1,
        PageCount: 100,
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, devices: data.arr || [] };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get devices: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device list:", error);
      return {
        success: false,
        error: error.message || "Network error getting device list",
      };
    }
  }

  // Get real-time location for a device by ID
  async getDeviceLocation(
    deviceId: string
  ): Promise<{ success: boolean; location?: LocationData; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data: LocationData = await this.apiCall("GetTracking", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        MapType: "google",
        Language: "en-us",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, location: data };
      } else if (data.state === "2002") {
        return { success: false, error: "No location data available" };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get location: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device location:", error);
      return {
        success: false,
        error: error.message || "Network error getting location",
      };
    }
  }

  // Get location by device ID (simplified method for direct calls)
  async getLocationByDeviceId(deviceId: string): Promise<{
    success: boolean;
    location?: {
      lat: number;
      lng: number;
      accuracy: number;
      timestamp: number;
    };
    error?: string;
  }> {
    const locationResult = await this.getDeviceLocation(deviceId);

    if (!locationResult.success || !locationResult.location) {
      return { success: false, error: locationResult.error };
    }

    const location = locationResult.location;

    // Convert to standard format
    if (location.lat && location.lng) {
      const standardLocation = {
        lat: parseFloat(location.lat),
        lng: parseFloat(location.lng),
        accuracy: location.isGPS === "1" ? 10 : 100, // GPS vs LBS accuracy estimate
        timestamp: location.positionTime
          ? new Date(location.positionTime).getTime()
          : Date.now(),
      };

      return {
        success: true,
        location: standardLocation,
      };
    }

    return { success: false, error: "Invalid location data received" };
  }

  // Create geofence for delivery location
  async createDeliveryGeofence(
    deviceId: string,
    name: string,
    lat: number,
    lng: number,
    radiusMeters: number = 100
  ): Promise<{ success: boolean; geofenceId?: string; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("SaveGeofence", {
        DeviceID: deviceId,
        GeofenceName: name,
        Remark: "Delivery Location",
        Lat: lat,
        Lng: lng,
        Radius: radiusMeters,
        GeofenceID: 0,
        MapType: "google",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, geofenceId: data.geofenceID };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to create geofence: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error creating geofence:", error);
      return {
        success: false,
        error: error.message || "Network error creating geofence",
      };
    }
  }

  // Get device details by ID
  async getDeviceDetails(
    deviceId: string
  ): Promise<{ success: boolean; device?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceDetail", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        Key: this.currentSession.key,
      });
      if (data.state === "0") {
        return { success: true, device: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device details: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device details:", error);
      return {
        success: false,
        error: error.message || "Network error getting device details",
      };
    }
  }

  // Get device history/playback
  async getDeviceHistory(
    deviceId: string,
    startTime: string,
    endTime: string
  ): Promise<{ success: boolean; history?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDevicesHistory", {
        DeviceID: deviceId,
        StartTime: startTime,
        EndTime: endTime,
        TimeZones: "South Africa Standard Time",
        ShowLBS: 0,
        MapType: "google",
        SelectCount: 1000,
        Key: this.currentSession.key,
      });
      if (data.state === "0") {
        return { success: true, history: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device history: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device history:", error);
      return {
        success: false,
        error: error.message || "Network error getting device history",
      };
    }
  }

  // Logout
  async logout(): Promise<void> {
    if (this.currentSession?.userID && this.currentSession?.key) {
      try {
        await this.apiCall("Exit", {
          ID: this.currentSession.userID,
          Key: this.currentSession.key,
        });
      } catch (error) {
        console.error("Error during logout:", error);
      }
    }
    this.currentSession = null;
  }

  // Helper to decode Tracknetics error states
  private getErrorMessage(state: string): string {
    const errorCodes: Record<string, string> = {
      "0": "Success",
      "1001": "Parameter error",
      "1002": "Program error",
      "2001": "Username or password error",
      "2002": "No result",
      "2003": "Car number already exists",
      "2004": "Fail to modify",
      "2005": "Modify success",
      "2020": "Username already exists",
      "2021": "It has sub account, cannot be deleted",
      "2022": "It has device, cannot be deleted",
      "2023": "Username does not exist",
      "3001": "KEY incorrect",
      "3004": "Maintenance...",
    };

    return errorCodes[state] || `Unknown error (${state})`;
  }
}

export const trackneticsService = new TrackneticsService();
</file>

<file path="frontend/src/components/OwnerDashboard.tsx">
import { useState } from "preact/hooks";
import { Plus, Users, Shield, Package, Activity, MapPin } from "lucide-preact";
import { DashboardLayout } from "./DashboardLayout";
import { CreateUserModal } from "./CreateUserModal";
import { CreateSafeModal } from "./CreateSafeModal";
import { UsersList } from "./UsersList";
import { SafesList } from "./SafesList";
import { TripsList } from "./TripsList";
import { StatsCards } from "./StatsCards";
import { LiveTracking } from "./LiveTracking"; // Added import
import { safes, trips } from "../store/data";

export function OwnerDashboard() {
  const [showCreateUser, setShowCreateUser] = useState(false);
  const [showCreateSafe, setShowCreateSafe] = useState(false);
  const [activeTab, setActiveTab] = useState<
    "overview" | "users" | "safes" | "trips" | "tracking"
  >("overview");

  const safesList = safes.value;
  const tripsList = trips.value;

  const stats = {
    totalSafes: safesList.length,
    activeSafes: safesList.filter((s) => s.status === "active").length,
    totalTrips: tripsList.length,
    activeTrips: tripsList.filter((t) => t.status === "in_transit").length,
  };

  // Define Tabs Configuration - Added Tracking Tab
  const tabs = [
    {
      id: "overview",
      label: "Overview",
      icon: Activity,
      isActive: activeTab === "overview",
      onClick: () => setActiveTab("overview"),
    },
    {
      id: "users",
      label: "Users",
      icon: Users,
      isActive: activeTab === "users",
      onClick: () => setActiveTab("users"),
    },
    {
      id: "safes",
      label: "Safes",
      icon: Shield,
      isActive: activeTab === "safes",
      onClick: () => setActiveTab("safes"),
    },
    {
      id: "trips",
      label: "Trips",
      icon: Package,
      isActive: activeTab === "trips",
      onClick: () => setActiveTab("trips"),
    },
    {
      id: "tracking",
      label: "Live Fleet",
      icon: MapPin,
      isActive: activeTab === "tracking",
      onClick: () => setActiveTab("tracking"),
    },
  ];

  // Context-aware Actions
  const actions = (
    <div className="flex space-x-3">
      {activeTab === "users" && (
        <button
          onClick={() => setShowCreateUser(true)}
          className="btn btn-secondary"
        >
          <Users className="h-4 w-4 mr-2" /> Add User
        </button>
      )}
      {(activeTab === "safes" ||
        activeTab === "overview" ||
        activeTab === "tracking") && (
        <button
          onClick={() => setShowCreateSafe(true)}
          className="btn btn-primary"
        >
          <Plus className="h-4 w-4 mr-2" /> Register Safe
        </button>
      )}
    </div>
  );

  return (
    <>
      <DashboardLayout tabs={tabs as any} actions={actions}>
        {activeTab === "overview" && (
          <div className="space-y-8 animate-fade-in">
            <StatsCards stats={stats} />

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <div className="card">
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-lg font-medium text-gray-900">
                    Recent Safes
                  </h3>
                  <button
                    onClick={() => setActiveTab("safes")}
                    className="text-sm text-brand hover:text-brand-hover"
                  >
                    View all
                  </button>
                </div>
                <SafesList limit={5} showActions={false} />
              </div>

              <div className="card">
                <div className="flex items-center justify-between mb-6">
                  <h3 className="text-lg font-medium text-gray-900">
                    Recent Trips
                  </h3>
                  <button
                    onClick={() => setActiveTab("trips")}
                    className="text-sm text-brand hover:text-brand-hover"
                  >
                    View all
                  </button>
                </div>
                <TripsList limit={5} showActions={false} />
              </div>
            </div>
          </div>
        )}

        {activeTab === "users" && (
          <div className="animate-fade-in">
            <UsersList />
          </div>
        )}
        {activeTab === "safes" && (
          <div className="animate-fade-in">
            <SafesList />
          </div>
        )}
        {activeTab === "trips" && (
          <div className="animate-fade-in">
            <TripsList />
          </div>
        )}

        {/* Owner sees ALL safes on the map at all times */}
        {activeTab === "tracking" && (
          <div className="animate-fade-in">
            <LiveTracking safes={safesList} />
          </div>
        )}
      </DashboardLayout>

      {showCreateUser && (
        <CreateUserModal onClose={() => setShowCreateUser(false)} />
      )}
      {showCreateSafe && (
        <CreateSafeModal onClose={() => setShowCreateSafe(false)} />
      )}
    </>
  );
}
</file>

<file path="frontend/src/components/TripsList.tsx">
import { useState } from "preact/hooks";
import { MapPin, Clock, Navigation, ExternalLink } from "lucide-preact";
import { trips, safes } from "../store/data";
import { currentUser, isOwner } from "../store/auth";
import { dataService } from "../services/data";
import { LoadingSpinner } from "./LoadingSpinner";
import { TripTrackingModal } from "./TripTrackingModal";
import { format, isPast } from "date-fns";

interface TripsListProps {
  limit?: number;
  showActions?: boolean;
  compact?: boolean;
}

export function TripsList({
  limit,
  showActions = true,
  compact = false,
}: TripsListProps) {
  const [updatingStatus, setUpdatingStatus] = useState<string | null>(null);
  const [trackingTrip, setTrackingTrip] = useState<any>(null);

  const user = currentUser.value;
  const isOwnerRole = isOwner.value;
  let tripsList = trips.value;
  const safesList = safes.value;

  if (!isOwnerRole && user) {
    const userSafeIds = safesList
      .filter((safe) => safe.assigned_to === user.id)
      .map((safe) => safe.id);
    tripsList = tripsList.filter((trip) => userSafeIds.includes(trip.safe_id));
  }

  if (limit) tripsList = tripsList.slice(0, limit);

  const getStatusBadge = (status: string) => {
    const styles = {
      pending: "badge-neutral",
      in_transit: "badge-warning",
      delivered: "badge-success",
      cancelled: "badge-error",
    };
    return (
      <span
        className={`badge ${
          styles[status as keyof typeof styles] || "badge-neutral"
        } capitalize`}
      >
        {status.replace("_", " ")}
      </span>
    );
  };

  const handleStatusChange = async (tripId: string, newStatus: any) => {
    setUpdatingStatus(tripId);
    try {
      await dataService.updateTripStatus(tripId, newStatus);
    } catch (error) {
      console.error(error);
    } finally {
      setUpdatingStatus(null);
    }
  };

  if (tripsList.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500 text-sm">
        No trips found.
      </div>
    );
  }

  const containerClass = compact
    ? "-mx-6 -mb-6 border-t border-gray-100"
    : "border border-gray-200 rounded-lg overflow-hidden";

  return (
    <>
      <div className={containerClass}>
        <ul className="divide-y divide-gray-100 bg-white">
          {tripsList.map((trip) => {
            const safe = safesList.find((s) => s.id === trip.safe_id);
            const isOverdue =
              isPast(new Date(trip.scheduled_delivery)) &&
              trip.status !== "delivered";
            const canTrack =
              safe && (safe.tracknetics_device_id || safe.tracking_device_id);

            return (
              <li
                key={trip.id}
                className="hover:bg-gray-50 transition-colors duration-150 px-6 py-4"
              >
                <div className="flex items-center justify-between gap-4">
                  {/* Left: Info */}
                  <div className="min-w-0 flex-1">
                    <div className="flex items-center gap-3 mb-1">
                      <h4 className="text-sm font-medium text-gray-900 truncate">
                        {trip.client_name}
                      </h4>
                      {getStatusBadge(trip.status)}
                      {isOverdue && (
                        <span className="badge badge-error">Overdue</span>
                      )}
                    </div>

                    <div className="flex items-center gap-4 text-xs text-gray-500 mt-1.5">
                      <div className="flex items-center gap-1 min-w-0">
                        <MapPin className="h-3 w-3 text-gray-400 shrink-0" />
                        <span className="truncate max-w-[200px]">
                          {trip.delivery_address}
                        </span>
                      </div>
                      <div className="hidden sm:flex items-center gap-1 shrink-0">
                        <Clock className="h-3 w-3 text-gray-400" />
                        <span>
                          {format(
                            new Date(trip.scheduled_pickup),
                            "MMM d, HH:mm"
                          )}
                        </span>
                      </div>
                    </div>
                  </div>

                  {/* Right: Actions */}
                  {showActions && (
                    <div className="flex items-center gap-2 shrink-0">
                      {updatingStatus === trip.id ? (
                        <LoadingSpinner size="small" />
                      ) : (
                        <>
                          {trip.status === "in_transit" && canTrack && (
                            <button
                              onClick={() => setTrackingTrip(trip)}
                              className="btn btn-ghost text-brand hover:text-brand-hover p-2"
                              title="Live Tracking"
                            >
                              <Navigation className="h-4 w-4" />
                            </button>
                          )}

                          {trip.status === "pending" && (
                            <button
                              onClick={() =>
                                handleStatusChange(trip.id, "in_transit")
                              }
                              className="btn btn-secondary text-xs py-1 h-7 px-2"
                            >
                              Start
                            </button>
                          )}

                          {trip.status === "in_transit" && (
                            <button
                              onClick={() =>
                                handleStatusChange(trip.id, "delivered")
                              }
                              className="btn btn-primary text-xs py-1 h-7 px-2"
                            >
                              Complete
                            </button>
                          )}

                          {trip.tracking_token && (
                            <button
                              onClick={() =>
                                window.open(
                                  dataService.generateTrackingUrl(
                                    trip.tracking_token!
                                  ),
                                  "_blank"
                                )
                              }
                              className="btn btn-ghost p-2 text-gray-400 hover:text-gray-600"
                              title="Customer Link"
                            >
                              <ExternalLink className="h-4 w-4" />
                            </button>
                          )}
                        </>
                      )}
                    </div>
                  )}
                </div>
              </li>
            );
          })}
        </ul>
      </div>

      {trackingTrip && (
        <TripTrackingModal
          trip={trackingTrip}
          onClose={() => setTrackingTrip(null)}
        />
      )}
    </>
  );
}
</file>

<file path="frontend/src/components/TripTrackingModal.tsx">
import { useState, useEffect, useRef } from "preact/hooks";
import {
  X,
  Navigation,
  RefreshCw,
  Clock,
  User,
  Package,
  AlertTriangle,
  Smartphone,
  Route,
} from "lucide-preact";
import { LoadingSpinner } from "./LoadingSpinner";
import { trackneticsService } from "../services/tracknetics";
import { safes } from "../store/data";
import { formatDistanceToNow, format } from "date-fns";
import L from "leaflet";
import {
  fixLeafletIcons,
  createArrowIcon,
  getOpenStreetMapLayer,
} from "../utils/leafletHelpers";

interface TripTrackingModalProps {
  trip: {
    id: string;
    safe_id: string;
    client_name: string;
    pickup_address: string;
    delivery_address: string;
    status: string;
    scheduled_pickup: string;
    scheduled_delivery: string;
    special_instructions?: string;
    priority?: string;
  };
  onClose: () => void;
}

interface SafeLocationData {
  location?: {
    lat: number;
    lng: number;
    accuracy: number;
    timestamp: number;
    speed?: number;
  };
  status: "online" | "offline" | "no_tracker" | "error";
  error?: string;
  lastUpdate: Date;
}

export function TripTrackingModal({ trip, onClose }: TripTrackingModalProps) {
  const [location, setLocation] = useState<SafeLocationData>({
    status: "offline",
    lastUpdate: new Date(),
  });
  const [loading, setLoading] = useState(false);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  const [autoRefresh, setAutoRefresh] = useState(true);

  const mapRef = useRef<HTMLDivElement>(null);
  const leafletMapRef = useRef<L.Map | null>(null);
  const safeMarkerRef = useRef<L.Marker | null>(null);
  const [mapsLoaded, setMapsLoaded] = useState(false);
  const [mapsError, setMapsError] = useState<string>("");

  // Get safe info
  const safe = safes.value.find((s) => s.id === trip.safe_id);
  const deviceId = safe?.tracknetics_device_id || safe?.tracking_device_id;

  // Get mobile app username (assuming it's tied to safe)
  const mobileUsername =
    safe?.mobile_users?.[0]?.username ||
    (safe?.serial_number
      ? safe.serial_number.toLowerCase().replace(/[^a-z0-9]/g, "") + "_driver"
      : "Unknown");

  // Initialize Leaflet map
  const initializeMap = () => {
    if (!mapRef.current || leafletMapRef.current || mapsError) return;

    try {
      fixLeafletIcons();

      const map = L.map(mapRef.current, {
        center: [-26.2041, 28.0473], // Default to Johannesburg
        zoom: 13,
        zoomControl: true,
      });

      getOpenStreetMapLayer().addTo(map);

      leafletMapRef.current = map;
      setMapsLoaded(true);

      // If we already have location data, update marker immediately
      if (location.location) {
        updateSafeMarker();
      }
    } catch (error) {
      console.error("Error initializing trip map:", error);
      setMapsError("Failed to initialize map");
    }
  };

  // Update safe marker position
  const updateSafeMarker = () => {
    if (!leafletMapRef.current) {
      return;
    }

    if (!location.location) {
      return;
    }

    const position: L.LatLngExpression = [
      location.location.lat,
      location.location.lng,
    ];

    try {
      if (!safeMarkerRef.current) {
        // Create safe marker with arrow icon
        const icon =
          location.location.speed && location.location.speed > 5
            ? createArrowIcon("#8B5CF6", 0) // Purple arrow
            : L.divIcon({
                className: "custom-safe-marker",
                html: `<div style="
                background-color: #8B5CF6;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                border: 3px solid white;
                box-shadow: 0 3px 6px rgba(0,0,0,0.3);
              "></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12],
              });

        safeMarkerRef.current = L.marker(position, { icon }).addTo(
          leafletMapRef.current
        );

        // Safe marker info
        const popupContent = `
          <div style="padding: 8px; min-width: 200px;">
            <h3 style="margin: 0 0 8px 0; color: #8B5CF6;">🚚 Safe ${
              safe?.serial_number
            }</h3>
            <div style="font-size: 12px; line-height: 1.4;">
              <p style="margin: 2px 0;"><strong>Driver:</strong> ${mobileUsername}</p>
              <p style="margin: 2px 0;"><strong>Client:</strong> ${
                trip.client_name
              }</p>
              <p style="margin: 2px 0;"><strong>Status:</strong> ${
                location.status
              }</p>
              <p style="margin: 2px 0;"><strong>Location:</strong> ${position[0].toFixed(
                6
              )}, ${position[1].toFixed(6)}</p>
              <p style="margin: 2px 0;"><strong>Accuracy:</strong> ±${
                location.location.accuracy
              }m</p>
              ${
                location.location.speed
                  ? `<p style="margin: 2px 0;"><strong>Speed:</strong> ${location.location.speed} km/h</p>`
                  : ""
              }
              <p style="margin: 2px 0;"><strong>Updated:</strong> ${formatDistanceToNow(
                location.lastUpdate
              )} ago</p>
            </div>
          </div>
        `;

        safeMarkerRef.current.bindPopup(popupContent);

        // Center map on safe location
        leafletMapRef.current.setView(position, 15);
      } else {
        // Update existing marker position
        safeMarkerRef.current.setLatLng(position);
        // Re-center map on updated position
        leafletMapRef.current.setView(
          position,
          leafletMapRef.current.getZoom()
        );
      }
    } catch (error) {
      console.error("Error updating safe marker:", error);
    }
  };

  // Get current safe location
  const updateLocation = async () => {
    if (!deviceId) {
      setLocation({
        status: "no_tracker",
        error: "No tracking device assigned",
        lastUpdate: new Date(),
      });
      return;
    }

    setLoading(true);

    try {
      const result = await trackneticsService.getLocationByDeviceId(deviceId);

      if (result.success && result.location) {
        const newLocation: SafeLocationData = {
          location: result.location,
          status: "online",
          lastUpdate: new Date(),
        };
        setLocation(newLocation);
        setLastUpdate(new Date());
      } else {
        setLocation({
          status: "offline",
          error: result.error || "No location data",
          lastUpdate: new Date(),
        });
      }
    } catch (error: any) {
      setLocation({
        status: "error",
        error: error.message || "Failed to get location",
        lastUpdate: new Date(),
      });
      console.error(
        `Error getting location for ${safe?.serial_number}:`,
        error
      );
    } finally {
      setLoading(false);
    }
  };

  // Initialize
  useEffect(() => {
    initializeMap();

    return () => {
      if (leafletMapRef.current) {
        leafletMapRef.current.remove();
        leafletMapRef.current = null;
      }
    };
  }, []);

  // Update safe marker when location changes
  useEffect(() => {
    if (mapsLoaded && location.location && !mapsError) {
      updateSafeMarker();
    }
  }, [location, mapsLoaded, mapsError]);

  // Auto-refresh location
  useEffect(() => {
    updateLocation();

    if (autoRefresh) {
      const interval = setInterval(updateLocation, 30000);
      return () => clearInterval(interval);
    }
  }, [deviceId, autoRefresh]);

  const getStatusColor = () => {
    switch (location.status) {
      case "online":
        return "text-green-600 bg-green-100";
      case "offline":
        return "text-red-600 bg-red-100";
      case "no_tracker":
        return "text-gray-600 bg-gray-100";
      case "error":
        return "text-orange-600 bg-orange-100";
      default:
        return "text-gray-600 bg-gray-100";
    }
  };

  const getPriorityColor = () => {
    switch (trip.priority) {
      case "urgent":
        return "text-red-600 bg-red-100";
      case "high":
        return "text-orange-600 bg-orange-100";
      case "normal":
        return "text-blue-600 bg-blue-100";
      case "low":
        return "text-gray-600 bg-gray-100";
      default:
        return "text-blue-600 bg-blue-100";
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-6xl h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b">
          <div className="flex items-center space-x-4">
            <div className="bg-purple-100 rounded-lg p-3">
              <Route className="h-6 w-6 text-purple-600" />
            </div>
            <div>
              <h2 className="text-2xl font-bold text-gray-900">
                Live Tracking
              </h2>
              <p className="text-gray-500">
                Trip {trip.id.slice(-8).toUpperCase()} • Safe{" "}
                {safe?.serial_number}
              </p>
            </div>
          </div>

          <div className="flex items-center space-x-3">
            <span
              className={`inline-flex items-center px-3 py-1 rounded-full text-sm font-medium ${getPriorityColor()}`}
            >
              {trip.priority?.toUpperCase() || "NORMAL"} PRIORITY
            </span>

            <button
              onClick={updateLocation}
              disabled={loading}
              className="btn btn-secondary"
            >
              {loading ? (
                <LoadingSpinner size="small" className="mr-2" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Refresh
            </button>

            <button
              onClick={onClose}
              className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
            >
              <X className="h-6 w-6 text-gray-500" />
            </button>
          </div>
        </div>

        <div className="flex flex-1 overflow-hidden">
          {/* Trip Info Sidebar */}
          <div className="w-80 border-r bg-gray-50 p-6 overflow-y-auto">
            <div className="space-y-6">
              {/* Client Info */}
              <div className="bg-white rounded-lg p-4">
                <div className="flex items-center space-x-3 mb-3">
                  <User className="h-5 w-5 text-blue-600" />
                  <h3 className="font-semibold text-gray-900">Client</h3>
                </div>
                <p className="text-gray-900 font-medium">{trip.client_name}</p>
                <p className="text-sm text-gray-500 mt-1">
                  Priority: {trip.priority?.toUpperCase() || "NORMAL"}
                </p>
              </div>

              {/* Safe Status */}
              <div className="bg-white rounded-lg p-4">
                <div className="flex items-center justify-between mb-3">
                  <div className="flex items-center space-x-3">
                    <Package className="h-5 w-5 text-purple-600" />
                    <h3 className="font-semibold text-gray-900">Safe Status</h3>
                  </div>
                  <span
                    className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getStatusColor()}`}
                  >
                    {location.status.toUpperCase()}
                  </span>
                </div>

                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span className="text-gray-500">Serial:</span>
                    <span className="font-mono">{safe?.serial_number}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Battery:</span>
                    <span
                      className={`font-medium ${
                        (safe?.battery_level || 0) > 50
                          ? "text-green-600"
                          : (safe?.battery_level || 0) > 20
                          ? "text-yellow-600"
                          : "text-red-600"
                      }`}
                    >
                      {safe?.battery_level}%
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Lock Status:</span>
                    <span
                      className={
                        safe?.is_locked ? "text-green-600" : "text-red-600"
                      }
                    >
                      {safe?.is_locked ? "SECURED" : "OPEN"}
                    </span>
                  </div>
                </div>
              </div>

              {/* Driver Info */}
              <div className="bg-white rounded-lg p-4">
                <div className="flex items-center space-x-3 mb-3">
                  <Smartphone className="h-5 w-5 text-green-600" />
                  <h3 className="font-semibold text-gray-900">Driver</h3>
                </div>
                <p className="text-gray-900 font-medium">{mobileUsername}</p>
                <p className="text-sm text-gray-500">Mobile App User</p>
              </div>

              {/* Location Info */}
              {location.location && (
                <div className="bg-white rounded-lg p-4">
                  <div className="flex items-center space-x-3 mb-3">
                    <Navigation className="h-5 w-5 text-blue-600" />
                    <h3 className="font-semibold text-gray-900">
                      Current Location
                    </h3>
                  </div>
                  <div className="space-y-2 text-sm">
                    <div>
                      <span className="text-gray-500">Coordinates:</span>
                      <p className="font-mono text-xs">
                        {location.location.lat.toFixed(6)},{" "}
                        {location.location.lng.toFixed(6)}
                      </p>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-gray-500">Accuracy:</span>
                      <span>±{location.location.accuracy}m</span>
                    </div>
                    {location.location.speed && (
                      <div className="flex justify-between">
                        <span className="text-gray-500">Speed:</span>
                        <span>{location.location.speed} km/h</span>
                      </div>
                    )}
                    <div className="flex justify-between">
                      <span className="text-gray-500">Updated:</span>
                      <span>
                        {formatDistanceToNow(location.lastUpdate)} ago
                      </span>
                    </div>
                  </div>
                </div>
              )}

              {/* Schedule */}
              <div className="bg-white rounded-lg p-4">
                <div className="flex items-center space-x-3 mb-3">
                  <Clock className="h-5 w-5 text-orange-600" />
                  <h3 className="font-semibold text-gray-900">Schedule</h3>
                </div>
                <div className="space-y-3 text-sm">
                  <div>
                    <p className="text-gray-500">Pickup:</p>
                    <p className="font-medium">
                      {format(
                        new Date(trip.scheduled_pickup),
                        "MMM d, yyyy 'at' HH:mm"
                      )}
                    </p>
                  </div>
                  <div>
                    <p className="text-gray-500">Delivery:</p>
                    <p className="font-medium">
                      {format(
                        new Date(trip.scheduled_delivery),
                        "MMM d, yyyy 'at' HH:mm"
                      )}
                    </p>
                  </div>
                </div>
              </div>

              {/* Special Instructions */}
              {trip.special_instructions && (
                <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                  <div className="flex items-center space-x-3 mb-2">
                    <AlertTriangle className="h-5 w-5 text-yellow-600" />
                    <h3 className="font-semibold text-yellow-800">
                      Special Instructions
                    </h3>
                  </div>
                  <p className="text-yellow-700 text-sm">
                    {trip.special_instructions}
                  </p>
                </div>
              )}

              {/* Auto-refresh Toggle */}
              <div className="bg-white rounded-lg p-4">
                <label className="flex items-center space-x-3">
                  <input
                    type="checkbox"
                    checked={autoRefresh}
                    onChange={(e) =>
                      setAutoRefresh((e.target as HTMLInputElement).checked)
                    }
                    className="rounded"
                  />
                  <div>
                    <span className="font-medium text-gray-900">
                      Auto-refresh
                    </span>
                    <p className="text-xs text-gray-500">
                      Updates every 30 seconds
                    </p>
                  </div>
                </label>
              </div>
            </div>
          </div>

          {/* Map */}
          <div className="flex-1 relative">
            {/* Maps Error State */}
            {mapsError && (
              <div className="absolute inset-0 flex items-center justify-center bg-gray-100">
                <div className="text-center">
                  <AlertTriangle className="h-12 w-12 mx-auto mb-4 text-red-400" />
                  <p className="text-lg font-medium mb-2">Map Error</p>
                  <p className="text-gray-600 text-sm max-w-xs mb-4">
                    {mapsError}
                  </p>
                  <button
                    onClick={() => {
                      setMapsError("");
                      setMapsLoaded(false);
                      initializeMap();
                    }}
                    className="bg-blue-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-blue-700 transition-colors"
                  >
                    Retry
                  </button>
                </div>
              </div>
            )}

            {/* Map Container */}
            <div
              ref={mapRef}
              className="w-full h-full"
              style={{
                display: !mapsError ? "block" : "none",
                minHeight: "400px",
              }}
            />

            {/* Map Legend */}
            {mapsLoaded && !mapsError && location.location && (
              <div className="absolute bottom-4 left-4 bg-white rounded-lg shadow-lg p-3">
                <div className="flex items-center space-x-2 text-sm">
                  <div className="w-4 h-4 rounded-full bg-purple-500"></div>
                  <span>Safe Position</span>
                </div>
              </div>
            )}

            {/* Status Badge */}
            <div className="absolute top-4 right-4 bg-white rounded-lg shadow-lg p-3">
              <div className="flex items-center space-x-2">
                <div
                  className={`w-2 h-2 rounded-full ${
                    location.status === "online"
                      ? "bg-green-500"
                      : "bg-gray-400"
                  }`}
                ></div>
                <span className="text-sm font-medium">
                  {lastUpdate
                    ? `Updated ${formatDistanceToNow(lastUpdate)} ago`
                    : "No updates yet"}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/index.css">
@import "tailwindcss";

@theme {
  /* Khluys Brand Colors */
  --color-brand: #ff6b35;
  --color-brand-hover: #ff5722;
  --color-brand-light: #fff1ec;

  /* Semantic Borders & Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem; /* 6px */
  --radius-lg: 0.5rem; /* 8px */

  /* Animation Primitives */
  --animate-fade-in: fade-in 0.2s ease-out;
  --animate-slide-up: slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1);

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  @keyframes slide-up {
    from {
      transform: translateY(10px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
}

@layer base {
  body {
    @apply bg-gray-50 text-gray-900 antialiased;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
      Roboto, sans-serif;
  }

  /* Refined Scrollbar */
  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  ::-webkit-scrollbar-track {
    @apply bg-transparent;
  }
  ::-webkit-scrollbar-thumb {
    @apply bg-gray-300 rounded-full hover:bg-gray-400;
  }
}

@layer components {
  /* --- Buttons --- */
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-brand disabled:opacity-50 disabled:cursor-not-allowed cursor-pointer active:scale-[0.98];
  }

  .btn-primary {
    @apply bg-brand text-white border border-transparent hover:bg-brand-hover shadow-sm;
  }

  .btn-secondary {
    @apply bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 hover:text-gray-900 shadow-sm;
  }

  .btn-ghost {
    @apply bg-transparent text-gray-500 hover:text-gray-900 hover:bg-gray-100;
  }

  .btn-danger {
    @apply bg-white text-red-600 border border-red-200 hover:bg-red-50 hover:border-red-300;
  }

  /* --- Inputs & Forms --- */
  .input {
    @apply block w-full px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-900 placeholder-gray-400
    transition-colors duration-200
    focus:outline-none focus:border-brand focus:ring-1 focus:ring-brand
    disabled:bg-gray-50 disabled:text-gray-500;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 mb-1.5;
  }

  /* --- Surface & Layout --- */
  .card {
    @apply bg-white px-3 py-3 rounded-lg border border-gray-200;
  }

  /* shadow-[0_1px_3px_rgba(0,0,0,0.05)]; */

  .table-header {
    @apply px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider border-b border-gray-200 bg-gray-50;
  }

  .table-cell {
    @apply px-6 py-4 whitespace-nowrap text-sm text-gray-500 border-b border-gray-100;
  }

  /* --- Badges --- */
  .badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border;
  }
  .badge-success {
    @apply bg-green-50 text-green-700 border-green-200;
  }
  .badge-warning {
    @apply bg-orange-50 text-orange-700 border-orange-200;
  }
  .badge-error {
    @apply bg-red-50 text-red-700 border-red-200;
  }
  .badge-neutral {
    @apply bg-gray-100 text-gray-700 border-gray-200;
  }
  .badge-brand {
    @apply bg-brand-light text-brand border-brand-light;
  }
}
</file>

<file path="frontend/src/services/auth.ts">
import { supabase } from "../lib/supabase";
import { authActions } from "../store/auth";
import { toast } from "../components/Toast";
import type { User } from "../types";
import { logger } from "../utils/logger";

class AuthService {
  private isInitializing = false;

  // Check rate limit before login
  private async checkRateLimit(email: string): Promise<{
    allowed: boolean;
    retryAfter?: number;
    message?: string;
  }> {
    try {
      const { data, error } = await supabase.functions.invoke(
        "rate-limit-check",
        {
          body: {
            identifier: email.toLowerCase(),
            attempt_type: "login",
            action: "check",
          },
        }
      );

      if (error || !data) {
        console.warn("Rate limit check failed, allowing attempt");
        return { allowed: true };
      }

      if (data.is_blocked) {
        const minutes = Math.ceil(data.retry_after / 60);
        return {
          allowed: false,
          retryAfter: data.retry_after,
          message: `Too many login attempts. Please try again in ${minutes} minute${
            minutes !== 1 ? "s" : ""
          }.`,
        };
      }

      return { allowed: true };
    } catch (error) {
      console.error("Rate limit check error:", error);
      return { allowed: true }; // Fail open
    }
  }

  // Log login attempt
  private async logLoginAttempt(email: string, success: boolean) {
    try {
      await supabase.functions.invoke("rate-limit-check", {
        body: {
          identifier: email.toLowerCase(),
          attempt_type: "login",
          action: "log",
          success,
          ip_address: null, // Edge function will detect this
          user_agent: navigator.userAgent,
        },
      });
    } catch (error) {
      console.warn("Failed to log login attempt:", error);
      // Don't block on logging failures
    }
  }

  async initialize() {
    if (this.isInitializing) {
      console.log("Auth already initializing, skipping...");
      return;
    }

    this.isInitializing = true;
    authActions.setLoading(true);

    try {
      const {
        data: { session },
        error,
      } = await supabase.auth.getSession();

      if (error) {
        console.error("Auth session error:", error);

        // Clear invalid session
        if (error.message.includes("Refresh Token")) {
          console.log("Clearing invalid session");
          await this.clearSession();
        }

        authActions.setLoading(false);
        this.isInitializing = false;
        return;
      }

      if (session?.user) {
        try {
          const userProfile = await this.getUserProfile(session.user.id);
          if (userProfile) {
            authActions.setUser(userProfile);
          } else {
            console.log("No profile found for user, clearing session");
            await this.clearSession();
          }
        } catch (profileError: any) {
          console.error("Error fetching user profile:", profileError);

          // If it's an auth error, clear session
          if (
            profileError.message?.includes("JWT") ||
            profileError.message?.includes("session")
          ) {
            await this.clearSession();
          }
        }
      }

      authActions.setLoading(false);

      // Listen for auth changes
      supabase.auth.onAuthStateChange(async (event, session) => {
        console.log("Auth state changed:", event);

        if (event === "SIGNED_IN" && session?.user) {
          try {
            const userProfile = await this.getUserProfile(session.user.id);
            if (userProfile) {
              authActions.setUser(userProfile);
            } else {
              console.log("No profile found after sign in");
              await this.clearSession();
            }
          } catch (profileError) {
            console.error(
              "Error fetching profile after sign in:",
              profileError
            );
            await this.clearSession();
          }
        } else if (event === "SIGNED_OUT") {
          authActions.logout();
        } else if (event === "TOKEN_REFRESHED") {
          console.log("Token refreshed successfully");
        } else if (event === "USER_UPDATED") {
          console.log("User updated");
        }
      });
    } catch (error) {
      console.error("Auth initialization failed:", error);
      authActions.setLoading(false);
    } finally {
      this.isInitializing = false;
    }
  }

  // Clear invalid session
  private async clearSession() {
    try {
      await supabase.auth.signOut();
      authActions.logout();

      // Clear local storage items related to Supabase
      const keys = Object.keys(localStorage);
      keys.forEach((key) => {
        if (key.includes("supabase")) {
          localStorage.removeItem(key);
        }
      });
    } catch (error) {
      console.error("Error clearing session:", error);
    }
  }

  async login(email: string, password: string) {
    logger.info("Login attempt", { email });

    const rateLimitCheck = await this.checkRateLimit(email);
    if (!rateLimitCheck.allowed) {
      logger.warn("Login blocked by rate limit", { email });
      toast.error(rateLimitCheck.message!);
      return { success: false, error: rateLimitCheck.message };
    }

    try {
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      await this.logLoginAttempt(email, !error);

      if (error) {
        logger.error("Login failed", { email, error: error.message });
        toast.error("Invalid email or password");
        return { success: false, error: error.message };
      }

      if (data.user) {
        const userProfile = await this.getUserProfile(data.user.id);
        if (userProfile) {
          logger.info("Login successful", {
            userId: data.user.id,
            role: userProfile.role,
          });
          toast.success("Login successful!");
          return {
            success: true,
            requiresPasswordChange: userProfile.must_change_password,
          };
        }
      }

      logger.error("Login failed - no profile", { email });
      toast.error("User profile not found");
      return { success: false, error: "User profile not found" };
    } catch (error: any) {
      logger.error("Login exception", { email, error: error.message });
      toast.error("Login failed. Please try again.");
      return { success: false, error: error.message || "Login failed" };
    }
  }

  async logout() {
    try {
      await supabase.auth.signOut();
      toast.info("Logged out successfully");
    } catch (error) {
      console.error("Logout error:", error);
      // Force logout even if API call fails
      authActions.logout();
    }
  }

  async changePassword(newPassword: string) {
    try {
      const { error } = await supabase.auth.updateUser({
        password: newPassword,
      });

      if (error) {
        toast.error("Failed to change password");
        return { success: false, error: error.message };
      }

      const {
        data: { user },
      } = await supabase.auth.getUser();

      if (user) {
        await supabase
          .from("profiles")
          .update({ must_change_password: false })
          .eq("id", user.id);

        authActions.updateUser({ must_change_password: false });
      }

      toast.success("Password changed successfully!");
      return { success: true };
    } catch (error: any) {
      console.error("Change password error:", error);
      toast.error("Failed to change password");
      return { success: false, error: error.message };
    }
  }

  async createUser(userData: {
    email: string;
    username: string;
    password: string;
    role: "admin";
    created_by?: string;
  }) {
    try {
      const { data, error } = await supabase.auth.signUp({
        email: userData.email,
        password: userData.password,
        options: {
          data: {
            username: userData.username,
            role: userData.role,
            must_change_password: true,
          },
          emailRedirectTo: `${window.location.origin}/login`,
        },
      });

      if (error) {
        toast.error("Failed to create user");
        return { success: false, error: error.message };
      }

      toast.success("User created successfully!");
      return {
        success: true,
        user: data.user,
        message:
          "User created! They will receive a confirmation email to activate their account.",
      };
    } catch (err: any) {
      console.error("Signup error:", err);
      toast.error("Failed to create user");
      return {
        success: false,
        error: "Failed to create user. Please try again.",
      };
    }
  }

  private async getUserProfile(userId: string): Promise<User | null> {
    try {
      const { data, error } = await supabase
        .from("profiles")
        .select("*")
        .eq("id", userId)
        .eq("is_active", true)
        .single();

      if (error) {
        console.error("Failed to get user profile:", error);

        // Don't throw on PGRST116 (no rows) - just return null
        if (error.code === "PGRST116") {
          console.log("No profile found for user");
          return null;
        }

        // If permission denied, this means RLS is blocking
        if (error.code === "42501") {
          console.error("RLS permission denied - this should not happen");
          // Log out to clear bad state
          throw new Error("Invalid session");
        }

        return null;
      }

      return data;
    } catch (err: any) {
      console.error("Exception getting user profile:", err);
      throw err;
    }
  }
}

export const authService = new AuthService();
</file>

<file path="frontend/src/services/tracknetics.ts">
import { supabase } from "../lib/supabase";
import { withTimeout } from "../utils/requestHelpers";

interface LoginResponse {
  state: string;
  userInfo?: {
    userID: string;
    userName: string;
    loginName: string;
    timeZone: string;
    address: string;
    cellPhone: string;
    key: string;
  };
}

interface DeviceInfo {
  id: string;
  sn: string; // IMEI
  name: string;
  status: string;
  speed?: string;
}

interface LocationData {
  state: string;
  positionTime?: string;
  lat?: string;
  lng?: string;
  speed?: string;
  course?: string;
  isStop?: string;
  stm?: string;
  isGPS?: string;
  status?: string;
}

class TrackneticsService {
  private currentSession: { userID?: string; key?: string } | null = null;

  // Make API call through Supabase Edge Function proxy
  private async apiCall(
    operation: string,
    params: Record<string, any> = {}
  ): Promise<any> {
    try {
      // Get current session for authentication
      const {
        data: { session },
      } = await supabase.auth.getSession();

      if (!session) {
        throw new Error("Authentication required");
      }

      // Timeout
      const result = await withTimeout(
        supabase.functions.invoke("tracknetics-proxy", {
          headers: {
            Authorization: `Bearer ${session.access_token}`,
          },
          body: {
            operation,
            params,
          },
        }),
        {
          timeoutMs: 30000,
          showErrorToast: true,
        }
      );

      const { data, error } = result;

      if (error) {
        console.error("Proxy call error:", error);
        throw new Error(`Proxy error: ${error.message}`);
      }

      return data;
    } catch (err) {
      console.error("API call failed:", err);
      throw err;
    }
  }

  // Login and get authentication key
  async login(): Promise<{ success: boolean; error?: string }> {
    try {
      // Edge function handles credentials internally
      const data: LoginResponse = await this.apiCall("Login", {});

      if (data.state === "0" && data.userInfo) {
        this.currentSession = {
          userID: data.userInfo.userID,
          key: data.userInfo.key,
        };
        return { success: true };
      } else {
        console.error("Tracknetics login failed:", data);
        const errorMessage = this.getErrorMessage(data.state);
        return { success: false, error: `Login failed: ${errorMessage}` };
      }
    } catch (error: any) {
      console.error("Tracknetics login error:", error);
      return {
        success: false,
        error: error.message || "Network error during login",
      };
    }
  }

  // Ensure we have a valid session
  private async ensureAuthenticated(): Promise<boolean> {
    if (!this.currentSession?.key) {
      const loginResult = await this.login();
      return loginResult.success;
    }
    return true;
  }

  // Get list of devices
  async getDeviceList(): Promise<{
    success: boolean;
    devices?: DeviceInfo[];
    error?: string;
  }> {
    if (
      !(await this.ensureAuthenticated()) ||
      !this.currentSession?.userID ||
      !this.currentSession?.key
    ) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceList", {
        ID: this.currentSession.userID,
        PageNo: 1,
        PageCount: 100,
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, devices: data.arr || [] };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get devices: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      return {
        success: false,
        error: error.message || "Network error getting device list",
      };
    }
  }

  // Get real-time location for a device by ID
  async getDeviceLocation(
    deviceId: string
  ): Promise<{ success: boolean; location?: LocationData; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data: LocationData = await this.apiCall("GetTracking", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        MapType: "google",
        Language: "en-us",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, location: data };
      } else if (data.state === "2002") {
        return { success: false, error: "No location data available" };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get location: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device location:", error);
      return {
        success: false,
        error: error.message || "Network error getting location",
      };
    }
  }

  // Get location by device ID (simplified method for direct calls)
  async getLocationByDeviceId(deviceId: string): Promise<{
    success: boolean;
    location?: {
      lat: number;
      lng: number;
      accuracy: number;
      timestamp: number;
    };
    error?: string;
  }> {
    const locationResult = await this.getDeviceLocation(deviceId);

    if (!locationResult.success || !locationResult.location) {
      return { success: false, error: locationResult.error };
    }

    const location = locationResult.location;

    if (location.lat && location.lng) {
      const standardLocation = {
        lat: parseFloat(location.lat),
        lng: parseFloat(location.lng),
        accuracy: location.isGPS === "1" ? 10 : 100,
        timestamp: location.positionTime
          ? new Date(location.positionTime).getTime()
          : Date.now(),
      };

      return {
        success: true,
        location: standardLocation,
      };
    }

    return { success: false, error: "Invalid location data received" };
  }

  // Create geofence for delivery location
  async createDeliveryGeofence(
    deviceId: string,
    name: string,
    lat: number,
    lng: number,
    radiusMeters: number = 100
  ): Promise<{ success: boolean; geofenceId?: string; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("SaveGeofence", {
        DeviceID: deviceId,
        GeofenceName: name,
        Remark: "Delivery Location",
        Lat: lat,
        Lng: lng,
        Radius: radiusMeters,
        GeofenceID: 0,
        MapType: "google",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, geofenceId: data.geofenceID };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to create geofence: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error creating geofence:", error);
      return {
        success: false,
        error: error.message || "Network error creating geofence",
      };
    }
  }

  // Get device details by ID
  async getDeviceDetails(
    deviceId: string
  ): Promise<{ success: boolean; device?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceDetail", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, device: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device details: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device details:", error);
      return {
        success: false,
        error: error.message || "Network error getting device details",
      };
    }
  }

  // Get device history/playback
  async getDeviceHistory(
    deviceId: string,
    startTime: string,
    endTime: string
  ): Promise<{ success: boolean; history?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDevicesHistory", {
        DeviceID: deviceId,
        StartTime: startTime,
        EndTime: endTime,
        TimeZones: "South Africa Standard Time",
        ShowLBS: 0,
        MapType: "google",
        SelectCount: 1000,
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, history: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device history: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device history:", error);
      return {
        success: false,
        error: error.message || "Network error getting device history",
      };
    }
  }

  // Logout
  async logout(): Promise<void> {
    if (this.currentSession?.userID && this.currentSession?.key) {
      try {
        await this.apiCall("Exit", {
          ID: this.currentSession.userID,
          Key: this.currentSession.key,
        });
      } catch (error) {
        console.error("Error during logout:", error);
      }
    }
    this.currentSession = null;
  }

  // Helper to decode Tracknetics error states
  private getErrorMessage(state: string): string {
    const errorCodes: Record<string, string> = {
      "0": "Success",
      "1001": "Parameter error",
      "1002": "Program error",
      "2001": "Username or password error",
      "2002": "No result",
      "2003": "Car number already exists",
      "2004": "Fail to modify",
      "2005": "Modify success",
      "2020": "Username already exists",
      "2021": "It has sub account, cannot be deleted",
      "2022": "It has device, cannot be deleted",
      "2023": "Username does not exist",
      "3001": "KEY incorrect",
      "3004": "Maintenance...",
    };

    return errorCodes[state] || `Unknown error (${state})`;
  }
}

export const trackneticsService = new TrackneticsService();
</file>

<file path="mobile/src/index.css">
@import "tailwindcss";

@theme {
  /* Kluys Brand Colors */
  --color-brand: #ff6b35;
  --color-brand-hover: #ff5722;
  --color-brand-light: #fff1ec;

  /* Semantic Borders & Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem; /* 6px - Crisp */
  --radius-lg: 0.5rem; /* 8px */

  /* Animations */
  --animate-fade-in: fade-in 0.2s ease-out;
  --animate-slide-up: slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1);

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  @keyframes slide-up {
    from {
      transform: translateY(10px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
}

@layer base {
  body {
    @apply bg-gray-50 text-gray-900 antialiased;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
      Roboto, sans-serif;
  }

  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  ::-webkit-scrollbar-track {
    @apply bg-transparent;
  }
  ::-webkit-scrollbar-thumb {
    @apply bg-gray-300 rounded-full hover:bg-gray-400;
  }
}

@layer components {
  /* --- Buttons --- */
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-brand disabled:opacity-50 disabled:cursor-not-allowed cursor-pointer active:scale-[0.98];
  }

  .btn-primary {
    @apply bg-brand text-white border border-transparent hover:bg-brand-hover shadow-sm;
  }

  .btn-secondary {
    @apply bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 hover:text-gray-900 shadow-sm;
  }

  .btn-ghost {
    @apply bg-transparent text-gray-500 hover:text-gray-900 hover:bg-gray-100;
  }

  .btn-danger {
    @apply bg-white text-red-600 border border-red-200 hover:bg-red-50 hover:border-red-300;
  }

  /* --- Inputs --- */
  .input {
    @apply block w-full px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-900 placeholder-gray-400
    transition-colors duration-200
    focus:outline-none focus:border-brand focus:ring-1 focus:ring-brand
    disabled:bg-gray-50 disabled:text-gray-500;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 mb-1.5;
  }

  /* --- Cards & Layout (Fixed Padding) --- */
  .card {
    @apply bg-white rounded-lg border border-gray-200 shadow-[0_1px_3px_rgba(0,0,0,0.05)] p-6;
  }

  /* --- Badges --- */
  .badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border;
  }
  .badge-success {
    @apply bg-green-50 text-green-700 border-green-200;
  }
  .badge-warning {
    @apply bg-orange-50 text-orange-700 border-orange-200;
  }
  .badge-error {
    @apply bg-red-50 text-red-700 border-red-200;
  }
  .badge-neutral {
    @apply bg-gray-100 text-gray-700 border-gray-200;
  }
  .badge-brand {
    @apply bg-brand-light text-brand border-brand-light;
  }
}
</file>

<file path="mobile/src/services/bluetooth.ts">
import { BleClient } from "@capacitor-community/bluetooth-le";
import { mobileAuthService } from "./auth";

// Service UUIDs for Pi communication
const PI_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const OTP_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const STATUS_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";

interface BluetoothConfig {
  phoneMac: string;
  piMac: string;
  trackerMac: string;
}

class BluetoothService {
  private config: BluetoothConfig;
  private isConnected = false;
  private deviceId: string | null = null;
  private connectionAttempts = 0;
  private readonly MAX_CONNECTION_ATTEMPTS = 3;
  private reconnectTimer: number | null = null;

  constructor() {
    // Load MAC addresses from environment
    this.config = {
      phoneMac: import.meta.env.VITE_PHONE_MAC_1 || "",
      piMac: import.meta.env.VITE_PI_MAC || "",
      trackerMac: import.meta.env.VITE_TRACKER_IMEI || "",
    };
  }

  // Initialize Bluetooth
  async initialize() {
    try {
      // Check if user is authenticated
      const sessionToken = mobileAuthService.getSessionToken();
      if (!sessionToken) {
        console.error("Cannot initialize Bluetooth: User not authenticated");
        return { success: false, error: "Authentication required" };
      }

      await BleClient.initialize();
      console.log("Bluetooth initialized");
      return { success: true };
    } catch (err: any) {
      console.error("Bluetooth init failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Validate phone MAC (optional security check)
  async validatePhoneMAC(): Promise<boolean> {
    // In production, you could implement device fingerprinting here
    // For now, we trust the authenticated session
    return true;
  }

  // Scan for Pi Bluetooth device with timeout
  async scanForPi(timeoutMs: number = 10000): Promise<{
    success: boolean;
    device?: any;
    error?: string;
  }> {
    try {
      console.log("Scanning for Pi with MAC:", this.config.piMac);

      let foundDevice = false;

      await BleClient.requestLEScan(
        { services: [PI_SERVICE_UUID] },
        (result) => {
          console.log("Device found:", result);

          // Check if this is our Pi by MAC address or name
          const deviceMac = result.device.deviceId.toUpperCase();
          const configMac = this.config.piMac.toUpperCase();

          if (
            deviceMac === configMac ||
            result.localName?.includes("GuardianSafe")
          ) {
            console.log("Found Guardian Safe Pi");
            BleClient.stopLEScan();
            this.deviceId = result.device.deviceId;
            foundDevice = true;
          }
        }
      );

      // Wait for scan timeout
      await new Promise((resolve) => setTimeout(resolve, timeoutMs));

      if (!foundDevice) {
        await BleClient.stopLEScan();
      }

      if (this.deviceId) {
        return { success: true, device: { deviceId: this.deviceId } };
      } else {
        return {
          success: false,
          error:
            "Guardian Safe not found. Make sure you are near the safe and it is powered on.",
        };
      }
    } catch (err: any) {
      console.error("Scan error:", err);
      await BleClient.stopLEScan().catch(() => {});
      return { success: false, error: err.message };
    }
  }

  // Connect to Pi with retry logic
  async connectToPi(): Promise<{ success: boolean; error?: string }> {
    if (!this.deviceId) {
      return { success: false, error: "No Pi device found. Scan first." };
    }

    // Check connection attempts
    if (this.connectionAttempts >= this.MAX_CONNECTION_ATTEMPTS) {
      return {
        success: false,
        error: "Maximum connection attempts reached. Please restart the app.",
      };
    }

    this.connectionAttempts++;

    try {
      console.log(
        `Connecting to Pi... (attempt ${this.connectionAttempts}/${this.MAX_CONNECTION_ATTEMPTS})`
      );

      await BleClient.connect(this.deviceId, (deviceId) => {
        console.log("Disconnected from Pi:", deviceId);
        this.handleDisconnection();
      });

      this.isConnected = true;
      this.connectionAttempts = 0; // Reset on success
      console.log("Connected to Pi");

      return { success: true };
    } catch (err: any) {
      console.error("Connection failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Handle unexpected disconnection
  private handleDisconnection() {
    this.isConnected = false;
    console.warn("Bluetooth connection lost");

    // Attempt to reconnect after delay
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    this.reconnectTimer = setTimeout(async () => {
      console.log("Attempting to reconnect...");
      const result = await this.connectToPi();
      if (!result.success) {
        console.error("Reconnection failed:", result.error);
      }
    }, 5000) as unknown as number;
  }

  // Send OTP to Pi for verification with validation
  async sendOTPToPi(
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    // Validate OTP format
    if (!/^\d{6}$/.test(otpCode)) {
      return { success: false, error: "Invalid OTP format" };
    }

    try {
      console.log("Sending OTP to Pi...");

      // Convert OTP string to bytes
      const encoder = new TextEncoder();
      const otpBytes = encoder.encode(otpCode);

      // Write OTP to characteristic with timeout
      const writePromise = BleClient.write(
        this.deviceId,
        PI_SERVICE_UUID,
        OTP_CHARACTERISTIC_UUID,
        new DataView(otpBytes.buffer)
      );

      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Write timeout")), 10000)
      );

      await Promise.race([writePromise, timeout]);

      console.log("OTP sent to Pi successfully");
      return { success: true };
    } catch (err: any) {
      console.error("Failed to send OTP:", err);

      // If write failed, connection might be lost
      if (
        err.message?.includes("disconnected") ||
        err.message?.includes("timeout")
      ) {
        this.isConnected = false;
      }

      return { success: false, error: err.message };
    }
  }

  // Read Pi status with enhanced error handling
  async readPiStatus(): Promise<{
    success: boolean;
    status?: {
      verified: boolean;
      lockOpen: boolean;
      batteryPercent: number;
      safeStatus: "inactive" | "active" | "maintenance" | "offline";
      voltage: number;
    };
    error?: string;
  }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    try {
      console.log("Reading Pi status...");

      const readPromise = BleClient.read(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID
      );

      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Read timeout")), 10000)
      );

      const result = (await Promise.race([readPromise, timeout])) as DataView;

      // Parse status bytes
      const statusArray = new Uint8Array(result.buffer);

      // Validate response length
      if (statusArray.length < 6) {
        return {
          success: false,
          error: "Invalid status response from safe",
        };
      }

      const verified = statusArray[0] === 1;
      const lockOpen = statusArray[1] === 1;
      const batteryPercent = Math.min(100, Math.max(0, statusArray[2])); // Clamp 0-100
      const statusCode = statusArray[3];

      // Reconstruct voltage from two bytes
      const voltageInt = (statusArray[4] << 8) | statusArray[5];
      const voltage = voltageInt / 10.0;

      // Validate voltage range
      if (voltage < 0 || voltage > 30) {
        console.warn("Voltage out of expected range:", voltage);
      }

      // Map status code to string
      const statusMap: Record<
        number,
        "inactive" | "active" | "maintenance" | "offline"
      > = {
        0: "inactive",
        1: "active",
        2: "maintenance",
        3: "offline",
      };
      const safeStatus = statusMap[statusCode] || "active";

      console.log("Pi status:", {
        verified,
        lockOpen,
        batteryPercent,
        safeStatus,
        voltage: `${voltage.toFixed(2)}V`,
      });

      return {
        success: true,
        status: {
          verified,
          lockOpen,
          batteryPercent,
          safeStatus,
          voltage,
        },
      };
    } catch (err: any) {
      console.error("Failed to read status:", err);

      // Check if connection was lost
      if (
        err.message?.includes("disconnected") ||
        err.message?.includes("timeout")
      ) {
        this.isConnected = false;
      }

      return { success: false, error: err.message };
    }
  }

  // Subscribe to Pi status changes with reconnection
  async subscribeToPiStatus(
    callback: (status: {
      verified: boolean;
      lockOpen: boolean;
      batteryPercent: number;
      voltage: number;
    }) => void
  ) {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    try {
      await BleClient.startNotifications(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID,
        (value) => {
          try {
            const statusArray = new Uint8Array(value.buffer);

            if (statusArray.length >= 6) {
              const verified = statusArray[0] === 1;
              const lockOpen = statusArray[1] === 1;
              const batteryPercent = Math.min(100, Math.max(0, statusArray[2]));
              const voltageInt = (statusArray[4] << 8) | statusArray[5];
              const voltage = voltageInt / 10.0;

              callback({ verified, lockOpen, batteryPercent, voltage });
            }
          } catch (parseError) {
            console.error("Error parsing notification:", parseError);
          }
        }
      );

      console.log("Subscribed to Pi status updates");
      return { success: true };
    } catch (err: any) {
      console.error("Failed to subscribe:", err);
      return { success: false, error: err.message };
    }
  }

  // Disconnect from Pi with cleanup
  async disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.deviceId) {
      try {
        await BleClient.disconnect(this.deviceId);
        this.isConnected = false;
        this.deviceId = null;
        this.connectionAttempts = 0;
        console.log("Disconnected from Pi");
      } catch (err) {
        console.error("Disconnect error:", err);
      }
    }
  }

  // Get connection status
  isConnectedToPi(): boolean {
    return this.isConnected;
  }

  // Get device configuration
  getConfig(): BluetoothConfig {
    return this.config;
  }

  // Reset connection state (for retry)
  resetConnection() {
    this.connectionAttempts = 0;
    this.deviceId = null;
    this.isConnected = false;
  }
}

export const bluetoothService = new BluetoothService();
</file>

<file path="mobile/src/services/geolocation.ts">
interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  timestamp: number;
}

class GeolocationService {
  // Check if we're running in a Capacitor environment
  private isCapacitorAvailable(): boolean {
    return !!(window as any).Capacitor;
  }

  // Get current position with high accuracy
  async getCurrentPosition(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      console.log(
        "Getting location - is Capacitor available?",
        this.isCapacitorAvailable()
      );

      if (this.isCapacitorAvailable()) {
        return await this.getCapacitorLocation();
      } else {
        return await this.getBrowserLocation();
      }
    } catch (err: any) {
      console.error("Geolocation error:", err);
      return { success: false, error: "Failed to get current location" };
    }
  }

  // Use Capacitor geolocation (for mobile apps)
  private async getCapacitorLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      // Import Capacitor dynamically to avoid errors in browser
      const { Geolocation } = await import("@capacitor/geolocation");

      // Check permissions first
      const permissions = await Geolocation.checkPermissions();

      if (permissions.location !== "granted") {
        const requestResult = await Geolocation.requestPermissions();
        if (requestResult.location !== "granted") {
          return { success: false, error: "Location permission denied" };
        }
      }

      // Get position with high accuracy
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000,
      });

      return {
        success: true,
        location: {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy,
          timestamp: position.timestamp,
        },
      };
    } catch (err: any) {
      console.error("Capacitor geolocation error:", err);

      let errorMessage = "Failed to get current location";
      if (err.message.includes("denied")) {
        errorMessage = "Location access denied";
      } else if (err.message.includes("timeout")) {
        errorMessage = "Location request timed out";
      } else if (err.message.includes("unavailable")) {
        errorMessage = "Location services unavailable";
      }

      return { success: false, error: errorMessage };
    }
  }

  // Use browser geolocation API (for web testing)
  private async getBrowserLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    return new Promise((resolve) => {
      if (!navigator.geolocation) {
        resolve({
          success: false,
          error: "Geolocation is not supported by this browser",
        });
        return;
      }

      console.log("Using browser geolocation...");

      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Browser location success:", position.coords);
          resolve({
            success: true,
            location: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            },
          });
        },
        (error) => {
          console.error("Browser location error:", error);

          let errorMessage = "Failed to get current location";
          switch (error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = "Location access denied by user";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = "Location information is unavailable";
              break;
            case error.TIMEOUT:
              errorMessage = "Location request timed out";
              break;
          }

          resolve({ success: false, error: errorMessage });
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 60000,
        }
      );
    });
  }

  // Watch position for continuous tracking
  async watchPosition(
    callback: (location: LocationData) => void
  ): Promise<string | null> {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");

        const watchId = await Geolocation.watchPosition(
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          },
          (position, err) => {
            if (err) {
              console.error("Location watch error:", err);
              return;
            }

            if (position) {
              callback({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp,
              });
            }
          }
        );

        return watchId;
      } else {
        // Browser fallback
        const watchId = navigator.geolocation.watchPosition(
          (position) => {
            callback({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            });
          },
          (error) => {
            console.error("Browser location watch error:", error);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          }
        );

        return watchId.toString();
      }
    } catch (err) {
      console.error("Failed to start location watching:", err);
      return null;
    }
  }

  // Stop watching position
  async clearWatch(watchId: string) {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");
        await Geolocation.clearWatch({ id: watchId });
      } else {
        navigator.geolocation.clearWatch(parseInt(watchId));
      }
    } catch (err) {
      console.error("Failed to clear location watch:", err);
    }
  }
}

export const geolocationService = new GeolocationService();
</file>

<file path="mobile/src/services/trips.ts">
import { supabase } from "./supabase";
import { currentUser } from "../store/auth";
import { tripsActions } from "../store/trips";
import { mobileAuthService } from "./auth";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  recipient_name?: string;
  recipient_email?: string;
  recipient_phone?: string;
  recipient_is_client?: boolean;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

class TripsService {
  private subscription: any = null;

  async loadTrips() {
    const user = currentUser.value;
    if (!user?.safe_id) {
      console.log("No user or safe_id found:", user);
      return;
    }

    // Verify session is still valid
    const sessionToken = mobileAuthService.getSessionToken();
    if (!sessionToken) {
      console.log("Session expired, logging out");
      await mobileAuthService.logout();
      return;
    }

    console.log("Loading trips for safe_id:", user.safe_id);
    tripsActions.setLoading(true);

    try {
      const { data, error } = await supabase
        .from("trips")
        .select("*")
        .eq("safe_id", user.safe_id)
        .in("status", ["pending", "in_transit"])
        .order("scheduled_pickup", { ascending: true });

      console.log("Trips query result:", data);
      console.log("Trips query error:", error);

      if (error) {
        console.error("Failed to load trips:", error);

        // If unauthorized, session might be invalid
        if (error.code === "PGRST301" || error.message?.includes("JWT")) {
          console.log("Session invalid, logging out");
          await mobileAuthService.logout();
          return;
        }

        tripsActions.setError("Failed to load trips");
        return;
      }

      console.log(`Found ${data?.length || 0} trips`);
      tripsActions.setTrips(data || []);
    } catch (err) {
      console.error("Exception loading trips:", err);
      tripsActions.setError("Failed to load trips");
    } finally {
      tripsActions.setLoading(false);
    }
  }

  async startTrip(tripId: string) {
    try {
      const sessionToken = mobileAuthService.getSessionToken();

      const { data, error } = await supabase.functions.invoke(
        "mobile-trip-action",
        {
          headers: {
            "x-session-token": sessionToken || "",
          },
          body: {
            action: "start_trip",
            trip_id: tripId,
          },
        }
      );

      if (error || !data.success) {
        console.error("Failed to start trip:", error || data.error);
        return {
          success: false,
          error: data?.error || error?.message || "Failed to start trip",
        };
      }

      tripsActions.updateTrip(tripId, data.trip);
      await this.logActivity("trip_started", tripId, "Trip started");

      return { success: true, trip: data.trip };
    } catch (err: any) {
      console.error("Error starting trip:", err);
      return { success: false, error: "Failed to start trip" };
    }
  }

  async completeTrip(tripId: string) {
    console.log("Attempting to complete trip:", tripId);

    try {
      const sessionToken = mobileAuthService.getSessionToken();

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke(
        "mobile-trip-action",
        {
          headers: {
            "x-session-token": sessionToken,
          },
          body: {
            action: "complete_trip",
            trip_id: tripId,
          },
        }
      );

      console.log("Complete trip response:", data);
      console.log("Complete trip error:", error);

      if (error) {
        console.error("Edge function error:", error);
        return {
          success: false,
          error: error.message || "Failed to complete trip",
        };
      }

      if (!data.success) {
        console.error("Failed to complete trip:", data.error);
        return {
          success: false,
          error: data.error || "Failed to complete trip",
        };
      }

      console.log("Trip completed successfully!");

      // Send delivery confirmation to CLIENT
      if (data.trip.client_email) {
        console.log(
          "Sending delivery confirmation to client:",
          data.trip.client_email
        );

        try {
          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
          const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

          const response = await fetch(
            `${supabaseUrl}/functions/v1/send-delivery-confirmation`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
              body: JSON.stringify({
                to: data.trip.client_email,
                client_name: data.trip.client_name,
                recipient_name:
                  data.trip.recipient_name || data.trip.client_name,
                trip_id: data.trip.id,
                delivery_address: data.trip.delivery_address,
                delivered_at: data.trip.actual_delivery_time,
              }),
            }
          );

          if (response.ok) {
            console.log("Delivery confirmation sent to client");
          } else {
            console.warn(
              "Delivery confirmation failed:",
              await response.text()
            );
          }
        } catch (emailError) {
          console.warn("Could not send delivery confirmation:", emailError);
          // Don't block on email failure
        }
      }

      tripsActions.updateTrip(tripId, data.trip);

      // Log audit trail
      await this.logActivity(
        "trip_completed",
        tripId,
        "Trip completed and safe unlocked"
      );

      return { success: true, trip: data.trip };
    } catch (err: any) {
      console.error("Exception completing trip:", err);
      return {
        success: false,
        error: "Failed to complete trip. Please try again.",
      };
    }
  }

  private async logActivity(event: string, tripId: string, details: string) {
    try {
      const user = currentUser.value;
      await supabase.from("activity_log").insert({
        event,
        user_type: "mobile",
        user_id: user?.username || "unknown",
        safe_id: user?.safe_id,
        trip_id: tripId,
        details,
        success: true,
        created_at: new Date().toISOString(),
      });
    } catch (err) {
      console.error("Failed to log activity:", err);
    }
  }

  setupRealtimeSubscriptions() {
    const user = currentUser.value;
    if (!user?.safe_id) return;

    console.log("Setting up trip subscriptions for safe:", user.safe_id);

    this.subscription = supabase
      .channel("trips-updates")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "trips",
          filter: `safe_id=eq.${user.safe_id}`,
        },
        (payload) => {
          console.log("Trip update received:", payload);

          if (payload.eventType === "INSERT") {
            tripsActions.addTrip(payload.new as TripData);
            this.showTripNotification(payload.new as TripData);
          } else if (payload.eventType === "UPDATE") {
            tripsActions.updateTrip(
              payload.new.id,
              payload.new as Partial<TripData>
            );
          }
        }
      )
      .subscribe((status) => {
        console.log("Realtime subscription status:", status);

        if (status === "CHANNEL_ERROR") {
          console.error("Realtime subscription error");
        }
      });
  }

  private showTripNotification(trip: TripData) {
    if ("Notification" in window && Notification.permission === "granted") {
      new Notification("New Trip Assigned!", {
        body: `Delivery for ${trip.client_name} - ${trip.pickup_address}`,
        icon: "/vite.svg",
      });
    }

    console.log("NEW TRIP ASSIGNED:", trip);
  }

  async requestNotificationPermission() {
    if ("Notification" in window) {
      const permission = await Notification.requestPermission();
      console.log("Notification permission:", permission);
      return permission === "granted";
    }
    return false;
  }

  cleanup() {
    if (this.subscription) {
      supabase.removeChannel(this.subscription);
    }
  }
}

export const tripsService = new TripsService();
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@preact/signals": "^2.3.1",
    "@supabase/supabase-js": "^2.57.2",
    "@tailwindcss/vite": "^4.1.12",
    "@types/leaflet": "^1.9.21",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "leaflet": "^1.9.4",
    "lucide-preact": "^0.541.0",
    "lucide-react": "^0.542.0",
    "preact": "^10.27.0"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.10.2",
    "typescript": "~5.8.3",
    "vite": "^7.1.2"
  }
}
</file>

<file path="frontend/src/components/CreateSafeModal.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  X,
  Shield,
  Smartphone,
  User,
  Eye,
  EyeOff,
  Copy,
  MapPin,
  AlertTriangle,
  RefreshCw,
} from "lucide-preact";
import { dataService } from "../services/data";
import { trackneticsService } from "../services/tracknetics";
import {
  mobileUserService,
  type MobileUserCredentials,
} from "../services/mobileUsers";
import { LoadingSpinner } from "./LoadingSpinner";
import { safes } from "../store/data";
import { supabase } from "../lib/supabase";

interface CreateSafeModalProps {
  onClose: () => void;
}

interface AdminUser {
  id: string;
  username: string;
}

interface TrackerDevice {
  id: string;
  sn: string; // IMEI
  name: string;
  status: string;
  isAvailable: boolean;
}

export function CreateSafeModal({ onClose }: CreateSafeModalProps) {
  const [currentStep, setCurrentStep] = useState(1);
  const [formData, setFormData] = useState({
    serial_number: "",
    device_hash: "",
    selected_tracker_id: "",
    assigned_to: "",
    driver_name: "",
  });

  // State management
  const [adminUsers, setAdminUsers] = useState<AdminUser[]>([]);
  const [availableTrackers, setAvailableTrackers] = useState<TrackerDevice[]>(
    []
  );
  const [loading, setLoading] = useState(false);
  const [loadingUsers, setLoadingUsers] = useState(true);
  const [loadingTrackers, setLoadingTrackers] = useState(false);
  const [trackersError, setTrackersError] = useState("");
  const [error, setError] = useState("");

  // Credentials state
  const [mobileCredentials, setMobileCredentials] =
    useState<MobileUserCredentials | null>(null);
  const [showCredentials, setShowCredentials] = useState(false);

  useEffect(() => {
    loadAdminUsers();
  }, []);

  const loadAdminUsers = async () => {
    try {
      const { data, error } = await supabase
        .from("profiles")
        .select("id, username")
        .eq("role", "admin")
        .eq("is_active", true)
        .order("username");

      if (error) {
        console.error("Failed to load admin users:", error);
      } else {
        setAdminUsers(data || []);
      }
    } catch (err) {
      console.error("Error loading admin users:", err);
    } finally {
      setLoadingUsers(false);
    }
  };

  // Load available trackers from Tracknetics
  const loadAvailableTrackers = async () => {
    setLoadingTrackers(true);
    setTrackersError("");

    try {
      // Get all devices from Tracknetics account
      const result = await trackneticsService.getDeviceList();

      if (!result.success || !result.devices) {
        throw new Error(result.error || "Failed to fetch tracking devices");
      }

      // Get trackers already assigned to safes in our database
      const assignedTrackerIds = safes.value
        .map((safe) => safe.tracknetics_device_id || safe.tracking_device_id)
        .filter(Boolean);

      // Filter to show only available trackers
      const availableDevices: TrackerDevice[] = result.devices.map(
        (device) => ({
          id: device.id,
          sn: device.sn,
          name: device.name,
          status: device.status,
          isAvailable: !assignedTrackerIds.includes(device.id),
        })
      );

      const unassignedCount = availableDevices.filter(
        (d) => d.isAvailable
      ).length;

      setAvailableTrackers(availableDevices);

      if (unassignedCount === 0) {
        setTrackersError(
          "No available trackers found. All trackers are already assigned to safes."
        );
      }
    } catch (error: any) {
      console.error("Error loading trackers:", error);

      if (
        error.message?.includes("Authentication failed") ||
        error.message?.includes("login") ||
        error.message?.includes("KEY incorrect")
      ) {
        setTrackersError(
          "Unable to connect to tracking service provider. Please contact Tracknetics support to ensure your account is active and service is online."
        );
      } else {
        setTrackersError(
          error.message ||
            "Failed to load tracking devices. Please check your connection and try again."
        );
      }
    } finally {
      setLoadingTrackers(false);
    }
  };

  const generateDeviceHash = () => {
    const chars = "ABCDEF0123456789";
    let hash = "";
    for (let i = 0; i < 16; i++) {
      hash += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    setFormData((prev) => ({ ...prev, device_hash: hash }));
  };

  const handleStep1Submit = (e: Event) => {
    e.preventDefault();
    if (!formData.serial_number || !formData.assigned_to) {
      setError("Please fill in all required fields");
      return;
    }
    setCurrentStep(2);
    setError("");
    // Load trackers when moving to step 2
    loadAvailableTrackers();
  };

  const handleStep2Submit = (e: Event) => {
    e.preventDefault();
    if (!formData.selected_tracker_id || !formData.device_hash) {
      setError("Please select a tracker and generate device hash");
      return;
    }
    setCurrentStep(3);
    setError("");
  };

  const handleFinalSubmit = async (e: Event) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      // Step 1: Create the safe
      const safeResult = await dataService.createSafe({
        serial_number: formData.serial_number,
        device_hash: formData.device_hash,
        tracking_device_id: formData.selected_tracker_id, // Store the selected tracker
        assigned_to: formData.assigned_to,
      });

      if (!safeResult.success) {
        setError(safeResult.error || "Failed to create safe");
        setLoading(false);
        return;
      }

      // Step 2: Create mobile app user
      const mobileUserResult = await mobileUserService.createMobileUser(
        safeResult.safe!.id,
        formData.serial_number,
        formData.driver_name
      );

      if (!mobileUserResult.success) {
        setError(
          `Safe created but failed to create mobile user: ${mobileUserResult.error}`
        );
        setLoading(false);
        return;
      }

      // Success! Show credentials
      setMobileCredentials(mobileUserResult.credentials!);
      setCurrentStep(4);
    } catch (err) {
      setError("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  const copyCredentials = () => {
    if (mobileCredentials) {
      const credentialsText = `Guardian Safe Mobile App Login:
Username: ${mobileCredentials.username}
Password: ${mobileCredentials.password}
      
Please save these credentials securely. The password will not be shown again.`;

      navigator.clipboard.writeText(credentialsText);
    }
  };

  const handleClose = () => {
    setCurrentStep(1);
    setFormData({
      serial_number: "",
      device_hash: "",
      selected_tracker_id: "",
      assigned_to: "",
      driver_name: "",
    });
    setAvailableTrackers([]);
    setMobileCredentials(null);
    setError("");
    setTrackersError("");
    onClose();
  };

  // Get selected tracker info
  const selectedTracker = availableTrackers.find(
    (t) => t.id === formData.selected_tracker_id
  );

  // Step 4: Show Credentials
  if (currentStep === 4 && mobileCredentials) {
    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
          <div className="flex items-center justify-between mb-6">
            <h2 className="text-xl font-bold text-gray-900">
              Safe Registered Successfully!
            </h2>
            <button
              onClick={handleClose}
              className="text-gray-400 hover:text-gray-600"
            >
              <X className="h-6 w-6" />
            </button>
          </div>

          <div className="space-y-4">
            <div className="bg-green-50 border border-green-200 rounded-lg p-4">
              <div className="flex items-center space-x-2 mb-3">
                <div className="bg-green-500 rounded-full p-1">
                  <Shield className="h-4 w-4 text-white" />
                </div>
                <h3 className="font-medium text-green-800">
                  Registration Complete
                </h3>
              </div>
              <div className="text-sm text-green-700 space-y-1">
                <p>
                  <strong>Safe:</strong> {formData.serial_number}
                </p>
                <p>
                  <strong>Tracker:</strong>{" "}
                  {selectedTracker?.name || formData.selected_tracker_id}
                </p>
                <p>
                  <strong>Status:</strong> Inactive (ready for activation)
                </p>
              </div>
            </div>

            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
              <div className="flex items-center justify-between mb-3">
                <div className="flex items-center space-x-2">
                  <Smartphone className="h-4 w-4 text-blue-600" />
                  <h3 className="font-medium text-blue-800">
                    Mobile App Credentials
                  </h3>
                </div>
                <button
                  onClick={() => setShowCredentials(!showCredentials)}
                  className="text-blue-600 hover:text-blue-800"
                >
                  {showCredentials ? (
                    <EyeOff className="h-4 w-4" />
                  ) : (
                    <Eye className="h-4 w-4" />
                  )}
                </button>
              </div>

              {showCredentials ? (
                <div className="space-y-3">
                  <div>
                    <p className="text-sm font-medium text-blue-700">
                      Username:
                    </p>
                    <p className="font-mono text-blue-900 bg-white px-2 py-1 rounded text-sm">
                      {mobileCredentials.username}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm font-medium text-blue-700">
                      Password:
                    </p>
                    <p className="font-mono text-blue-900 bg-white px-2 py-1 rounded text-sm">
                      {mobileCredentials.password}
                    </p>
                  </div>
                  <button
                    onClick={copyCredentials}
                    className="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 flex items-center justify-center space-x-2"
                  >
                    <Copy className="h-4 w-4" />
                    <span>Copy Credentials</span>
                  </button>
                </div>
              ) : (
                <p className="text-sm text-blue-700">
                  Click the eye icon to view the mobile app login credentials.
                </p>
              )}
            </div>

            <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
              <p className="text-sm text-yellow-800">
                <strong>Next Steps:</strong>
              </p>
              <ol className="text-sm text-yellow-700 mt-2 space-y-1 list-decimal list-inside">
                <li>Test the safe and tracker functionality</li>
                <li>Activate the safe from the Safes dashboard</li>
                <li>Provide mobile credentials to your driver</li>
              </ol>
            </div>

            <button onClick={handleClose} className="w-full btn btn-primary">
              Complete Registration
            </button>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md mx-4">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-bold text-gray-900">
            {currentStep === 1
              ? "Register New Safe"
              : currentStep === 2
              ? "Select Tracking Device"
              : "Configure Mobile Access"}
          </h2>
          <button
            onClick={handleClose}
            className="text-gray-400 hover:text-gray-600"
          >
            <X className="h-6 w-6" />
          </button>
        </div>

        {/* Step Indicator */}
        <div className="flex items-center justify-center space-x-4 mb-6">
          <div
            className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
              currentStep >= 1
                ? "bg-blue-600 text-white"
                : "bg-gray-200 text-gray-600"
            }`}
          >
            1
          </div>
          <div
            className={`h-1 w-8 ${
              currentStep >= 2 ? "bg-blue-600" : "bg-gray-200"
            }`}
          ></div>
          <div
            className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
              currentStep >= 2
                ? "bg-blue-600 text-white"
                : "bg-gray-200 text-gray-600"
            }`}
          >
            2
          </div>
          <div
            className={`h-1 w-8 ${
              currentStep >= 3 ? "bg-blue-600" : "bg-gray-200"
            }`}
          ></div>
          <div
            className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${
              currentStep >= 3
                ? "bg-blue-600 text-white"
                : "bg-gray-200 text-gray-600"
            }`}
          >
            3
          </div>
        </div>

        {error && (
          <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded text-sm mb-4">
            {error}
          </div>
        )}

        {/* Step 1: Basic Safe Info */}
        {currentStep === 1 && (
          <form onSubmit={handleStep1Submit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Safe Serial Number *
              </label>
              <div className="mt-1 relative">
                <input
                  type="text"
                  required
                  className="input pl-10"
                  placeholder="GS-2025-001"
                  value={formData.serial_number}
                  onInput={(e) =>
                    setFormData((prev) => ({
                      ...prev,
                      serial_number: (
                        e.target as HTMLInputElement
                      ).value.toUpperCase(),
                    }))
                  }
                />
                <Shield className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700">
                Assign to Admin User *
              </label>
              <div className="mt-1">
                {loadingUsers ? (
                  <div className="flex items-center justify-center py-2">
                    <LoadingSpinner size="small" />
                    <span className="ml-2 text-sm text-gray-500">
                      Loading users...
                    </span>
                  </div>
                ) : (
                  <select
                    required
                    className="input"
                    value={formData.assigned_to}
                    onChange={(e) =>
                      setFormData((prev) => ({
                        ...prev,
                        assigned_to: (e.target as HTMLSelectElement).value,
                      }))
                    }
                  >
                    <option value="">Select an admin user</option>
                    {adminUsers.map((user) => (
                      <option key={user.id} value={user.id}>
                        {user.username}
                      </option>
                    ))}
                  </select>
                )}
              </div>
            </div>

            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={handleClose}
                className="btn btn-secondary"
              >
                Cancel
              </button>
              <button type="submit" className="btn btn-primary">
                Continue
              </button>
            </div>
          </form>
        )}

        {/* Step 2: Tracker Selection */}
        {currentStep === 2 && (
          <form onSubmit={handleStep2Submit} className="space-y-4">
            <div>
              <div className="flex items-center justify-between mb-3">
                <label className="block text-sm font-medium text-gray-700">
                  Select GPS Tracker *
                </label>
                <button
                  type="button"
                  onClick={loadAvailableTrackers}
                  disabled={loadingTrackers}
                  className="text-blue-600 hover:text-blue-800 text-sm flex items-center space-x-1"
                >
                  <RefreshCw
                    className={`h-4 w-4 ${
                      loadingTrackers ? "animate-spin" : ""
                    }`}
                  />
                  <span>Refresh List</span>
                </button>
              </div>

              {loadingTrackers ? (
                <div className="flex items-center justify-center py-8 border-2 border-dashed border-gray-300 rounded-lg">
                  <div className="text-center">
                    <LoadingSpinner size="medium" />
                    <p className="mt-2 text-sm text-gray-500">
                      Fetching available trackers from Tracknetics...
                    </p>
                  </div>
                </div>
              ) : trackersError ? (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                  <div className="flex items-start space-x-3">
                    <AlertTriangle className="h-5 w-5 text-red-600 mt-0.5 flex-shrink-0" />
                    <div>
                      <p className="text-sm font-medium text-red-800 mb-2">
                        Unable to Load Trackers
                      </p>
                      <p className="text-sm text-red-700 mb-3">
                        {trackersError}
                      </p>
                      <div className="space-y-2">
                        <button
                          type="button"
                          onClick={loadAvailableTrackers}
                          className="text-sm bg-red-600 text-white px-3 py-1 rounded hover:bg-red-700"
                        >
                          Try Again
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              ) : (
                <div>
                  <select
                    required
                    className="input"
                    value={formData.selected_tracker_id}
                    onChange={(e) =>
                      setFormData((prev) => ({
                        ...prev,
                        selected_tracker_id: (e.target as HTMLSelectElement)
                          .value,
                      }))
                    }
                  >
                    <option value="">Select a tracking device</option>
                    {availableTrackers
                      .filter((tracker) => tracker.isAvailable)
                      .map((tracker) => (
                        <option key={tracker.id} value={tracker.id}>
                          {tracker.name} (ID: {tracker.id}) - {tracker.status}
                        </option>
                      ))}
                  </select>

                  {/* Tracker Info */}
                  {selectedTracker && (
                    <div className="mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                      <div className="flex items-center space-x-2 mb-2">
                        <MapPin className="h-4 w-4 text-blue-600" />
                        <h4 className="font-medium text-blue-800">
                          Selected Tracker
                        </h4>
                      </div>
                      <div className="text-sm text-blue-700 space-y-1">
                        <p>
                          <strong>Device:</strong> {selectedTracker.name}
                        </p>
                        <p>
                          <strong>ID:</strong> {selectedTracker.id}
                        </p>
                        <p>
                          <strong>IMEI:</strong> {selectedTracker.sn}
                        </p>
                        <p>
                          <strong>Status:</strong> {selectedTracker.status}
                        </p>
                      </div>
                    </div>
                  )}

                  {/* Statistics */}
                  <div className="mt-3 text-xs text-gray-500 text-center">
                    {availableTrackers.filter((t) => t.isAvailable).length}{" "}
                    available •{" "}
                    {availableTrackers.filter((t) => !t.isAvailable).length}{" "}
                    already assigned • {availableTrackers.length} total in
                    account
                  </div>
                </div>
              )}
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700">
                Device Hash (Phone + Pi Combo) *
              </label>
              <div className="mt-1 flex space-x-2">
                <div className="flex-1 relative">
                  <input
                    type="text"
                    required
                    className="input pl-10 font-mono"
                    placeholder="Generated device hash"
                    value={formData.device_hash}
                    onInput={(e) =>
                      setFormData((prev) => ({
                        ...prev,
                        device_hash: (
                          e.target as HTMLInputElement
                        ).value.toUpperCase(),
                      }))
                    }
                  />
                  <Smartphone className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                </div>
                <button
                  type="button"
                  onClick={generateDeviceHash}
                  className="btn btn-secondary"
                >
                  Generate
                </button>
              </div>
            </div>

            <div className="bg-green-50 border border-green-200 rounded p-3 text-sm text-green-700">
              <p className="font-medium">✅ Tracker Assignment Validated</p>
              <p className="mt-1">
                The selected tracker is confirmed available and will be assigned
                to this safe.
              </p>
            </div>

            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={() => setCurrentStep(1)}
                className="btn btn-secondary"
                disabled={loading}
              >
                Back
              </button>
              <button
                type="submit"
                className="btn btn-primary"
                disabled={
                  !formData.selected_tracker_id ||
                  !formData.device_hash ||
                  !!trackersError
                }
              >
                Continue
              </button>
            </div>
          </form>
        )}

        {/* Step 3: Mobile User Setup */}
        {currentStep === 3 && (
          <form onSubmit={handleFinalSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700">
                Driver Name (Optional)
              </label>
              <div className="mt-1 relative">
                <input
                  type="text"
                  className="input pl-10"
                  placeholder="John Doe"
                  value={formData.driver_name}
                  onInput={(e) =>
                    setFormData((prev) => ({
                      ...prev,
                      driver_name: (e.target as HTMLInputElement).value,
                    }))
                  }
                />
                <User className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
              </div>
              <p className="text-xs text-gray-500 mt-1">
                This will be used for the mobile app account
              </p>
            </div>

            {/* Summary */}
            <div className="bg-gray-50 rounded-lg p-4 space-y-3">
              <h4 className="font-medium text-gray-900">
                Registration Summary
              </h4>
              <div className="text-sm space-y-2">
                <div className="flex justify-between">
                  <span className="text-gray-500">Safe Serial:</span>
                  <span className="font-mono">{formData.serial_number}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-500">GPS Tracker:</span>
                  <span className="font-mono">
                    {selectedTracker?.name || formData.selected_tracker_id}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-500">Device Hash:</span>
                  <span className="font-mono text-xs">
                    {formData.device_hash}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-gray-500">Driver:</span>
                  <span>{formData.driver_name || "Auto-generated"}</span>
                </div>
              </div>
            </div>

            <div className="bg-blue-50 border border-blue-200 rounded p-3 text-sm text-blue-700">
              <p className="font-medium">What will be created:</p>
              <ul className="mt-1 space-y-1 list-disc list-inside">
                <li>Safe registration with validated GPS tracker</li>
                <li>Mobile app user account for driver access</li>
                <li>Secure login credentials for the safe's phone</li>
                <li>Safe will be created as INACTIVE (ready for testing)</li>
              </ul>
            </div>

            <div className="flex justify-end space-x-3 pt-4 border-t">
              <button
                type="button"
                onClick={() => setCurrentStep(2)}
                className="btn btn-secondary"
                disabled={loading}
              >
                Back
              </button>
              <button
                type="submit"
                className="btn btn-primary"
                disabled={loading}
              >
                {loading ? (
                  <>
                    <LoadingSpinner size="small" className="mr-2" />
                    Creating Safe...
                  </>
                ) : (
                  "Create Safe & Mobile User"
                )}
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );
}
</file>

<file path="mobile/capacitor.config.ts">
import { CapacitorConfig } from "@capacitor/cli";

const config: CapacitorConfig = {
  appId: "com.guardiansafe.mobile",
  appName: "Guardian Safe Driver",
  webDir: "dist",
  plugins: {
    BluetoothLe: {
      displayStrings: {
        scanning: "Scanning for Guardian Safe...",
        cancel: "Cancel",
        availableDevices: "Available Safes",
        noDeviceFound: "No Guardian Safe found",
      },
    },
    Geolocation: {
      permissions: {
        location: "always",
      },
    },
  },
};

export default config;
</file>

<file path="mobile/src/app.tsx">
import { useEffect } from "preact/hooks";
// import { Shield } from "lucide-preact";
import { mobileAuthService } from "./services/auth";
import { isAuthenticated, isLoading } from "./store/auth";
import { LoginScreen } from "./screens/LoginScreen";
import { DashboardScreen } from "./screens/DashboardScreen";
import { LoadingSpinner } from "./components/LoadingSpinner";

export function App() {
  const authenticated = isAuthenticated.value;
  const loading = isLoading.value;

  useEffect(() => {
    mobileAuthService.initialize();
  }, []);

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="mt-4 text-gray-600">Connecting to Khluys...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return <LoginScreen />;
  }

  // Show main dashboard
  return <DashboardScreen />;
}

export default App;
</file>

<file path="mobile/src/components/OTPGenerator.tsx">
import { MapPin, Send } from "lucide-preact";
import { LoadingSpinner } from "./LoadingSpinner";

interface OTPGeneratorProps {
  onOTPRequested: () => void;
  loading: boolean;
}

export function OTPGenerator({ onOTPRequested, loading }: OTPGeneratorProps) {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 text-center">
      <div className="bg-orange-50 rounded-full p-4 w-16 h-16 mx-auto mb-4 flex items-center justify-center">
        <Send className="h-8 w-8 text-brand" />
      </div>
      <h3 className="text-xl font-semibold text-gray-900 mb-2">
        Request Delivery Code
      </h3>
      <p className="text-gray-500 text-sm mb-6">
        Confirm your location to send the unlock code to the recipient.
      </p>

      <button
        onClick={onOTPRequested}
        disabled={loading}
        className="w-full btn btn-primary py-3 rounded-lg flex items-center justify-center gap-2"
      >
        {loading ? (
          <>
            <LoadingSpinner size="small" className="text-white" />
            <span>Verifying Location...</span>
          </>
        ) : (
          <>
            <MapPin className="h-4 w-4" />
            <span>Verify & Send Code</span>
          </>
        )}
      </button>
    </div>
  );
}
</file>

<file path="mobile/src/screens/DashboardScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  LogOut,
  Shield,
  // Bell,
  Package,
  AlertTriangle,
  Phone,
  RefreshCw,
  Unlock,
  Bluetooth,
} from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { tripsService } from "../services/trips";
import { currentUser, currentSafe } from "../store/auth";
import {
  currentTrips,
  pendingTrips,
  inTransitTrip,
  isLoading,
  error,
} from "../store/trips";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { TripCard } from "../components/TripCard";
import { DeliveryScreen } from "./DeliveryScreen";
import { bluetoothService } from "../services/bluetooth";

export function DashboardScreen() {
  const user = currentUser.value;
  const safe = currentSafe.value;
  const trips = currentTrips.value;
  const pending = pendingTrips.value;
  const inTransit = inTransitTrip.value;
  const loading = isLoading.value;
  const tripsError = error.value;

  const [selectedTrip, setSelectedTrip] = useState<any>(null);
  const [btConnected, setBtConnected] = useState(false);

  // Pi Status State
  const [piStatus, setPiStatus] = useState<{
    batteryPercent: number;
    safeStatus: string;
    voltage: number;
    lockOpen: boolean;
  } | null>(null);

  // 1. Initialize Bluetooth
  useEffect(() => {
    const initBluetooth = async () => {
      await bluetoothService.initialize();
      // Try auto-connect
      const scanResult = await bluetoothService.scanForPi();
      if (scanResult.success) {
        const connectResult = await bluetoothService.connectToPi();
        if (connectResult.success) {
          setBtConnected(true);
          // Initial status read
          const statusResult = await bluetoothService.readPiStatus();
          if (statusResult.success && statusResult.status) {
            updateStatusState(statusResult.status);
          }
        }
      }
    };
    initBluetooth();
    return () => bluetoothService.disconnect();
  }, []);

  // 2. Poll Status
  useEffect(() => {
    if (!btConnected) return;
    const pollStatus = async () => {
      const result = await bluetoothService.readPiStatus();
      if (result.success && result.status) {
        updateStatusState(result.status);
      }
    };
    const interval = setInterval(pollStatus, 30000);
    return () => clearInterval(interval);
  }, [btConnected]);

  // Helper to update status safely
  const updateStatusState = (status: any) => {
    setPiStatus({
      batteryPercent: status.batteryPercent,
      safeStatus: status.safeStatus,
      voltage: status.voltage,
      lockOpen: status.lockOpen,
    });
  };

  // 3. Load Trips
  useEffect(() => {
    tripsService.loadTrips();
    tripsService.setupRealtimeSubscriptions();
    return () => tripsService.cleanup();
  }, []);

  const handleStartTrip = async (tripId: string) => {
    const result = await tripsService.startTrip(tripId);
    if (result.success) {
      const trip = trips.find((t) => t.id === tripId);
      if (trip) setSelectedTrip(trip);
    } else {
      alert(`Error: ${result.error}`);
    }
  };

  const handleLogout = async () => {
    if (confirm("Sign out of driver session?")) {
      await mobileAuthService.logout();
    }
  };

  const handleSOS = () => {
    alert("SOS ACTIVATED: Emergency services notified.");
  };

  // If a trip is selected or in progress, show Delivery Screen
  if (selectedTrip) {
    return (
      <DeliveryScreen
        trip={selectedTrip}
        onBack={() => setSelectedTrip(null)}
      />
    );
  }

  // Main Dashboard UI
  return (
    <div className="min-h-screen bg-gray-50 pb-safe">
      {/* Header */}
      <div className="bg-white pt-safe px-4 py-4 pt-6 border-b border-gray-200 sticky top-0 z-20 shadow-sm">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-xl font-bold text-gray-900">
              Hi, {user?.driver_name || user?.username}
            </h1>
            <p className="text-xs text-gray-500 mt-0.5">
              Safe ID:{" "}
              <span className="font-mono font-medium">
                {safe?.serial_number}
              </span>
            </p>
          </div>
          <button
            onClick={handleSOS}
            className="bg-red-50 text-red-600 p-2.5 rounded-full border border-red-100 active:scale-95 transition-transform shadow-sm"
          >
            <Phone className="h-5 w-5" />
          </button>
        </div>
      </div>

      {/* Safe Status Scroll */}
      <div className="bg-gray-50 pt-4 pb-2 px-4">
        <div className="flex gap-3 overflow-x-auto no-scrollbar pb-2">
          {/* Status Card: Connection */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <div className="flex items-center gap-2 text-xs text-gray-500 mb-2">
              <Bluetooth className="h-3.5 w-3.5" /> Connection
            </div>
            <div className="flex items-center gap-2">
              <div
                className={`w-2.5 h-2.5 rounded-full ${
                  btConnected ? "bg-green-500 animate-pulse" : "bg-gray-300"
                }`}
              ></div>
              <span className="text-sm font-medium text-gray-900">
                {btConnected ? "Connected" : "Offline"}
              </span>
            </div>
          </div>

          {/* Status Card: Battery */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <p className="text-xs text-gray-500 mb-2">Battery Level</p>
            <div className="flex items-baseline gap-1">
              <span
                className={`text-xl font-bold ${
                  (piStatus?.batteryPercent ?? safe?.battery_level ?? 0) < 20
                    ? "text-red-600"
                    : "text-gray-900"
                }`}
              >
                {piStatus?.batteryPercent ?? safe?.battery_level ?? 0}%
              </span>
              {piStatus?.voltage && (
                <span className="text-xs text-gray-400">
                  {piStatus.voltage.toFixed(1)}V
                </span>
              )}
            </div>
          </div>

          {/* Status Card: Lock */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <p className="text-xs text-gray-500 mb-2">Lock State</p>
            <div className="flex items-center gap-1.5">
              {piStatus?.lockOpen || safe?.is_locked === false ? (
                <>
                  <Unlock className="h-4 w-4 text-red-600" />
                  <span className="text-sm font-medium text-red-600">
                    Unlocked
                  </span>
                </>
              ) : (
                <>
                  <Shield className="h-4 w-4 text-green-600" />
                  <span className="text-sm font-medium text-green-600">
                    Secured
                  </span>
                </>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Warnings */}
      <div className="px-4 space-y-2">
        {!btConnected && (
          <div className="bg-gray-900 text-white px-4 py-3 rounded-lg flex items-center justify-between shadow-sm">
            <div className="flex items-center gap-3">
              <Bluetooth className="h-5 w-5 text-gray-400" />
              <span className="text-sm font-medium">Safe disconnected</span>
            </div>
          </div>
        )}
        {tripsError && (
          <div className="bg-red-50 border border-red-100 text-red-700 px-4 py-3 rounded-lg flex items-center gap-2 text-sm">
            <AlertTriangle className="h-4 w-4" /> {tripsError}
          </div>
        )}
      </div>

      {/* Main Content */}
      <div className="px-4 py-4 space-y-6 pb-24">
        {loading ? (
          <div className="py-12 text-center">
            <LoadingSpinner size="large" />
            <p className="mt-3 text-sm text-gray-500">Syncing trips...</p>
          </div>
        ) : (
          <>
            {/* In Transit Section */}
            {inTransit && (
              <section>
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-3 flex items-center gap-2">
                  <Package className="h-4 w-4" /> Current Job
                </h2>
                <div
                  onClick={() => setSelectedTrip(inTransit)}
                  className="cursor-pointer active:scale-[0.98] transition-transform"
                >
                  <TripCard trip={inTransit} variant="active" />
                </div>
              </section>
            )}

            {/* Pending Section */}
            <section>
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider">
                  Up Next ({pending.length})
                </h2>
                <button
                  onClick={() => tripsService.loadTrips()}
                  className="text-brand text-xs font-medium p-1"
                >
                  Refresh
                </button>
              </div>

              {pending.length === 0 && !inTransit ? (
                <div className="text-center py-10 bg-white rounded-xl border border-dashed border-gray-200">
                  <Package className="h-10 w-10 text-gray-300 mx-auto mb-2" />
                  <p className="text-sm text-gray-500">No trips assigned.</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {pending.map((trip) => (
                    <TripCard
                      key={trip.id}
                      trip={trip}
                      onStartTrip={() => handleStartTrip(trip.id)}
                      onViewDetails={() => setSelectedTrip(trip)}
                    />
                  ))}
                </div>
              )}
            </section>
          </>
        )}
      </div>

      {/* Bottom Navigation */}
      <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 pb-safe px-6 py-3 pb-8 flex justify-between items-center z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
        <button className="flex flex-col items-center gap-1 text-brand w-16">
          <Shield className="h-6 w-6" />
          <span className="text-[10px] font-medium">Home</span>
        </button>
        <button
          className="flex flex-col items-center gap-1 text-gray-400 hover:text-gray-600 active:text-gray-800 w-16"
          onClick={() => tripsService.loadTrips()}
        >
          <RefreshCw className="h-6 w-6" />
          <span className="text-[10px] font-medium">Sync</span>
        </button>
        <button
          className="flex flex-col items-center gap-1 text-gray-400 hover:text-red-600 active:text-red-700 w-16"
          onClick={handleLogout}
        >
          <LogOut className="h-6 w-6" />
          <span className="text-[10px] font-medium">Exit</span>
        </button>
      </div>
    </div>
  );
}
</file>

<file path="mobile/src/screens/LoginScreen.tsx">
import { useState } from "preact/hooks";
import { Shield, Eye, EyeOff, AlertTriangle, ArrowRight } from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { validateUsername, validatePassword } from "../utils/validation";

export function LoginScreen() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [validationErrors, setValidationErrors] = useState<{
    username?: string;
    password?: string;
  }>({});

  const validateForm = (): boolean => {
    const errors: { username?: string; password?: string } = {};

    const usernameValidation = validateUsername(username);
    if (!usernameValidation.valid) {
      errors.username = usernameValidation.error;
    }

    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      errors.password = passwordValidation.error;
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleLogin = async (e: Event) => {
    e.preventDefault();
    setError("");
    setValidationErrors({});

    // Client-side validation
    if (!validateForm()) {
      return;
    }

    setLoading(true);

    try {
      const result = await mobileAuthService.login(username, password);

      if (!result.success) {
        setError(result.error || "Login failed");
      }
    } catch (err) {
      setError("Network error. Please check your connection.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center px-6 py-12 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-sm text-center">
        <div className="mx-auto h-16 w-16 bg-gray-900 rounded-xl flex items-center justify-center shadow-sm mb-6">
          <Shield className="h-8 w-8 text-brand" />
        </div>
        <h2 className="text-2xl font-semibold tracking-tight text-gray-900">
          Driver Access
        </h2>
        <p className="mt-2 text-sm text-gray-500">Khluys</p>
      </div>

      <div className="mt-10 sm:mx-auto sm:w-full sm:max-w-sm">
        <form className="space-y-6" onSubmit={handleLogin}>
          {error && (
            <div className="bg-red-50 border border-red-100 rounded-lg p-3 flex items-center space-x-3">
              <AlertTriangle className="h-5 w-5 text-red-600 flex-shrink-0" />
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          <div>
            <label htmlFor="username" className="label">
              Username
            </label>
            <div className="mt-1">
              <input
                id="username"
                name="username"
                type="text"
                autoComplete="username"
                required
                className={`input ${
                  validationErrors.username
                    ? "border-red-300 focus:border-red-500 focus:ring-red-200"
                    : ""
                }`}
                placeholder="Enter username"
                value={username}
                onInput={(e) => {
                  setUsername((e.target as HTMLInputElement).value);
                  setValidationErrors({
                    ...validationErrors,
                    username: undefined,
                  });
                }}
              />
              {validationErrors.username && (
                <p className="mt-1 text-sm text-red-600">
                  {validationErrors.username}
                </p>
              )}
            </div>
          </div>

          <div>
            <label htmlFor="password" className="label">
              Password
            </label>
            <div className="mt-1 relative">
              <input
                id="password"
                name="password"
                type={showPassword ? "text" : "password"}
                autoComplete="current-password"
                required
                className={`input pr-10 ${
                  validationErrors.password
                    ? "border-red-300 focus:border-red-500 focus:ring-red-200"
                    : ""
                }`}
                placeholder="Enter password"
                value={password}
                onInput={(e) => {
                  setPassword((e.target as HTMLInputElement).value);
                  setValidationErrors({
                    ...validationErrors,
                    password: undefined,
                  });
                }}
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600 transition-colors"
                onClick={() => setShowPassword(!showPassword)}
              >
                {showPassword ? (
                  <EyeOff className="h-5 w-5" />
                ) : (
                  <Eye className="h-5 w-5" />
                )}
              </button>
            </div>
            {validationErrors.password && (
              <p className="mt-1 text-sm text-red-600">
                {validationErrors.password}
              </p>
            )}
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full btn btn-primary py-3 text-base shadow-md"
          >
            {loading ? (
              <div className="flex items-center justify-center space-x-2">
                <LoadingSpinner
                  size="small"
                  className="text-white border-white"
                />
                <span>Authenticating...</span>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                <span>Sign In</span>
                <ArrowRight className="ml-2 h-4 w-4" />
              </div>
            )}
          </button>
        </form>

        <p className="mt-10 text-center text-xs text-gray-400">
          V0.2 • For Authorized Personnel Only
        </p>
      </div>
    </div>
  );
}
</file>

<file path="mobile/src/services/auth.ts">
import { supabase } from "./supabase";
import { authActions } from "../store/auth";

class MobileAuthService {
  private readonly STORAGE_KEY = "guardian_mobile_user";

  async initialize() {
    authActions.setLoading(true);

    console.log("Initializing mobile auth...");

    try {
      const storedUser = this.getStoredUser();

      if (storedUser) {
        const isValid = await this.validateAndRefreshUser(storedUser);

        if (isValid) {
          console.log("Stored user is valid");
          return;
        } else {
          console.log("Stored user is invalid, clearing...");
          this.clearStoredUser();
        }
      }

      console.log("No valid stored user found");
    } catch (error) {
      console.error("Auth initialization error:", error);
      this.clearStoredUser();
    } finally {
      authActions.setLoading(false);
    }
  }

  async login(username: string, password: string) {
    console.log("Attempting mobile login for:", username);

    try {
      // Call the mobile-auth Edge Function
      const { data, error } = await supabase.functions.invoke("mobile-auth", {
        body: {
          username: username.trim(),
          password: password,
        },
      });

      if (error) {
        console.error("Mobile auth error:", error);
        return { success: false, error: "Login failed. Please try again." };
      }

      if (!data.success) {
        console.log("Login failed:", data.error);
        return { success: false, error: data.error || "Invalid credentials" };
      }

      console.log("Login successful for:", data.user.username);

      // Store session token
      this.storeSession(data.session.token, data.session.expires_at);

      // Create mobile user object with proper typing
      const mobileUser = {
        id: data.user.id as string,
        username: data.user.username as string,
        driver_name: data.user.driver_name as string | undefined,
        safe_id: data.user.safe_id as string,
        safe: data.safe
          ? {
              id: data.safe.id as string,
              serial_number: data.safe.serial_number as string,
              status: data.safe.status as string,
              battery_level: data.safe.battery_level as number,
              is_locked: data.safe.is_locked as boolean,
              tracking_device_id: (data.safe.tracking_device_id ||
                data.safe.tracknetics_device_id) as string | undefined,
            }
          : null,
        is_active: true,
        created_at: new Date().toISOString(),
      };

      this.storeUser(mobileUser);
      authActions.setUser(mobileUser);

      return { success: true };
    } catch (error: any) {
      console.error("Login exception:", error);
      return { success: false, error: "Network error. Please try again." };
    }
  }

  async logout() {
    console.log("Logging out...");
    this.clearStoredUser();
    this.clearSession();
    authActions.logout();
  }

  private async validateAndRefreshUser(storedUser: any): Promise<boolean> {
    try {
      // Check if session is still valid
      const session = this.getStoredSession();
      if (!session || new Date(session.expires_at) < new Date()) {
        console.log("Session expired");
        return false;
      }

      // Verify user still exists and is active
      const { data: user, error: userError } = await supabase
        .from("mobile_users")
        .select("*")
        .eq("username", storedUser.username)
        .eq("is_active", true)
        .single();

      if (userError || !user) {
        console.log("User validation failed:", userError);
        return false;
      }

      // Get fresh safe data
      const { data: safe, error: safeError } = await supabase
        .from("safes")
        .select("*")
        .eq("id", user.safe_id)
        .single();

      if (safeError) {
        console.log("Safe lookup failed:", safeError);
        // Continue with null safe
      }

      const refreshedUser = {
        id: user.id as string,
        username: user.username as string,
        driver_name: user.driver_name as string | undefined,
        safe_id: user.safe_id as string,
        safe: safe
          ? {
              id: safe.id as string,
              serial_number: safe.serial_number as string,
              status: safe.status as string,
              battery_level: safe.battery_level as number,
              is_locked: safe.is_locked as boolean,
              tracking_device_id: (safe.tracking_device_id ||
                safe.tracknetics_device_id) as string | undefined,
            }
          : null,
        is_active: user.is_active as boolean,
        created_at: user.created_at as string,
      };

      this.storeUser(refreshedUser);
      authActions.setUser(refreshedUser);

      return true;
    } catch (error) {
      console.error("User validation error:", error);
      return false;
    }
  }

  private getStoredUser(): any {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  }

  private storeUser(user: any): void {
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(user));
    } catch (error) {
      console.error("Failed to store user:", error);
    }
  }

  private clearStoredUser(): void {
    try {
      localStorage.removeItem(this.STORAGE_KEY);
    } catch (error) {
      console.error("Failed to clear stored user:", error);
    }
  }

  private getStoredSession(): { token: string; expires_at: string } | null {
    try {
      const stored = localStorage.getItem("guardian_mobile_session");
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  }

  private storeSession(token: string, expires_at: string): void {
    try {
      localStorage.setItem(
        "guardian_mobile_session",
        JSON.stringify({ token, expires_at })
      );
    } catch (error) {
      console.error("Failed to store session:", error);
    }
  }

  private clearSession(): void {
    try {
      localStorage.removeItem("guardian_mobile_session");
    } catch (error) {
      console.error("Failed to clear session:", error);
    }
  }

  // Get current session token for authenticated requests
  getSessionToken(): string | null {
    const session = this.getStoredSession();
    if (!session || new Date(session.expires_at) < new Date()) {
      return null;
    }
    return session.token;
  }
}

export const mobileAuthService = new MobileAuthService();
</file>

<file path="frontend/src/components/CreateTripModal.tsx">
import { useState } from "preact/hooks";
import {
  X,
  MapPin,
  Calendar,
  User,
  // Phone,
  // Mail,
  ArrowRight,
  AlertTriangle,
  Shield,
  Users,
} from "lucide-preact";
import { dataService, type TripBookingData } from "../services/data";
import { LoadingSpinner } from "./LoadingSpinner";
import type { Safe } from "../types";

interface CreateTripModalProps {
  onClose: () => void;
  availableSafes: Safe[];
}

export function CreateTripModal({
  onClose,
  availableSafes,
}: CreateTripModalProps) {
  const [currentStep, setCurrentStep] = useState(1);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  // Restored FULL data structure matching your original logic
  const [formData, setFormData] = useState<TripBookingData>({
    safe_id: "",
    // Client (The person paying/booking)
    client_name: "",
    client_phone: "",
    client_email: "",

    // Recipient (The person receiving the OTP)
    recipient_is_client: true,
    recipient_name: "",
    recipient_email: "",
    recipient_phone: "",

    // Logistics
    pickup_address: "",
    pickup_contact_name: "",
    pickup_contact_phone: "",

    delivery_address: "",
    delivery_contact_name: "",
    delivery_contact_phone: "",

    scheduled_pickup: "",
    scheduled_delivery: "",
    priority: "normal",
    requires_signature: false,
    special_instructions: "",
    delivery_notes: "",
  });

  const steps = [
    { id: 1, title: "Client & Recipient", icon: User },
    { id: 2, title: "Locations", icon: MapPin },
    { id: 3, title: "Schedule", icon: Calendar },
  ];

  const handleNext = () => {
    setError("");
    // Basic validation per step
    if (currentStep === 1) {
      if (!formData.safe_id) return setError("Please select a safe.");
      if (!formData.client_name) return setError("Client Name is required.");
      // If recipient is NOT client, we need those details for the OTP
      if (!formData.recipient_is_client) {
        if (!formData.recipient_name || !formData.recipient_email) {
          return setError(
            "Recipient Name and Email are required for OTP delivery."
          );
        }
      }
    }
    if (currentStep === 2) {
      if (!formData.pickup_address || !formData.delivery_address) {
        return setError("Both Pickup and Delivery addresses are required.");
      }
    }
    setCurrentStep((c) => c + 1);
  };

  const handleSubmit = async () => {
    setLoading(true);
    setError("");

    try {
      const result = await dataService.createTrip(formData);
      if (result.success) {
        onClose();
      } else {
        setError(result.error || "Failed to book trip");
      }
    } catch (err) {
      setError("An unexpected error occurred.");
    } finally {
      setLoading(false);
    }
  };

  // Helper to auto-fill recipient if same as client
  const toggleRecipient = (isClient: boolean) => {
    setFormData((prev) => ({
      ...prev,
      recipient_is_client: isClient,
      // If switching back to client, clear the manual recipient fields to avoid confusion
      recipient_name: isClient ? "" : prev.recipient_name,
      recipient_email: isClient ? "" : prev.recipient_email,
      recipient_phone: isClient ? "" : prev.recipient_phone,
    }));
  };

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div
        className="fixed inset-0 bg-gray-900/40 backdrop-blur-sm transition-opacity"
        onClick={onClose}
      ></div>

      <div className="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0">
        <div className="relative w-full max-w-3xl bg-white rounded-lg shadow-2xl overflow-hidden animate-slide-up text-left">
          {/* Header */}
          <div className="bg-white px-6 py-4 border-b border-gray-100 flex justify-between items-center">
            <div>
              <h3 className="text-lg font-medium text-gray-900">
                Book New Transport
              </h3>
              <div className="flex items-center gap-4 mt-2">
                {steps.map((step, idx) => (
                  <div
                    key={step.id}
                    className={`flex items-center text-xs font-medium ${
                      currentStep >= step.id ? "text-brand" : "text-gray-400"
                    }`}
                  >
                    <span
                      className={`w-6 h-6 rounded-full flex items-center justify-center mr-2 border ${
                        currentStep >= step.id
                          ? "bg-brand/5 border-brand"
                          : "bg-gray-50 border-gray-200"
                      }`}
                    >
                      {step.id}
                    </span>
                    {step.title}
                    {idx < steps.length - 1 && (
                      <span className="mx-3 text-gray-300">/</span>
                    )}
                  </div>
                ))}
              </div>
            </div>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-600 transition-colors p-2 hover:bg-gray-50 rounded-full"
            >
              <X className="h-5 w-5" />
            </button>
          </div>

          {/* Progress Line */}
          <div className="w-full bg-gray-50 h-0.5">
            <div
              className="bg-brand h-0.5 transition-all duration-300"
              style={{ width: `${(currentStep / 3) * 100}%` }}
            />
          </div>

          {/* Content Body */}
          <div className="p-6 max-h-[70vh] overflow-y-auto">
            {error && (
              <div className="mb-6 bg-red-50 border border-red-100 text-red-600 px-4 py-3 rounded-md text-sm flex items-center animate-fade-in">
                <AlertTriangle className="h-4 w-4 mr-2" /> {error}
              </div>
            )}

            {/* STEP 1: Client & Recipient (Crucial for OTP) */}
            {currentStep === 1 && (
              <div className="space-y-8 animate-fade-in">
                {/* Section: Resources */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="col-span-2">
                    <label className="label">Assign Safe *</label>
                    <div className="relative">
                      <Shield className="absolute left-3 top-2.5 h-4 w-4 text-gray-400" />
                      <select
                        className="input pl-9"
                        value={formData.safe_id}
                        onChange={(e) =>
                          setFormData({
                            ...formData,
                            safe_id: (e.target as HTMLSelectElement).value,
                          })
                        }
                      >
                        <option value="">Select a safe unit...</option>
                        {availableSafes.map((safe) => (
                          <option key={safe.id} value={safe.id}>
                            {safe.serial_number} — {safe.status} (
                            {safe.battery_level}%)
                          </option>
                        ))}
                      </select>
                    </div>
                  </div>
                </div>

                {/* Section: Client Details */}
                <div>
                  <h4 className="text-sm font-medium text-gray-900 mb-4 border-b border-gray-100 pb-2">
                    Client Details (Booker)
                  </h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="col-span-2 md:col-span-1">
                      <label className="label">Client Name *</label>
                      <input
                        type="text"
                        className="input"
                        placeholder="e.g. Acme Jewelry"
                        value={formData.client_name}
                        onInput={(e) =>
                          setFormData({
                            ...formData,
                            client_name: (e.target as HTMLInputElement).value,
                          })
                        }
                      />
                    </div>
                    <div className="col-span-2 md:col-span-1">
                      <label className="label">Client Phone</label>
                      <input
                        type="tel"
                        className="input"
                        placeholder="+27..."
                        value={formData.client_phone}
                        onInput={(e) =>
                          setFormData({
                            ...formData,
                            client_phone: (e.target as HTMLInputElement).value,
                          })
                        }
                      />
                    </div>
                    <div className="col-span-2">
                      <label className="label">
                        Client Email (for invoice/tracking)
                      </label>
                      <input
                        type="email"
                        className="input"
                        placeholder="accounts@acme.com"
                        value={formData.client_email}
                        onInput={(e) =>
                          setFormData({
                            ...formData,
                            client_email: (e.target as HTMLInputElement).value,
                          })
                        }
                      />
                    </div>
                  </div>
                </div>

                {/* Section: Recipient / OTP Target */}
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                  <div className="flex items-center justify-between mb-4">
                    <h4 className="text-sm font-medium text-gray-900 flex items-center gap-2">
                      <Users className="h-4 w-4" /> Recipient & OTP Settings
                    </h4>
                    <label className="flex items-center gap-2 text-sm text-gray-600 cursor-pointer">
                      <input
                        type="checkbox"
                        checked={formData.recipient_is_client}
                        onChange={(e) =>
                          toggleRecipient(
                            (e.target as HTMLInputElement).checked
                          )
                        }
                        className="text-brand focus:ring-brand rounded border-gray-300"
                      />
                      Recipient is same as Client
                    </label>
                  </div>

                  {!formData.recipient_is_client ? (
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 animate-fade-in">
                      <div className="col-span-2 md:col-span-1">
                        <label className="label">Recipient Name *</label>
                        <input
                          type="text"
                          className="input bg-white"
                          placeholder="Receiver Name"
                          value={formData.recipient_name}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              recipient_name: (e.target as HTMLInputElement)
                                .value,
                            })
                          }
                        />
                      </div>
                      <div className="col-span-2 md:col-span-1">
                        <label className="label">
                          Recipient Phone (for SMS OTP)
                        </label>
                        <input
                          type="tel"
                          className="input bg-white"
                          placeholder="+27..."
                          value={formData.recipient_phone}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              recipient_phone: (e.target as HTMLInputElement)
                                .value,
                            })
                          }
                        />
                      </div>
                      <div className="col-span-2">
                        <label className="label">
                          Recipient Email (for Email OTP) *
                        </label>
                        <input
                          type="email"
                          className="input bg-white"
                          placeholder="receiver@email.com"
                          value={formData.recipient_email}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              recipient_email: (e.target as HTMLInputElement)
                                .value,
                            })
                          }
                        />
                        <p className="text-xs text-gray-500 mt-1">
                          The OTP required to unlock the safe will be sent here.
                        </p>
                      </div>
                    </div>
                  ) : (
                    <p className="text-sm text-gray-500 italic">
                      The secure OTP will be sent to the Client's contact
                      details entered above.
                    </p>
                  )}
                </div>
              </div>
            )}

            {/* STEP 2: Locations & Site Contacts */}
            {currentStep === 2 && (
              <div className="space-y-8 animate-fade-in">
                {/* Pickup */}
                <div>
                  <div className="flex items-center gap-2 mb-3 text-brand font-medium">
                    <MapPin className="h-4 w-4" /> Pickup Details
                  </div>
                  <div className="space-y-4 pl-6 border-l-2 border-gray-100">
                    <div>
                      <label className="label">Pickup Address *</label>
                      <textarea
                        className="input min-h-[60px]"
                        placeholder="Full street address..."
                        value={formData.pickup_address}
                        onInput={(e) =>
                          setFormData({
                            ...formData,
                            pickup_address: (e.target as HTMLTextAreaElement)
                              .value,
                          })
                        }
                      />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <label className="label">Site Contact Name</label>
                        <input
                          type="text"
                          className="input"
                          placeholder="e.g. Security Desk"
                          value={formData.pickup_contact_name}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              pickup_contact_name: (
                                e.target as HTMLInputElement
                              ).value,
                            })
                          }
                        />
                      </div>
                      <div>
                        <label className="label">Site Contact Phone</label>
                        <input
                          type="tel"
                          className="input"
                          placeholder="Optional"
                          value={formData.pickup_contact_phone}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              pickup_contact_phone: (
                                e.target as HTMLInputElement
                              ).value,
                            })
                          }
                        />
                      </div>
                    </div>
                  </div>
                </div>

                {/* Delivery */}
                <div>
                  <div className="flex items-center gap-2 mb-3 text-gray-900 font-medium">
                    <MapPin className="h-4 w-4" /> Delivery Details
                  </div>
                  <div className="space-y-4 pl-6 border-l-2 border-gray-100">
                    <div>
                      <label className="label">Delivery Address *</label>
                      <textarea
                        className="input min-h-[60px]"
                        placeholder="Full street address..."
                        value={formData.delivery_address}
                        onInput={(e) =>
                          setFormData({
                            ...formData,
                            delivery_address: (e.target as HTMLTextAreaElement)
                              .value,
                          })
                        }
                      />
                    </div>
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <label className="label">Site Contact Name</label>
                        <input
                          type="text"
                          className="input"
                          placeholder="e.g. Reception"
                          value={formData.delivery_contact_name}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              delivery_contact_name: (
                                e.target as HTMLInputElement
                              ).value,
                            })
                          }
                        />
                      </div>
                      <div>
                        <label className="label">Site Contact Phone</label>
                        <input
                          type="tel"
                          className="input"
                          placeholder="Optional"
                          value={formData.delivery_contact_phone}
                          onInput={(e) =>
                            setFormData({
                              ...formData,
                              delivery_contact_phone: (
                                e.target as HTMLInputElement
                              ).value,
                            })
                          }
                        />
                      </div>
                    </div>
                  </div>
                </div>

                <div className="flex items-center gap-2 p-4 bg-gray-50 rounded-md border border-gray-100">
                  <input
                    type="checkbox"
                    id="sig"
                    checked={formData.requires_signature}
                    onChange={(e) =>
                      setFormData({
                        ...formData,
                        requires_signature: (e.target as HTMLInputElement)
                          .checked,
                      })
                    }
                    className="rounded border-gray-300 text-brand focus:ring-brand"
                  />
                  <label htmlFor="sig" className="text-sm text-gray-700">
                    Require digital signature on driver device upon delivery
                  </label>
                </div>
              </div>
            )}

            {/* STEP 3: Schedule & Review */}
            {currentStep === 3 && (
              <div className="space-y-6 animate-fade-in">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="label">Scheduled Pickup *</label>
                    <input
                      type="datetime-local"
                      className="input"
                      value={formData.scheduled_pickup}
                      onInput={(e) =>
                        setFormData({
                          ...formData,
                          scheduled_pickup: (e.target as HTMLInputElement)
                            .value,
                        })
                      }
                    />
                  </div>
                  <div>
                    <label className="label">Scheduled Delivery *</label>
                    <input
                      type="datetime-local"
                      className="input"
                      value={formData.scheduled_delivery}
                      onInput={(e) =>
                        setFormData({
                          ...formData,
                          scheduled_delivery: (e.target as HTMLInputElement)
                            .value,
                        })
                      }
                    />
                  </div>
                  <div className="col-span-1 md:col-span-2">
                    <label className="label">Priority Level</label>
                    <select
                      className="input"
                      value={formData.priority}
                      onChange={(e) =>
                        setFormData({
                          ...formData,
                          priority: (e.target as HTMLSelectElement)
                            .value as any,
                        })
                      }
                    >
                      <option value="low">Low</option>
                      <option value="normal">Normal</option>
                      <option value="high">High Priority</option>
                      <option value="urgent">URGENT</option>
                    </select>
                  </div>
                </div>

                <div>
                  <label className="label">
                    Special Instructions (Driver Visible)
                  </label>
                  <textarea
                    className="input"
                    placeholder="e.g. Use side entrance, verify ID..."
                    value={formData.special_instructions}
                    onInput={(e) =>
                      setFormData({
                        ...formData,
                        special_instructions: (e.target as HTMLTextAreaElement)
                          .value,
                      })
                    }
                  />
                </div>

                <div className="bg-brand/5 border border-brand/10 rounded-md p-4 text-sm">
                  <h4 className="font-medium text-brand mb-2">
                    OTP Delivery Summary
                  </h4>
                  <p className="text-gray-600">
                    The secure unlock code will be sent to: <br />
                    <span className="font-medium text-gray-900">
                      {formData.recipient_is_client
                        ? formData.client_name
                        : formData.recipient_name}
                    </span>{" "}
                    (
                    {formData.recipient_is_client
                      ? formData.client_email
                      : formData.recipient_email}
                    )
                  </p>
                </div>
              </div>
            )}
          </div>

          {/* Footer Actions */}
          <div className="bg-gray-50 px-6 py-4 flex justify-between items-center border-t border-gray-100">
            {currentStep > 1 ? (
              <button
                onClick={() => setCurrentStep((c) => c - 1)}
                className="btn btn-secondary"
              >
                Back
              </button>
            ) : (
              <button onClick={onClose} className="btn btn-ghost">
                Cancel
              </button>
            )}

            <button
              onClick={() =>
                currentStep === 3 ? handleSubmit() : handleNext()
              }
              className="btn btn-primary min-w-[120px]"
              disabled={loading}
            >
              {loading ? (
                <LoadingSpinner size="small" className="text-white" />
              ) : (
                <>
                  {currentStep === 3 ? "Confirm Booking" : "Next Step"}
                  {currentStep !== 3 && <ArrowRight className="ml-2 h-4 w-4" />}
                </>
              )}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/components/LiveTracking.tsx">
import { useState, useEffect, useRef } from "preact/hooks";
import {
  MapPin,
  Navigation,
  RefreshCw,
  Satellite,
  AlertTriangle,
  Battery,
} from "lucide-preact";
import { LoadingSpinner } from "./LoadingSpinner";
import { trackneticsService } from "../services/tracknetics";
import type { Safe } from "../types";
import { formatDistanceToNow } from "date-fns";
import L from "leaflet";
import {
  fixLeafletIcons,
  createArrowIcon,
  getOpenStreetMapLayer,
  getSatelliteLayer,
} from "../utils/leafletHelpers";

interface LiveTrackingProps {
  safes: Safe[];
}

interface SafeLocationData {
  safeId: string;
  serialNumber: string;
  deviceId: string | null;
  location?: {
    lat: number;
    lng: number;
    accuracy: number;
    timestamp: number;
    speed?: number;
    course?: number;
    isGPS?: boolean;
    positionTime?: string;
  };
  status: "online" | "offline" | "no_tracker" | "error";
  error?: string;
  lastUpdate: Date;
}

export function LiveTracking({ safes }: LiveTrackingProps) {
  const [locations, setLocations] = useState<SafeLocationData[]>([]);
  const [loading, setLoading] = useState(false);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  const [mapView, setMapView] = useState<"roadmap" | "satellite">("roadmap");
  const [autoRefresh, setAutoRefresh] = useState(true);
  const mapRef = useRef<HTMLDivElement>(null);
  const leafletMapRef = useRef<L.Map | null>(null);
  const markersRef = useRef<L.Marker[]>([]);
  const [mapsLoaded, setMapsLoaded] = useState(false);

  // Initialize Leaflet map
  const initializeMap = () => {
    if (!mapRef.current || leafletMapRef.current) return;

    try {
      // Fix Leaflet icons
      fixLeafletIcons();

      // Create map centered on Johannesburg
      const map = L.map(mapRef.current, {
        center: [-26.2041, 28.0473],
        zoom: 8,
        zoomControl: true,
      });

      // Add tile layer based on view type
      if (mapView === "satellite") {
        getSatelliteLayer().addTo(map);
      } else {
        getOpenStreetMapLayer().addTo(map);
      }

      leafletMapRef.current = map;
      setMapsLoaded(true);
    } catch (error) {
      console.error("Error initializing Leaflet Map:", error);
    }
  };

  // Update map markers
  const updateMapMarkers = () => {
    if (!leafletMapRef.current || !mapsLoaded) {
      return;
    }

    try {
      // Clear existing markers
      markersRef.current.forEach((marker) => marker.remove());
      markersRef.current = [];

      const bounds: L.LatLngBoundsExpression = [];
      let hasValidLocations = false;

      // Create new markers
      for (const safeLocation of locations) {
        if (!safeLocation.location) continue;

        const position: L.LatLngExpression = [
          safeLocation.location.lat,
          safeLocation.location.lng,
        ];

        // Choose icon based on status and movement
        const color = safeLocation.status === "online" ? "#10B981" : "#EF4444";
        const icon =
          safeLocation.location.speed && safeLocation.location.speed > 5
            ? createArrowIcon(color, safeLocation.location.course || 0)
            : L.divIcon({
                className: "custom-marker",
                html: `<div style="
                background-color: ${color};
                width: 20px;
                height: 20px;
                border-radius: 50%;
                border: 3px solid white;
                box-shadow: 0 2px 5px rgba(0,0,0,0.3);
              "></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10],
              });

        const marker = L.marker(position, { icon }).addTo(
          leafletMapRef.current!
        );

        // Create popup
        const popupContent = `
        <div style="padding: 8px; min-width: 200px;">
          <h3 style="margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">
            Safe ${safeLocation.serialNumber}
          </h3>
          <div style="font-size: 14px; line-height: 1.4;">
            <p style="margin: 4px 0;"><strong>Status:</strong> ${getStatusLabel(
              safeLocation.status
            )}</p>
            <p style="margin: 4px 0;"><strong>Location:</strong> ${position[0].toFixed(
              6
            )}, ${position[1].toFixed(6)}</p>
            <p style="margin: 4px 0;"><strong>Accuracy:</strong> ±${
              safeLocation.location.accuracy
            }m</p>
            <p style="margin: 4px 0;"><strong>Updated:</strong> ${formatDistanceToNow(
              safeLocation.lastUpdate
            )} ago</p>
            ${
              safeLocation.location.speed
                ? `<p style="margin: 4px 0;"><strong>Speed:</strong> ${safeLocation.location.speed} km/h</p>`
                : ""
            }
          </div>
        </div>
      `;

        marker.bindPopup(popupContent);
        markersRef.current.push(marker);
        bounds.push(position);
        hasValidLocations = true;
      }

      // Fit bounds to show all markers
      if (hasValidLocations && bounds.length > 0) {
        leafletMapRef.current.fitBounds(bounds, { padding: [50, 50] });
      }

      // orce map redraw
      if (leafletMapRef.current) {
        leafletMapRef.current.invalidateSize();
      }
    } catch (error) {
      console.error("Error updating markers:", error);
    }
  };

  // Switch map layer when view changes
  useEffect(() => {
    if (leafletMapRef.current) {
      // Remove all tile layers
      leafletMapRef.current.eachLayer((layer) => {
        if (layer instanceof L.TileLayer) {
          leafletMapRef.current!.removeLayer(layer);
        }
      });

      // Add new tile layer
      if (mapView === "satellite") {
        getSatelliteLayer().addTo(leafletMapRef.current);
      } else {
        getOpenStreetMapLayer().addTo(leafletMapRef.current);
      }
    }
  }, [mapView]);

  // Initialize map on mount
  useEffect(() => {
    initializeMap();

    return () => {
      if (leafletMapRef.current) {
        leafletMapRef.current.remove();
        leafletMapRef.current = null;
      }
    };
  }, []);

  // Update markers when locations change
  useEffect(() => {
    if (mapsLoaded) {
      updateMapMarkers();
    }
  }, [locations, mapsLoaded]);

  // Get trackable safes
  const trackableSafes = safes.filter(
    (safe) => safe.tracknetics_device_id || safe.tracking_device_id
  );

  const updateLocations = async () => {
    if (trackableSafes.length === 0) return;

    setLoading(true);
    const newLocations: SafeLocationData[] = [];

    for (const safe of trackableSafes) {
      const deviceId = safe.tracknetics_device_id || safe.tracking_device_id;

      const safeLocation: SafeLocationData = {
        safeId: safe.id,
        serialNumber: safe.serial_number,
        deviceId: deviceId || null,
        status: "offline",
        lastUpdate: new Date(),
      };

      if (deviceId) {
        try {
          const result = await trackneticsService.getLocationByDeviceId(
            deviceId
          );

          if (result.success && result.location) {
            safeLocation.location = {
              lat: result.location.lat,
              lng: result.location.lng,
              accuracy: result.location.accuracy,
              timestamp: result.location.timestamp,
            };
            safeLocation.status = "online";
          } else {
            safeLocation.status = "offline";
            safeLocation.error = result.error || "No location data";
          }
        } catch (error: any) {
          safeLocation.status = "error";
          safeLocation.error = error.message || "Failed to get location";
          console.error(
            `Error getting location for ${safe.serial_number}:`,
            error
          );
        }
      } else {
        safeLocation.status = "no_tracker";
        safeLocation.error = "No tracking device assigned";
      }

      newLocations.push(safeLocation);
    }

    setLocations([...newLocations]);
    setLastUpdate(new Date());
    setLoading(false);
  };

  // Auto-refresh every 30 seconds
  useEffect(() => {
    updateLocations();

    if (autoRefresh) {
      const interval = setInterval(updateLocations, 30000);
      return () => clearInterval(interval);
    }
  }, [safes, autoRefresh]);

  const getStatusColor = (status: SafeLocationData["status"]) => {
    switch (status) {
      case "online":
        return "text-green-600 bg-green-100";
      case "offline":
        return "text-red-600 bg-red-100";
      case "no_tracker":
        return "text-gray-600 bg-gray-100";
      case "error":
        return "text-orange-600 bg-orange-100";
      default:
        return "text-gray-600 bg-gray-100";
    }
  };

  const getStatusLabel = (status: SafeLocationData["status"]) => {
    switch (status) {
      case "online":
        return "Online";
      case "offline":
        return "Offline";
      case "no_tracker":
        return "No Tracker";
      case "error":
        return "Error";
      default:
        return "Unknown";
    }
  };

  if (trackableSafes.length === 0) {
    return (
      <div className="card text-center py-12">
        <MapPin className="h-12 w-12 text-gray-400 mx-auto mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">
          No Trackable Safes
        </h3>
        <p className="text-gray-500 mb-4">
          No safes have tracking devices assigned.
        </p>
        <p className="text-sm text-gray-400">
          Add a tracking device ID to safes in the database to enable live
          tracking.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Controls */}
      <div className="card">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-lg font-medium text-gray-900">
              Live GPS Tracking
            </h3>
            <p className="text-sm text-gray-500">
              {lastUpdate && `Last updated: ${lastUpdate.toLocaleTimeString()}`}
            </p>
          </div>

          <div className="flex items-center space-x-3">
            {/* Auto-refresh toggle */}
            <label className="flex items-center space-x-2 text-sm">
              <input
                type="checkbox"
                checked={autoRefresh}
                onChange={(e) =>
                  setAutoRefresh((e.target as HTMLInputElement).checked)
                }
                className="rounded"
              />
              <span>Auto-refresh</span>
            </label>

            {/* Map view toggle */}
            <div className="flex rounded-lg border border-gray-300">
              <button
                onClick={() => setMapView("roadmap")}
                className={`px-3 py-1 text-sm rounded-l-lg ${
                  mapView === "roadmap"
                    ? "bg-blue-600 text-white"
                    : "bg-white text-gray-700 hover:bg-gray-50"
                }`}
              >
                <Navigation className="h-4 w-4" />
              </button>
              <button
                onClick={() => setMapView("satellite")}
                className={`px-3 py-1 text-sm rounded-r-lg ${
                  mapView === "satellite"
                    ? "bg-blue-600 text-white"
                    : "bg-white text-gray-700 hover:bg-gray-50"
                }`}
              >
                <Satellite className="h-4 w-4" />
              </button>
            </div>

            {/* Manual refresh */}
            <button
              onClick={updateLocations}
              disabled={loading}
              className="btn btn-secondary"
            >
              {loading ? (
                <LoadingSpinner size="small" className="mr-2" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Refresh
            </button>
          </div>
        </div>
      </div>

      {/* Leaflet Map */}
      <div className="card">
        <div className="h-96 rounded-lg overflow-hidden bg-gray-200">
          {!mapsLoaded && (
            <div className="w-full h-full flex items-center justify-center">
              <div className="text-center">
                <LoadingSpinner size="large" />
                <p className="mt-4 text-gray-600">Loading map...</p>
              </div>
            </div>
          )}
          <div
            ref={mapRef}
            className="w-full h-full"
            style={{ minHeight: "384px" }}
          />
        </div>

        {/* Map Legend */}
        <div className="mt-4 flex items-center justify-between">
          <div className="flex items-center space-x-4 text-sm">
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 rounded-full bg-green-500"></div>
              <span>Online</span>
            </div>
            <div className="flex items-center space-x-2">
              <div className="w-3 h-3 rounded-full bg-red-500"></div>
              <span>Offline</span>
            </div>
          </div>

          <div className="text-xs text-gray-500">
            Click markers for details •{" "}
            {locations.filter((l) => l.location).length} of {locations.length}{" "}
            safes located
          </div>
        </div>
      </div>

      {/* Location Status Cards - keeping your existing cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {locations.map((safeLocation) => {
          const safe = safes.find((s) => s.id === safeLocation.safeId);

          return (
            <div key={safeLocation.safeId} className="card">
              <div className="flex items-center justify-between mb-4">
                <div className="flex items-center space-x-3">
                  <div
                    className={`p-2 rounded-lg ${
                      safeLocation.status === "online"
                        ? "bg-green-100"
                        : "bg-gray-100"
                    }`}
                  >
                    <MapPin
                      className={`h-5 w-5 ${
                        safeLocation.status === "online"
                          ? "text-green-600"
                          : "text-gray-400"
                      }`}
                    />
                  </div>
                  <div>
                    <h4 className="font-medium text-gray-900">
                      Safe {safeLocation.serialNumber}
                    </h4>
                    <p className="text-sm text-gray-500">
                      Device: {safeLocation.deviceId || "None"}
                    </p>
                  </div>
                </div>

                <span
                  className={`inline-flex items-center px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(
                    safeLocation.status
                  )}`}
                >
                  {getStatusLabel(safeLocation.status)}
                </span>
              </div>

              {safeLocation.location ? (
                <div className="space-y-3">
                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <p className="text-gray-500">Latitude</p>
                      <p className="font-mono text-gray-900">
                        {safeLocation.location.lat.toFixed(6)}
                      </p>
                    </div>
                    <div>
                      <p className="text-gray-500">Longitude</p>
                      <p className="font-mono text-gray-900">
                        {safeLocation.location.lng.toFixed(6)}
                      </p>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-4 text-sm">
                    <div>
                      <p className="text-gray-500">Accuracy</p>
                      <p className="text-gray-900">
                        ±{safeLocation.location.accuracy}m
                        {safeLocation.location.isGPS && (
                          <span className="ml-1 text-green-600 text-xs">
                            GPS
                          </span>
                        )}
                      </p>
                    </div>
                    <div>
                      <p className="text-gray-500">Updated</p>
                      <p className="text-gray-900 text-xs">
                        {formatDistanceToNow(safeLocation.lastUpdate)} ago
                      </p>
                    </div>
                  </div>

                  {/* Safe Status Integration */}
                  {safe && (
                    <div className="pt-3 border-t border-gray-200">
                      <div className="flex items-center justify-between text-sm">
                        <div className="flex items-center space-x-4">
                          <div className="flex items-center space-x-1">
                            <Battery className="h-3 w-3 text-gray-400" />
                            <span
                              className={`text-xs ${
                                safe.battery_level > 50
                                  ? "text-green-600"
                                  : safe.battery_level > 20
                                  ? "text-yellow-600"
                                  : "text-red-600"
                              }`}
                            >
                              {safe.battery_level}%
                            </span>
                          </div>
                          <div className="flex items-center space-x-1">
                            <div
                              className={`w-2 h-2 rounded-full ${
                                safe.status === "active"
                                  ? "bg-green-500"
                                  : "bg-gray-400"
                              }`}
                            />
                            <span className="text-xs text-gray-600 capitalize">
                              {safe.status}
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                <div className="text-center py-4">
                  <AlertTriangle className="h-8 w-8 text-gray-400 mx-auto mb-2" />
                  <p className="text-gray-500 text-sm">
                    {safeLocation.error || "No location data available"}
                  </p>
                  {safeLocation.status === "no_tracker" && (
                    <p className="text-xs text-gray-400 mt-1">
                      Add tracking device ID to database
                    </p>
                  )}
                </div>
              )}
            </div>
          );
        })}
      </div>

      {/* System Status */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h4 className="font-medium text-blue-800 mb-2">System Status:</h4>
        <ul className="text-sm text-blue-700 space-y-1">
          <li>
            Real-time tracking:{" "}
            {autoRefresh ? "Active (30s intervals)" : "Manual only"}
          </li>
          <li>Open source mapping with Leaflet</li>
        </ul>
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/app.tsx">
import { useEffect, useMemo } from "preact/hooks";
import { authService } from "./services/auth";
import { dataService } from "./services/data";
import { isAuthenticated, isLoading, currentUser } from "./store/auth";
import { LoginPage } from "./components/LoginPage";
import { OwnerDashboard } from "./components/OwnerDashboard";
import { AdminDashboard } from "./components/AdminDashboard";
import { CustomerTrackingPage } from "./components/CustomerTrackingPage";
import { ChangePasswordModal } from "./components/ChangePasswordModal";
import { LoadingSpinner } from "./components/LoadingSpinner";
import { ErrorBoundary } from "./components/ErrorBoundary";
import { ToastContainer } from "./components/Toast";
import { setupNetworkListeners } from "./utils/networkHelpers";

export function App() {
  const authenticated = isAuthenticated.value;
  const loading = isLoading.value;
  const user = currentUser.value;

  const currentPath = useMemo(() => {
    return window.location.pathname;
  }, [window.location.pathname]);

  const trackingToken = useMemo(() => {
    const match = currentPath.match(/^\/track\/([^\/]+)$/);
    return match ? match[1] : null;
  }, [currentPath]);

  useEffect(() => {
    // Setup network listeners
    setupNetworkListeners();

    // Initialize auth
    authService.initialize();
  }, []);

  useEffect(() => {
    if (authenticated && user) {
      dataService.loadUserData();
      dataService.setupRealtimeSubscriptions();
    }

    return () => {
      if (authenticated) {
        dataService.cleanup();
      }
    };
  }, [authenticated, user]);

  if (trackingToken) {
    return (
      <ErrorBoundary>
        <ToastContainer />
        <CustomerTrackingPage trackingToken={trackingToken} />
      </ErrorBoundary>
    );
  }

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <LoadingSpinner size="large" />
      </div>
    );
  }

  if (!authenticated) {
    return (
      <ErrorBoundary>
        <ToastContainer />
        <LoginPage />
      </ErrorBoundary>
    );
  }

  return (
    <ErrorBoundary>
      <ToastContainer />
      {user?.must_change_password && <ChangePasswordModal />}
      {user?.role === "owner" ? <OwnerDashboard /> : <AdminDashboard />}
    </ErrorBoundary>
  );
}

export default App;
</file>

<file path="frontend/src/components/CustomerTrackingPage.tsx">
import { useState, useEffect, useRef } from "preact/hooks";
import {
  Shield,
  // MapPin,
  // Clock,
  Package,
  // CheckCircle,
  AlertCircle,
  // Navigation,
  RefreshCw,
} from "lucide-preact";
import { dataService } from "../services/data";
import { trackneticsService } from "../services/tracknetics";
import { LoadingSpinner } from "./LoadingSpinner";
import { format } from "date-fns";
import L from "leaflet";
import {
  fixLeafletIcons,
  createArrowIcon,
  getOpenStreetMapLayer,
} from "../utils/leafletHelpers";

interface CustomerTrackingPageProps {
  trackingToken: string;
}

interface TripTrackingData {
  id: string;
  client_name: string;
  pickup_address: string;
  delivery_address: string;
  status: string;
  scheduled_pickup: string;
  scheduled_delivery: string;
  actual_pickup_time?: string;
  actual_delivery_time?: string;
  priority?: string;
  special_instructions?: string;
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
  safes: {
    id: string;
    serial_number: string;
    status: string;
    battery_level: number;
    last_update: string;
    tracknetics_device_id?: string;
    tracking_device_id?: string;
  };
}

interface SafeLocationData {
  location?: {
    lat: number;
    lng: number;
    accuracy: number;
    timestamp: number;
    speed?: number;
  };
  status: "online" | "offline" | "no_tracker" | "error";
  error?: string;
  lastUpdate: Date;
}

export function CustomerTrackingPage({
  trackingToken,
}: CustomerTrackingPageProps) {
  const [trip, setTrip] = useState<TripTrackingData | null>(null);
  const [safeLocation, setSafeLocation] = useState<SafeLocationData>({
    status: "offline",
    lastUpdate: new Date(),
  });
  const [loading, setLoading] = useState(true);
  const [locationLoading, setLocationLoading] = useState(false);
  const [error, setError] = useState("");
  const [, setLastUpdate] = useState<Date>(new Date());
  const [autoRefresh] = useState(true);

  // Map refs
  const mapRef = useRef<HTMLDivElement>(null);
  const leafletMapRef = useRef<L.Map | null>(null);
  const safeMarkerRef = useRef<L.Marker | null>(null);
  const [mapsLoaded, setMapsLoaded] = useState(false);
  const [mapsError, setMapsError] = useState<string>("");

  // Load trip data
  const loadTripData = async (showLoading = true) => {
    if (showLoading) setLoading(true);
    setError("");

    try {
      const result = await dataService.getTripByTrackingToken(trackingToken);

      if (result.success && result.trip) {
        setTrip(result.trip as unknown as TripTrackingData);
        setLastUpdate(new Date());
      } else {
        setError(
          result.error || "Secure transport not found or tracking not enabled"
        );
      }
    } catch (err) {
      setError("Unable to load tracking information. Please try again.");
    } finally {
      if (showLoading) setLoading(false);
    }
  };

  // Initialize map
  const initializeMap = () => {
    if (!mapRef.current || leafletMapRef.current || mapsError) return;

    try {
      fixLeafletIcons();

      // Wait for DOM to fully render
      setTimeout(() => {
        if (!mapRef.current) return;

        const map = L.map(mapRef.current, {
          center: [-26.2041, 28.0473],
          zoom: 13,
          zoomControl: true,
          scrollWheelZoom: true,
        });

        getOpenStreetMapLayer().addTo(map);

        leafletMapRef.current = map;

        // Force size recalculation
        setTimeout(() => {
          if (leafletMapRef.current) {
            leafletMapRef.current.invalidateSize();
          }
        }, 250);

        setMapsLoaded(true);
        // Update marker if location exists
        if (safeLocation.location) {
          setTimeout(() => updateSafeMarker(), 500);
        }
      }, 100);
    } catch (error) {
      console.error("Error initializing customer map:", error);
      setMapsError("Failed to initialize map");
    }
  };

  // Update safe location
  const updateSafeLocation = async () => {
    if (!trip?.safes) return;

    const deviceId =
      trip.safes.tracknetics_device_id || trip.safes.tracking_device_id;
    if (!deviceId) {
      setSafeLocation({
        status: "no_tracker",
        error: "No tracking device available",
        lastUpdate: new Date(),
      });
      return;
    }

    setLocationLoading(true);

    try {
      const locationPromise =
        trackneticsService.getLocationByDeviceId(deviceId);
      const timeoutPromise = new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error("Location timeout")), 10000)
      );

      const result = await Promise.race([
        locationPromise,
        timeoutPromise,
      ]).catch((err): { success: false; error: string } => {
        console.warn("Location fetch timeout:", err);
        return { success: false, error: "Location request timed out" };
      });

      if (result.success && result.location) {
        const newLocation: SafeLocationData = {
          location: result.location,
          status: "online",
          lastUpdate: new Date(),
        };
        setSafeLocation(newLocation);
      } else {
        setSafeLocation({
          status: "offline",
          error: result.error || "No current location",
          lastUpdate: new Date(),
        });
      }
    } catch (error: any) {
      setSafeLocation({
        status: "error",
        error: error.message || "Failed to get location",
        lastUpdate: new Date(),
      });
    } finally {
      setLocationLoading(false);
    }
  };

  // Update safe marker on map
  const updateSafeMarker = () => {
    if (!leafletMapRef.current) {
      return;
    }

    if (!safeLocation.location) {
      return;
    }

    const position: L.LatLngExpression = [
      safeLocation.location.lat,
      safeLocation.location.lng,
    ];

    try {
      if (!safeMarkerRef.current) {
        // Create safe marker
        const icon =
          safeLocation.location.speed && safeLocation.location.speed > 5
            ? createArrowIcon("#8B5CF6", 0)
            : L.divIcon({
                className: "custom-transport-marker",
                html: `<div style="
                background-color: #8B5CF6;
                width: 28px;
                height: 28px;
                border-radius: 50%;
                border: 4px solid white;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
              "></div>`,
                iconSize: [28, 28],
                iconAnchor: [14, 14],
              });

        safeMarkerRef.current = L.marker(position, { icon }).addTo(
          leafletMapRef.current
        );

        // Safe info window
        const popupContent = `
          <div style="padding: 8px;">
            <h3 style="margin: 0 0 8px 0; color: #8B5CF6;">🚚 Your Secure Transport</h3>
            <div style="font-size: 12px;">
              <p style="margin: 2px 0;"><strong>Status:</strong> ${
                safeLocation.status
              }</p>
              <p style="margin: 2px 0;"><strong>Location:</strong> ${position[0].toFixed(
                6
              )}, ${position[1].toFixed(6)}</p>
              <p style="margin: 2px 0;"><strong>Accuracy:</strong> ±${
                safeLocation.location.accuracy
              }m</p>
              ${
                safeLocation.location.speed
                  ? `<p style="margin: 2px 0;"><strong>Speed:</strong> ${safeLocation.location.speed} km/h</p>`
                  : ""
              }
              <p style="margin: 2px 0;"><strong>Last Update:</strong> Just now</p>
            </div>
          </div>
        `;

        safeMarkerRef.current.bindPopup(popupContent);

        // Center map on safe location
        leafletMapRef.current.setView(position, 15);
      } else {
        // Update existing marker position
        safeMarkerRef.current.setLatLng(position);
        leafletMapRef.current.setView(
          position,
          leafletMapRef.current.getZoom()
        );
      }
    } catch (error) {
      console.error("Error updating safe marker:", error);
    }
  };

  // Initialize everything
  useEffect(() => {
    loadTripData();
    initializeMap();

    return () => {
      if (leafletMapRef.current) {
        leafletMapRef.current.remove();
        leafletMapRef.current = null;
      }
    };
  }, [trackingToken]);

  // Update safe marker when location changes
  useEffect(() => {
    if (mapsLoaded && safeLocation.location && !mapsError) {
      updateSafeMarker();
    }
  }, [safeLocation, mapsLoaded, mapsError]);

  // Auto-refresh logic
  useEffect(() => {
    if (trip) {
      updateSafeLocation(); // Initial load

      if (autoRefresh && trip.status === "in_transit") {
        const interval = setInterval(() => {
          loadTripData(false); // Refresh trip data
          updateSafeLocation(); // Refresh location
        }, 30000);
        return () => clearInterval(interval);
      }
    }
  }, [trip, autoRefresh]);

  // Helper functions
  /*   const getStatusInfo = (status: string) => {
    switch (status) {
      case "pending":
        return {
          color: "bg-blue-100 text-blue-800",
          icon: Clock,
          label: "Secure Transport Scheduled",
          description:
            "Your valuable items are scheduled for secure collection",
        };
      case "in_transit":
        return {
          color: "bg-yellow-100 text-yellow-800",
          icon: Package,
          label: "Secure Transport In Progress",
          description:
            "Your items are in secure transit with live GPS monitoring",
        };
      case "delivered":
        return {
          color: "bg-green-100 text-green-800",
          icon: CheckCircle,
          label: "Secure Delivery Complete",
          description: "Your items have been safely delivered",
        };
      case "cancelled":
        return {
          color: "bg-gray-100 text-gray-800",
          icon: AlertCircle,
          label: "Transport Cancelled",
          description: "This secure transport has been cancelled",
        };
      default:
        return {
          color: "bg-gray-100 text-gray-800",
          icon: Package,
          label: "Status Unknown",
          description: "",
        };
    }
  }; */

  /*   const getPriorityLabel = (priority?: string) => {
    switch (priority) {
      case "urgent":
        return "URGENT";
      case "high":
        return "HIGH PRIORITY";
      default:
        return "STANDARD";
    }
  }; */

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 flex items-center justify-center px-4">
        <div className="text-center">
          <LoadingSpinner size="large" className="mb-4" />
          <p className="text-gray-300">
            Loading secure transport information...
          </p>
        </div>
      </div>
    );
  }

  if (error || !trip) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-900 to-gray-700 flex items-center justify-center px-4">
        <div className="max-w-md w-full text-center">
          <div className="bg-red-100 rounded-full p-3 w-16 h-16 mx-auto mb-4">
            <AlertCircle className="h-10 w-10 text-red-600" />
          </div>
          <h2 className="text-xl font-bold text-white mb-2">
            Access Restricted
          </h2>
          <p className="text-gray-300 mb-6">{error}</p>
        </div>
      </div>
    );
  }

  // const statusInfo = getStatusInfo(trip.status);
  // const StatusIcon = statusInfo.icon;

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      {/* Minimal Header */}
      <div className="bg-white border-b border-gray-200 z-10 shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
          <div className="flex items-center gap-2">
            <div className="bg-brand rounded p-1.5">
              <Shield className="h-5 w-5 text-white" />
            </div>
            <span className="font-medium text-gray-900 tracking-tight">
              Kluys Tracking
            </span>
          </div>
          {trip?.status === "in_transit" && (
            <div className="badge badge-brand animate-pulse">
              <span className="w-1.5 h-1.5 rounded-full bg-brand mr-1.5"></span>
              Live
            </div>
          )}
        </div>
      </div>

      {/* Split Layout */}
      <div className="flex-1 flex flex-col lg:flex-row relative">
        {/* Map Container - Takes dominance */}
        <div className="flex-1 relative min-h-[50vh] bg-gray-100 order-2 lg:order-1">
          <div ref={mapRef} className="absolute inset-0 z-0" />

          {/* Floating Map Controls (Example) */}
          <div className="absolute bottom-6 right-6 z-10 flex flex-col gap-2">
            <button
              onClick={updateSafeLocation}
              className="bg-white p-2.5 rounded-md shadow-lg border border-gray-200 text-gray-600 hover:text-brand transition-colors"
            >
              <RefreshCw
                className={`h-5 w-5 ${locationLoading ? "animate-spin" : ""}`}
              />
            </button>
          </div>
        </div>

        {/* Status Sidebar / Bottom Sheet */}
        <div className="bg-white border-t lg:border-t-0 lg:border-l border-gray-200 w-full lg:w-96 p-6 z-10 shadow-lg flex flex-col gap-6 order-1 lg:order-2 overflow-y-auto max-h-[50vh] lg:max-h-screen">
          {/* Status Timeline */}
          <div>
            <h2 className="text-sm font-medium text-gray-500 uppercase tracking-wider mb-4">
              Transport Status
            </h2>
            <div className="flex items-center gap-3 mb-2">
              <div
                className={`p-2 rounded-full ${
                  trip?.status === "in_transit"
                    ? "bg-brand-light text-brand"
                    : "bg-gray-100 text-gray-500"
                }`}
              >
                <Package className="h-6 w-6" />
              </div>
              <div>
                <h3 className="text-lg font-medium text-gray-900 capitalize">
                  {trip?.status.replace("_", " ")}
                </h3>
                <p className="text-sm text-gray-500">
                  {trip?.status === "in_transit"
                    ? "Arriving shortly"
                    : "Scheduled"}
                </p>
              </div>
            </div>
          </div>

          <hr className="border-gray-100" />

          {/* Locations */}
          <div className="relative pl-4 border-l-2 border-gray-100 space-y-8 my-2">
            <div className="relative">
              <div className="absolute -left-[21px] top-1 h-3 w-3 rounded-full border-2 border-white bg-gray-400 ring-1 ring-gray-200"></div>
              <p className="text-xs text-gray-500 mb-1">From</p>
              <p className="text-sm font-medium text-gray-900">
                {trip?.pickup_address}
              </p>
              <p className="text-xs text-gray-400 mt-0.5">
                {format(new Date(trip?.scheduled_pickup || ""), "MMM d, HH:mm")}
              </p>
            </div>
            <div className="relative">
              <div className="absolute -left-[21px] top-1 h-3 w-3 rounded-full border-2 border-white bg-brand ring-1 ring-brand/30"></div>
              <p className="text-xs text-gray-500 mb-1">To</p>
              <p className="text-sm font-medium text-gray-900">
                {trip?.delivery_address}
              </p>
              <p className="text-xs text-gray-400 mt-0.5">
                {format(
                  new Date(trip?.scheduled_delivery || ""),
                  "MMM d, HH:mm"
                )}
              </p>
            </div>
          </div>

          {trip?.special_instructions && (
            <div className="bg-gray-50 rounded-md p-3 border border-gray-200 mt-auto">
              <div className="flex items-center gap-2 text-gray-900 font-medium text-sm mb-1">
                <Shield className="h-3 w-3" /> Security Note
              </div>
              <p className="text-xs text-gray-600">
                {trip.special_instructions}
              </p>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="mobile/src/services/otp.ts">
import { supabase } from "./supabase";
import { mobileAuthService } from "./auth";

interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}

class OTPService {
  private lastOTPRequest: number = 0;
  private readonly MIN_REQUEST_INTERVAL = 30000; // 30 seconds

  async requestOTP(
    tripId: string,
    location: { latitude: number; longitude: number; accuracy: number }
  ): Promise<OTPResponse> {
    try {
      const now = Date.now();
      if (now - this.lastOTPRequest < this.MIN_REQUEST_INTERVAL) {
        const waitTime = Math.ceil(
          (this.MIN_REQUEST_INTERVAL - (now - this.lastOTPRequest)) / 1000
        );
        return {
          success: false,
          error: `Please wait ${waitTime} seconds before requesting another code`,
        };
      }

      console.log("Requesting OTP for trip:", tripId);

      const sessionToken = mobileAuthService.getSessionToken();

      console.log("Session token retrieved:", sessionToken ? "YES" : "NO");

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke("mobile-otp", {
        body: {
          session_token: sessionToken, // Pass in body instead of header
          action: "request_otp",
          trip_id: tripId,
          location: location,
        },
      });

      console.log("Edge function response:", data);
      console.log("Edge function error:", error);

      if (error) {
        console.error("OTP request error:", error);
        return {
          success: false,
          error: error.message || "Failed to request OTP",
        };
      }

      if (!data.success) {
        console.error("OTP request failed:", data.error);
        return { success: false, error: data.error || "Failed to request OTP" };
      }

      this.lastOTPRequest = now;

      console.log("OTP request completed successfully");
      return {
        success: true,
        expires_at: data.expires_at,
      };
    } catch (err: any) {
      console.error("OTP request exception:", err);
      return {
        success: false,
        error: `Failed to request OTP: ${err.message}`,
      };
    }
  }

  async verifyOTP(
    tripId: string,
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      console.log("Verifying OTP for trip:", tripId);

      if (!/^\d{6}$/.test(otpCode)) {
        return { success: false, error: "Invalid OTP format" };
      }

      const sessionToken = mobileAuthService.getSessionToken();

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke("mobile-otp", {
        body: {
          session_token: sessionToken, // Pass in body instead of header
          action: "verify_otp",
          trip_id: tripId,
          otp_code: otpCode,
        },
      });

      if (error) {
        console.error("OTP verification error:", error);
        return {
          success: false,
          error: error.message || "Failed to verify OTP",
        };
      }

      if (!data.success) {
        console.error("OTP verification failed:", data.error);
        return {
          success: false,
          error: data.error || "Invalid or expired OTP code",
        };
      }

      console.log("OTP verified successfully");
      return { success: true };
    } catch (err: any) {
      console.error("OTP verification exception:", err);
      return { success: false, error: `Verification failed: ${err.message}` };
    }
  }

  async cleanupExpiredOTPs() {
    try {
      const { error } = await supabase
        .from("trip_otps")
        .delete()
        .lt("expires_at", new Date().toISOString());

      if (error) {
        console.error("OTP cleanup error:", error);
      } else {
        console.log("Expired OTPs cleaned up");
      }
    } catch (err) {
      console.error("OTP cleanup exception:", err);
    }
  }
}

export const otpService = new OTPService();
</file>

<file path="frontend/src/types/index.ts">
export type UserRole = "owner" | "admin";

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  created_by?: string;
  must_change_password: boolean;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

export interface MobileUser {
  id: string;
  safe_id: string;
  username: string;
  driver_name?: string;
  is_active: boolean;
  created_by: string;
  created_at: string;
  updated_at: string;
}

export interface Safe {
  id: string;
  serial_number: string;
  device_hash: string;
  status: SafeStatus;
  battery_level: number;
  is_locked: boolean;
  tracking_device_id?: string;
  tracknetics_device_id?: string; // Add this line
  assigned_to: string;
  last_update?: string;
  created_at: string;
  mobile_users?: MobileUser[];
}

export type SafeStatus = "active" | "inactive" | "maintenance" | "offline";

// Updated Trip interface with new optional fields
export interface Trip {
  trip: any;
  id: string;
  safe_id: string;
  client_name: string;
  client_phone?: string;
  client_email?: string;
  pickup_address: string;
  pickup_contact_name?: string;
  pickup_contact_phone?: string;
  delivery_address: string;
  delivery_contact_name?: string;
  delivery_contact_phone?: string;
  recipient_name?: string;
  recipient_email?: string;
  recipient_phone?: string;
  recipient_is_client?: boolean;
  status: TripStatus;
  scheduled_pickup: string;
  scheduled_delivery: string;
  priority?: TripPriority;
  special_instructions?: string;
  delivery_notes?: string;
  requires_signature?: boolean;
  recurring_config?: {
    frequency: "daily" | "weekly" | "monthly";
    end_date?: string;
    days_of_week?: number[];
  };
  recurring_parent_id?: string;
  actual_pickup_time?: string;
  actual_delivery_time?: string;
  cancellation_reason?: string;
  cancelled_at?: string;
  tracking_token?: string;
  customer_tracking_enabled?: boolean;
  created_by: string;
  created_at: string;
  updated_at: string;
}

export type TripStatus = "pending" | "in_transit" | "delivered" | "cancelled";
export type TripPriority = "low" | "normal" | "high" | "urgent";

export interface AuthState {
  user: User | null;
  loading: boolean;
  isAuthenticated: boolean;
}
</file>

<file path="mobile/src/screens/DeliveryScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  ArrowLeft,
  // MapPin,
  Navigation,
  Key,
  CheckCircle,
  AlertCircle,
  Mail,
  // Phone,
} from "lucide-preact";
import { tripsService } from "../services/trips";
import { otpService } from "../services/otp";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { bluetoothService } from "../services/bluetooth";
import { geolocationService } from "../services/geolocation";

interface DeliveryScreenProps {
  trip: any;
  onBack: () => void;
}

export function DeliveryScreen({ trip, onBack }: DeliveryScreenProps) {
  // Steps: travel -> otp_req -> otp_enter -> unlocking -> success
  const [step, setStep] = useState<
    "travel" | "otp_req" | "otp_enter" | "unlocking" | "success"
  >("travel");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [otpCode, setOtpCode] = useState("");

  // Restore state from LocalStorage on mount
  useEffect(() => {
    const saved = localStorage.getItem(`trip_state_${trip.id}`);
    if (saved) setStep(saved as any);
  }, [trip.id]);

  // Save state on change
  useEffect(() => {
    if (step === "success") localStorage.removeItem(`trip_state_${trip.id}`);
    else localStorage.setItem(`trip_state_${trip.id}`, step);
  }, [step, trip.id]);

  // --- Actions ---

  const handleArrived = async () => {
    setLoading(true);
    setError("");
    try {
      // 1. Get Location
      const locResult = await geolocationService.getCurrentPosition();
      if (!locResult.success) throw new Error(locResult.error);

      // 2. Notify Backend (Optional, logic usually handled in OTP req)
      setStep("otp_req");
    } catch (err: any) {
      setError(err.message || "Failed to verify location.");
    } finally {
      setLoading(false);
    }
  };

  const handleRequestOTP = async () => {
    setLoading(true);
    setError("");
    try {
      const locResult = await geolocationService.getCurrentPosition();
      if (!locResult.success || !locResult.location)
        throw new Error("Location required for OTP.");

      const result = await otpService.requestOTP(trip.id, locResult.location);
      if (result.success) {
        setStep("otp_enter");
      } else {
        throw new Error(result.error);
      }
    } catch (err: any) {
      setError(err.message || "OTP Request failed.");
    } finally {
      setLoading(false);
    }
  };

  const handleUnlock = async () => {
    if (otpCode.length !== 6) return setError("Enter 6-digit code.");

    setLoading(true);
    setError("");

    try {
      // 1. Verify OTP with Backend
      const verifyResult = await otpService.verifyOTP(trip.id, otpCode);
      if (!verifyResult.success) throw new Error(verifyResult.error);

      // 2. Connect Bluetooth (if not already)
      if (!bluetoothService.isConnectedToPi()) {
        await bluetoothService.initialize();
        const scan = await bluetoothService.scanForPi();
        if (!scan.success) throw new Error("Safe not found. Move closer.");
        const conn = await bluetoothService.connectToPi();
        if (!conn.success) throw new Error("Bluetooth connection failed.");
      }

      // 3. Send Unlock Command
      setStep("unlocking");
      const btResult = await bluetoothService.sendOTPToPi(otpCode);
      if (!btResult.success) throw new Error(btResult.error);

      // 4. Complete Trip in Backend
      const completeResult = await tripsService.completeTrip(trip.id);
      if (!completeResult.success) throw new Error(completeResult.error);

      setStep("success");
    } catch (err: any) {
      setError(err.message || "Unlock process failed.");
      setStep("otp_enter"); // Go back to allow retry
    } finally {
      setLoading(false);
    }
  };

  // --- Renders ---

  return (
    <div className="min-h-screen bg-white flex flex-col pb-safe">
      {/* Nav */}
      <div className="px-4 py-4 pt-5 border-b border-gray-100 flex items-center bg-white sticky top-0 z-10">
        <button
          onClick={onBack}
          className="p-2 -ml-2 text-gray-500 hover:bg-gray-50 rounded-full"
        >
          <ArrowLeft className="h-6 w-6" />
        </button>
        <div className="ml-2 flex-1">
          <h1 className="font-semibold text-gray-900 text-lg">Delivery</h1>
          <p className="text-xs text-gray-500 truncate w-48">
            {trip.delivery_address}
          </p>
        </div>
        <div className="ml-auto">
          <span className="bg-brand/10 text-brand text-xs font-bold px-2 py-1 rounded uppercase">
            {step === "success" ? "Done" : "Active"}
          </span>
        </div>
      </div>

      {/* Error Banner */}
      {error && (
        <div className="mx-4 mt-4 bg-red-50 border border-red-100 p-3 rounded-lg flex items-start gap-3 animate-fade-in">
          <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0 mt-0.5" />
          <p className="text-sm text-red-800">{error}</p>
        </div>
      )}

      {/* Main Body */}
      <div className="flex-1 flex flex-col items-center justify-center p-6 text-center">
        {/* 1. Travel State */}
        {step === "travel" && (
          <div className="w-full max-w-sm animate-fade-in">
            <div className="w-20 h-20 bg-blue-50 text-blue-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Navigation className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">En Route</h2>
            <p className="text-gray-500 mb-8">
              Navigate to the delivery location.
              <br />
              Confirm arrival to proceed.
            </p>

            <div className="bg-gray-50 p-4 rounded-xl border border-gray-100 mb-8 text-left">
              <p className="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-1">
                Destination
              </p>
              <p className="text-gray-900 font-medium">
                {trip.delivery_address}
              </p>
              {trip.delivery_contact_name && (
                <p className="text-sm text-gray-500 mt-1">
                  {trip.delivery_contact_name} • {trip.delivery_contact_phone}
                </p>
              )}
            </div>

            <button
              onClick={handleArrived}
              disabled={loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "I have Arrived"
              )}
            </button>
          </div>
        )}

        {/* 2. Request OTP */}
        {step === "otp_req" && (
          <div className="w-full max-w-sm animate-fade-in">
            <div className="w-20 h-20 bg-orange-50 text-orange-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Mail className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              Authorize Unlock
            </h2>
            <p className="text-gray-500 mb-8">
              Send the secure 6-digit code to the recipient to confirm identity.
            </p>

            <div className="bg-gray-50 p-4 rounded-xl border border-gray-100 mb-8 text-left">
              <p className="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2">
                Recipient
              </p>
              <p className="text-gray-900 font-medium text-lg">
                {trip.recipient_name || trip.client_name}
              </p>
              <p className="text-gray-500 flex items-center gap-2 mt-1">
                <Mail className="h-3 w-3" />{" "}
                {trip.recipient_email || trip.client_email}
              </p>
            </div>

            <button
              onClick={handleRequestOTP}
              disabled={loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "Send OTP Code"
              )}
            </button>
          </div>
        )}

        {/* 3. Enter OTP */}
        {step === "otp_enter" && (
          <div className="w-full max-w-sm animate-fade-in">
            <div className="w-20 h-20 bg-gray-900 text-brand rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Key className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              Enter Code
            </h2>
            <p className="text-gray-500 mb-8">
              Ask the recipient for the 6-digit PIN sent to their email.
            </p>

            <input
              type="text"
              inputMode="numeric"
              pattern="[0-9]*"
              maxLength={6}
              className="w-full text-center text-5xl tracking-[0.2em] font-mono border-b-2 border-gray-200 focus:border-brand outline-none py-4 mb-8 bg-transparent transition-colors"
              placeholder="••••••"
              value={otpCode}
              onInput={(e) => setOtpCode((e.target as HTMLInputElement).value)}
              autoFocus
            />

            <button
              onClick={handleUnlock}
              disabled={otpCode.length !== 6 || loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "Verify & Unlock"
              )}
            </button>

            <button
              onClick={() => setStep("otp_req")}
              className="mt-4 text-sm text-gray-400 underline"
            >
              Resend Code
            </button>
          </div>
        )}

        {/* 4. Unlocking (Transient) */}
        {step === "unlocking" && (
          <div className="w-full max-w-sm animate-fade-in text-center">
            <LoadingSpinner size="large" className="mx-auto mb-6 text-brand" />
            <h2 className="text-xl font-bold text-gray-900">
              Unlocking Safe...
            </h2>
            <p className="text-gray-500 mt-2">Communicating via Bluetooth</p>
          </div>
        )}

        {/* 5. Success */}
        {step === "success" && (
          <div className="w-full max-w-sm animate-fade-in">
            <div className="w-24 h-24 bg-green-50 text-green-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <CheckCircle className="h-12 w-12" />
            </div>
            <h2 className="text-3xl font-bold text-gray-900 mb-2">
              Delivery Done!
            </h2>
            <p className="text-gray-600 mb-8">Safe unlocked. Job closed.</p>

            <button
              onClick={onBack}
              className="w-full btn btn-secondary py-4 text-lg rounded-xl border-gray-300"
            >
              Back to Dashboard
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="frontend/src/services/data.ts">
import { supabase } from "../lib/supabase";
import { dataActions } from "../store/data";
import { currentUser } from "../store/auth";
import { validateTripData } from "../utils/validation";
import { toast } from "../components/Toast";
import { retryRequest } from "../utils/networkHelpers";

import type {
  Safe,
  Trip,
  SafeStatus,
  TripStatus,
  TripPriority,
} from "../types";

// Trip booking data interface
export interface TripBookingData {
  safe_id: string;
  client_name: string;
  client_phone?: string;
  client_email?: string;
  pickup_address: string;
  pickup_contact_name?: string;
  pickup_contact_phone?: string;
  delivery_address: string;
  delivery_contact_name?: string;
  delivery_contact_phone?: string;

  recipient_name?: string;
  recipient_email?: string;
  recipient_phone?: string;
  recipient_is_client?: boolean; // Toggle: "Same as client"

  scheduled_pickup: string;
  scheduled_delivery: string;
  priority?: TripPriority;
  special_instructions?: string;
  delivery_notes?: string;
  requires_signature?: boolean;
  recurring?: {
    enabled: boolean;
    frequency: "daily" | "weekly" | "monthly";
    end_date?: string;
    days_of_week?: number[];
  };
}

export interface TripValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
}

class DataService {
  private safesSubscription: any = null;
  private tripsSubscription: any = null;
  private reconnectionAttempts = 0;
  private maxReconnectionAttempts = 5;

  async loadUserData() {
    const user = currentUser.value;
    if (!user) return;

    dataActions.setLoading(true);

    try {
      // Load data - RLS automatically filters based on user
      await Promise.all([this.loadSafes(), this.loadTrips()]);
    } catch (error) {
      console.error("Failed to load user data:", error);
    } finally {
      dataActions.setLoading(false);
    }
  }

  async loadSafes() {
    try {
      const { data, error } = await retryRequest(
        async () => {
          return await supabase
            .from("safes")
            .select("*")
            .order("created_at", { ascending: false });
        },
        {
          maxRetries: 3,
          delayMs: 1000,
          onRetry: (attempt) => {
            console.log(`Retrying safes load (attempt ${attempt})`);
          },
        }
      );

      if (error) {
        console.error("Failed to load safes:", error);
        toast.error("Failed to load safes");
        return;
      }

      dataActions.setSafes(data || []);
    } catch (error) {
      console.error("Error loading safes:", error);
      toast.error("Unable to load safes. Please refresh.");
    }
  }

  async loadTrips() {
    try {
      const { data, error } = await retryRequest(
        async () => {
          return await supabase
            .from("trips")
            .select("*")
            .order("created_at", { ascending: false });
        },
        {
          maxRetries: 3,
          delayMs: 1000,
          onRetry: (attempt) => {
            console.log(`Retrying trips load (attempt ${attempt})`);
          },
        }
      );

      if (error) {
        console.error("Failed to load trips:", error);
        toast.error("Failed to load trips");
        return;
      }

      dataActions.setTrips(data || []);
    } catch (error) {
      console.error("Error loading trips:", error);
      toast.error("Unable to load trips. Please refresh.");
    }
  }

  async createSafe(safeData: {
    serial_number: string;
    device_hash: string;
    assigned_to: string;
    tracking_device_id?: string;
  }) {
    const { data, error } = await supabase
      .from("safes")
      .insert({
        ...safeData,
        status: "inactive",
        battery_level: 100,
        is_locked: true,
      })
      .select()
      .single();

    if (error) {
      return { success: false, error: error.message };
    }

    // No need to manually update store - real-time will handle it
    return { success: true, safe: data };
  }

  // Trip creation with validation and new fields
  async createTrip(tripData: any) {
    const user = currentUser.value;
    if (!user) {
      return { success: false, error: "User not authenticated" };
    }

    // Server-side validation
    const validation = validateTripData(tripData);
    if (!validation.valid) {
      const errorMessages = Object.values(validation.errors).join(", ");
      return { success: false, error: errorMessages };
    }

    // Use sanitized data
    const sanitizedData = validation.sanitized!;

    // Determine recipient
    const recipientName = sanitizedData.recipient_is_client
      ? sanitizedData.client_name
      : sanitizedData.recipient_name;

    const recipientEmail = sanitizedData.recipient_is_client
      ? sanitizedData.client_email
      : sanitizedData.recipient_email;

    const recipientPhone = sanitizedData.recipient_is_client
      ? sanitizedData.client_phone
      : sanitizedData.recipient_phone;

    const customerTrackingEnabled = !!sanitizedData.client_email;

    const enhancedTripData = {
      ...sanitizedData,
      created_by: user.id,
      status: "pending",
      priority: sanitizedData.priority || "normal",
      requires_signature: sanitizedData.requires_signature || false,
      customer_tracking_enabled: customerTrackingEnabled,
      recipient_name: recipientName,
      recipient_email: recipientEmail,
      recipient_phone: recipientPhone,
      ...(sanitizedData.recurring?.enabled && {
        recurring_config: sanitizedData.recurring,
      }),
    };

    delete enhancedTripData.recurring;

    try {
      const { data, error } = await supabase
        .from("trips")
        .insert(enhancedTripData)
        .select("*, tracking_token")
        .single();

      if (error) {
        console.error("Supabase error:", error);
        toast.error("Failed to create trip. Please try again.");
        return { success: false, error: error.message };
      }

      if (enhancedTripData.client_email) {
        this.sendClientBookingConfirmation(data).catch((err) => {
          console.warn("Email failed (non-blocking):", err);
          toast.warning("Trip created but confirmation email failed to send");
        });
      }

      toast.success("Trip booked successfully!");
      return { success: true, trip: data };
    } catch (err) {
      console.error("Exception creating trip:", err);
      toast.error("Network error. Please check your connection.");
      return {
        success: false,
        error: "Failed to create trip booking. Please try again.",
      };
    }
  }
  // Validate trip data before submission
  validateTripData(
    data: TripBookingData,
    availableSafes: Safe[]
  ): TripValidationResult {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Required field validation
    if (!data.safe_id) errors.push("Safe selection is required");
    if (!data.client_name.trim()) errors.push("Client name is required");
    if (!data.pickup_address.trim()) errors.push("Pickup address is required");
    if (!data.delivery_address.trim())
      errors.push("Delivery address is required");
    if (!data.scheduled_pickup) errors.push("Pickup time is required");
    if (!data.scheduled_delivery) errors.push("Delivery time is required");

    // Safe availability validation
    const selectedSafe = availableSafes.find(
      (safe) => safe.id === data.safe_id
    );
    if (data.safe_id && !selectedSafe) {
      errors.push("Selected safe is not available");
    } else if (selectedSafe) {
      if (selectedSafe.status !== "active") {
        errors.push(`Safe ${selectedSafe.serial_number} is not active`);
      }
      if (selectedSafe.battery_level < 20) {
        warnings.push(
          `Safe ${selectedSafe.serial_number} has low battery (${selectedSafe.battery_level}%)`
        );
      }
    }

    // Time validation
    const now = new Date();
    const pickupTime = new Date(data.scheduled_pickup);
    const deliveryTime = new Date(data.scheduled_delivery);

    if (pickupTime <= now) {
      errors.push("Pickup time must be in the future");
    }

    if (deliveryTime <= pickupTime) {
      errors.push("Delivery time must be after pickup time");
    }

    const timeDiff = deliveryTime.getTime() - pickupTime.getTime();
    const minDuration = 30 * 60 * 1000; // 30 minutes minimum

    if (timeDiff < minDuration) {
      errors.push("Minimum trip duration is 30 minutes");
    }

    // Contact validation
    if (data.client_phone && !this.isValidPhone(data.client_phone)) {
      errors.push("Invalid client phone number");
    }

    if (data.client_email && !this.isValidEmail(data.client_email)) {
      errors.push("Invalid client email address");
    }

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
    };
  }

  // Check for scheduling conflicts
  async checkSchedulingConflicts(
    safeId: string,
    pickupTime: string,
    deliveryTime: string,
    excludeTripId?: string
  ): Promise<any[]> {
    try {
      let query = supabase
        .from("trips")
        .select("id, client_name, scheduled_pickup, scheduled_delivery")
        .eq("safe_id", safeId)
        .in("status", ["pending", "in_transit"]);

      if (excludeTripId) {
        query = query.neq("id", excludeTripId);
      }

      const { data, error } = await query;

      if (error) {
        console.error("Conflict check query error:", error);
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      const newPickup = new Date(pickupTime);
      const newDelivery = new Date(deliveryTime);

      const conflicts = data.filter((trip) => {
        const existingPickup = new Date(trip.scheduled_pickup);
        const existingDelivery = new Date(trip.scheduled_delivery);

        // Check for time overlap
        const hasConflict =
          newPickup < existingDelivery && newDelivery > existingPickup;

        if (hasConflict) {
          console.log("⚠️ Conflict found with trip:", trip.id);
        }

        return hasConflict;
      });

      console.log(
        `Conflict check complete: ${conflicts.length} conflicts found`
      );
      return conflicts;
    } catch (error) {
      console.error("Exception in conflict check:", error);
      // Don't block trip creation on conflict check errors
      return [];
    }
  }

  // Generate customer tracking URL
  // Around line 360
  generateTrackingUrl(trackingToken: string): string {
    // Use environment variable or fallback to window.location
    const baseUrl = import.meta.env.VITE_APP_URL || window.location.origin;
    return `${baseUrl}/track/${trackingToken}`;
  }

  async getTripByTrackingToken(trackingToken: string) {
    try {
      const { data, error } = await supabase
        .from("trips")
        .select(
          `
        id,
        client_name,
        pickup_address,
        delivery_address,
        status,
        scheduled_pickup,
        scheduled_delivery,
        actual_pickup_time,
        actual_delivery_time,
        priority,
        special_instructions,
        requires_signature,
        created_at,
        updated_at,
        safe_id,
        safes!inner(
          id,
          serial_number,
          status,
          battery_level,
          last_update,
          tracknetics_device_id,
          tracking_device_id
        )
      `
        )
        .eq("tracking_token", trackingToken)
        .eq("customer_tracking_enabled", true)
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      // Transform the data to match our interface (safes is returned as array, we need single object)
      const transformedData = {
        ...data,
        safes: Array.isArray(data.safes) ? data.safes[0] : data.safes,
      };

      return { success: true, trip: transformedData };
    } catch (err: any) {
      console.error("Error fetching trip by tracking token:", err);
      return { success: false, error: "Failed to load tracking information" };
    }
  }

  // Enable/disable customer tracking for a trip
  async toggleCustomerTracking(tripId: string, enabled: boolean) {
    try {
      const { data, error } = await supabase
        .from("trips")
        .update({
          customer_tracking_enabled: enabled,
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId)
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true, trip: data };
    } catch (err) {
      console.error("Error toggling customer tracking:", err);
      return { success: false, error: "Failed to update tracking settings" };
    }
  }

  async updateSafeStatus(safeId: string, updates: { status: SafeStatus }) {
    const { data, error } = await supabase
      .from("safes")
      .update(updates)
      .eq("id", safeId)
      .select()
      .single();

    if (error) {
      throw new Error(error.message);
    }

    return { success: true, safe: data };
  }

  async updateTripStatus(tripId: string, status: TripStatus) {
    try {
      const { data, error } = await supabase
        .from("trips")
        .update({
          status,
          updated_at: new Date().toISOString(),
          ...(status === "in_transit" && {
            actual_pickup_time: new Date().toISOString(),
          }),
          ...(status === "delivered" && {
            actual_delivery_time: new Date().toISOString(),
          }),
        })
        .eq("id", tripId)
        .select("*, safes(serial_number)")
        .single();

      if (error) {
        toast.error("Failed to update trip status");
        throw new Error(error.message);
      }

      if (data.customer_tracking_enabled && data.client_email) {
        await this.sendStatusUpdateEmail(data, status);
      }

      toast.success(`Trip status updated to ${status.replace("_", " ")}`);
      return { success: true, trip: data };
    } catch (error) {
      console.error("Error updating trip status:", error);
      throw error;
    }
  }

  // Send status update email
  private async sendStatusUpdateEmail(trip: any, newStatus: string) {
    try {
      console.log(
        `Sending status update email: ${newStatus} to ${trip.client_email}`
      );

      const statusMessages = {
        in_transit:
          "Your items have been securely collected and are now in transit",
        delivered: "Your secure transport has been completed successfully",
        cancelled: "Your secure transport has been cancelled",
      };

      // Get current session for auth headers
      const {
        data: { session },
      } = await supabase.auth.getSession();

      const { error } = await supabase.functions.invoke(
        "send-customer-tracking", // Reuse same function
        {
          headers: {
            Authorization: `Bearer ${session?.access_token}`,
          },
          body: {
            to: trip.client_email,
            trip_id: trip.id,
            client_name: trip.client_name,
            pickup_address: trip.pickup_address,
            delivery_address: trip.delivery_address,
            scheduled_pickup: trip.scheduled_pickup,
            scheduled_delivery: trip.scheduled_delivery,
            special_instructions: trip.special_instructions,
            priority: trip.priority || "normal",
            tracking_url: this.generateTrackingUrl(trip.tracking_token),
            status_update: true, // Flag for status update email
            new_status: newStatus,
            status_message:
              statusMessages[newStatus as keyof typeof statusMessages],
          },
        }
      );

      if (error) {
        console.error("Error sending status update email:", error);
      } else {
        console.log("Status update email sent successfully");
      }
    } catch (error) {
      console.error("Exception sending status update email:", error);
    }
  }

  // Update an existing trip
  async updateTrip(
    tripId: string,
    updates: Partial<TripBookingData>
  ): Promise<{ success: boolean; trip?: Trip; error?: string }> {
    try {
      // If updating schedule, check for conflicts
      if (
        updates.safe_id ||
        updates.scheduled_pickup ||
        updates.scheduled_delivery
      ) {
        const { data: currentTrip } = await supabase
          .from("trips")
          .select("safe_id, scheduled_pickup, scheduled_delivery")
          .eq("id", tripId)
          .single();

        if (currentTrip) {
          const safeId = updates.safe_id || currentTrip.safe_id;
          const pickupTime =
            updates.scheduled_pickup || currentTrip.scheduled_pickup;
          const deliveryTime =
            updates.scheduled_delivery || currentTrip.scheduled_delivery;

          const conflicts = await this.checkSchedulingConflicts(
            safeId,
            pickupTime,
            deliveryTime,
            tripId
          );

          if (conflicts.length > 0) {
            return {
              success: false,
              error: `Scheduling conflict detected with existing trip`,
            };
          }
        }
      }

      const { data: updatedTrip, error } = await supabase
        .from("trips")
        .update({
          ...updates,
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId)
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true, trip: updatedTrip };
    } catch (error) {
      console.error("Error updating trip:", error);
      return {
        success: false,
        error: "Failed to update trip. Please try again.",
      };
    }
  }

  // Cancel a trip
  async cancelTrip(
    tripId: string,
    cancelReason?: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const { error } = await supabase
        .from("trips")
        .update({
          status: "cancelled",
          cancellation_reason: cancelReason,
          cancelled_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId);

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true };
    } catch (error) {
      console.error("Error cancelling trip:", error);
      return {
        success: false,
        error: "Failed to cancel trip. Please try again.",
      };
    }
  }

  // Setup automatic real-time subscriptions
  setupRealtimeSubscriptions() {
    const user = currentUser.value;
    if (!user) return;

    // Subscribe to safes
    this.safesSubscription = supabase
      .channel("safes-changes")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "safes" },
        (payload) => {
          if (payload.eventType === "INSERT") {
            dataActions.addSafe(payload.new as Safe);
          } else if (payload.eventType === "UPDATE") {
            dataActions.updateSafe(
              payload.new.id,
              payload.new as Partial<Safe>
            );
          }
        }
      )
      .subscribe((status) => {
        console.log("Safes subscription status:", status);

        if (status === "CHANNEL_ERROR") {
          this.handleSubscriptionError("safes");
        } else if (status === "SUBSCRIBED") {
          this.reconnectionAttempts = 0;
        }
      });

    // Subscribe to trips
    this.tripsSubscription = supabase
      .channel("trips-changes")
      .on(
        "postgres_changes",
        { event: "*", schema: "public", table: "trips" },
        (payload) => {
          if (payload.eventType === "INSERT") {
            dataActions.addTrip(payload.new as Trip);
          } else if (payload.eventType === "UPDATE") {
            dataActions.updateTrip(
              payload.new.id,
              payload.new as Partial<Trip>
            );
          }
        }
      )
      .subscribe((status) => {
        console.log("Trips subscription status:", status);

        if (status === "CHANNEL_ERROR") {
          this.handleSubscriptionError("trips");
        } else if (status === "SUBSCRIBED") {
          this.reconnectionAttempts = 0;
        }
      });
  }

  private handleSubscriptionError(channelName: string) {
    console.error(`Subscription error for ${channelName}`);

    if (this.reconnectionAttempts < this.maxReconnectionAttempts) {
      this.reconnectionAttempts++;
      const delay = Math.min(
        1000 * Math.pow(2, this.reconnectionAttempts),
        30000
      );

      console.log(
        `Attempting to reconnect ${channelName} in ${delay}ms (attempt ${this.reconnectionAttempts})`
      );

      setTimeout(() => {
        this.cleanup();
        this.setupRealtimeSubscriptions();
      }, delay);
    } else {
      console.error(`Max reconnection attempts reached for ${channelName}`);
      toast.error("Real-time updates disconnected. Please refresh the page.");
    }
  }

  cleanup() {
    // Clean up subscriptions
    if (this.safesSubscription) {
      supabase.removeChannel(this.safesSubscription);
    }
    if (this.tripsSubscription) {
      supabase.removeChannel(this.tripsSubscription);
    }
  }

  // Utility functions
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  private isValidPhone(phone: string): boolean {
    // Remove spaces, dashes, parentheses for validation
    const cleanPhone = phone.replace(/[\s\-\(\)]/g, "");

    const southAfricanPatterns = [
      /^0[7-8][0-9]\d{7}$/, // Mobile: 071, 072, etc (10 digits total)
      /^0[1-6]\d{8}$/, // Landline: 010, 011, etc (10 digits total)
      /^\+27[7-8][0-9]\d{7}$/, // International mobile: +27 71, +27 82, etc
      /^\+27[1-6]\d{8}$/, // International landline: +27 11, +27 21, etc
      /^27[7-8][0-9]\d{7}$/, // International mobile without +: 27 71, 27 82, etc
      /^27[1-6]\d{8}$/, // International landline without +: 27 11, 27 21, etc
    ];

    // Test against South African patterns
    for (const pattern of southAfricanPatterns) {
      if (pattern.test(cleanPhone)) {
        return true;
      }
    }

    // Fallback: Allow any reasonable phone number format (more permissive)
    // This catches any other valid international formats
    const generalPattern = /^[\+]?[\d\s\-\(\)]{7,15}$/;
    return generalPattern.test(cleanPhone);
  }

  // 1. CLIENT: Booking confirmation
  private async sendClientBookingConfirmation(trip: Trip) {
    try {
      if (!trip.client_email) return;

      const trackingUrl =
        trip.customer_tracking_enabled && trip.tracking_token
          ? this.generateTrackingUrl(trip.tracking_token)
          : null;

      const emailPromise = supabase.functions.invoke(
        "send-client-booking-confirmation",
        {
          body: {
            to: trip.client_email,
            client_name: trip.client_name,
            trip_id: trip.id,
            pickup_address: trip.pickup_address,
            delivery_address: trip.delivery_address,
            recipient_name: trip.recipient_name,
            scheduled_pickup: trip.scheduled_pickup,
            scheduled_delivery: trip.scheduled_delivery,
            tracking_url: trackingUrl,
            priority: trip.priority || "normal",
          },
        }
      );

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("timeout")), 5000)
      );

      await Promise.race([emailPromise, timeoutPromise]).catch(() => {});
    } catch (error) {
      console.error("Client email error (non-blocking):", error);
    }
  }

  // 2. RECIPIENT: Driver arriving notification
  // (Called from mobile app when driver clicks "I've Arrived")
  async sendRecipientArrivalNotification(trip: Trip) {
    try {
      if (!trip.recipient_email) return;

      // OPTIONAL: Include tracking link for recipient
      // const trackingUrl = this.generateTrackingUrl(trip.tracking_token);

      const emailPromise = supabase.functions.invoke("send-recipient-arrival", {
        body: {
          to: trip.recipient_email,
          recipient_name: trip.recipient_name,
          delivery_address: trip.delivery_address,
          client_name: trip.client_name,
          // tracking_url: trackingUrl, // OPTIONAL
        },
      });

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("timeout")), 8000)
      );

      await Promise.race([emailPromise, timeoutPromise]).catch(() => {
        console.warn("Email timeout - continuing");
      });
    } catch (error) {
      console.error("Recipient arrival email error:", error);
    }
  }

  // 3. CLIENT: Delivery completed confirmation
  async sendClientDeliveryConfirmation(trip: Trip) {
    try {
      if (!trip.client_email) return;

      const emailPromise = supabase.functions.invoke(
        "send-delivery-confirmation",
        {
          body: {
            to: trip.client_email,
            client_name: trip.client_name,
            trip_id: trip.id,
            recipient_name: trip.recipient_name,
            delivery_address: trip.delivery_address,
            delivered_at: new Date().toISOString(),
          },
        }
      );

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("timeout")), 8000)
      );

      await Promise.race([emailPromise, timeoutPromise]).catch(() => {
        console.warn("Email timeout - continuing");
      });
    } catch (error) {
      console.error("Delivery confirmation email error:", error);
    }
  }
}

export const dataService = new DataService();
</file>

</files>
