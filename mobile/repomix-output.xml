This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
android/.gitignore
android/app/.gitignore
android/app/build.gradle
android/app/capacitor.build.gradle
android/app/proguard-rules.pro
android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java
android/app/src/main/AndroidManifest.xml
android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java
android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml
android/app/src/main/res/drawable/ic_launcher_background.xml
android/app/src/main/res/layout/activity_main.xml
android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
android/app/src/main/res/values/ic_launcher_background.xml
android/app/src/main/res/values/strings.xml
android/app/src/main/res/values/styles.xml
android/app/src/main/res/xml/file_paths.xml
android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java
android/build.gradle
android/capacitor.settings.gradle
android/gradle.properties
android/gradle/wrapper/gradle-wrapper.properties
android/gradlew
android/gradlew.bat
android/settings.gradle
android/variables.gradle
capacitor.config.ts
index.html
package.json
public/vite.svg
src/app.tsx
src/components/LoadingSpinner.tsx
src/components/OTPGenerator.tsx
src/components/TripCard.tsx
src/index.css
src/main.tsx
src/screens/DashboardScreen.tsx
src/screens/DeliveryScreen.tsx
src/screens/LoginScreen.tsx
src/services/audit.ts
src/services/auth.ts
src/services/bluetooth.ts
src/services/geolocation.ts
src/services/otp.ts
src/services/storage.ts
src/services/supabase.ts
src/services/tracknetics.ts
src/services/trips.ts
src/store/auth.ts
src/store/trips.ts
src/types/index.ts
src/utils/validation.ts
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Environment variables
.env
.env.local
.env.production

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="android/.gitignore">
# Using Android gitignore template: https://github.com/github/gitignore/blob/HEAD/Android.gitignore

# Built application files
*.apk
*.aar
*.ap_
*.aab

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
#  Uncomment the following line in case you need and you don't have the release build type files in your app
# release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Navigation Editor is relevant for you
.idea/navEditor.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Android Profiling
*.hprof

# Cordova plugins for Capacitor
capacitor-cordova-android-plugins

# Copied web assets
app/src/main/assets/public

# Generated Config files
app/src/main/assets/capacitor.config.json
app/src/main/assets/capacitor.plugins.json
app/src/main/res/xml/config.xml
</file>

<file path="android/app/.gitignore">
/build/*
!/build/.npmkeep
</file>

<file path="android/app/build.gradle">
apply plugin: 'com.android.application'

android {
    namespace "com.guardiansafe.mobile"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "com.guardiansafe.mobile"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}
</file>

<file path="android/app/capacitor.build.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_21
      targetCompatibility JavaVersion.VERSION_21
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-community-bluetooth-le')
    implementation project(':capacitor-app')
    implementation project(':capacitor-geolocation')
    implementation project(':capacitor-haptics')
    implementation project(':capacitor-preferences')
    implementation project(':capacitor-status-bar')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
</file>

<file path="android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:fullBackupContent="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:usesCleartextTraffic="false">

        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode|navigation"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <intent-filter android:autoVerify="true">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data android:scheme="https" />
                <data android:host="guardian-safe-1uv582r1n-majorbeards-projects.vercel.app" />
            </intent-filter>

        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"></meta-data>
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
</manifest>
</file>

<file path="android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java">
package com.guardiansafe.mobile;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {}
</file>

<file path="android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>
</file>

<file path="android/app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector
    android:height="108dp"
    android:width="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108"
    xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#3DDC84"
          android:pathData="M0,0h108v108h-108z"/>
    <path android:fillColor="#00000000" android:pathData="M9,0L9,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,0L19,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,0L29,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,0L39,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,0L49,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,0L59,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,0L69,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,0L79,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M89,0L89,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M99,0L99,108"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,9L108,9"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,19L108,19"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,29L108,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,39L108,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,49L108,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,59L108,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,69L108,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,79L108,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,89L108,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M0,99L108,99"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,29L89,29"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,39L89,39"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,49L89,49"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,59L89,59"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,69L89,69"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M19,79L89,79"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M29,19L29,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M39,19L39,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M49,19L49,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M59,19L59,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M69,19L69,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
    <path android:fillColor="#00000000" android:pathData="M79,19L79,89"
          android:strokeColor="#33FFFFFF" android:strokeWidth="0.8"/>
</vector>
</file>

<file path="android/app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@drawable/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/values/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>
</file>

<file path="android/app/src/main/res/values/strings.xml">
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">Khluys</string>
    <string name="title_activity_main">Khluys</string>
    <string name="package_name">com.khluys.mobile</string>
    <string name="custom_url_scheme">com.khluys.mobile</string>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/xml/file_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>
</file>

<file path="android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="android/build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.2'
        classpath 'com.google.gms:google-services:4.4.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="android/capacitor.settings.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-community-bluetooth-le'
project(':capacitor-community-bluetooth-le').projectDir = new File('../node_modules/@capacitor-community/bluetooth-le/android')

include ':capacitor-app'
project(':capacitor-app').projectDir = new File('../node_modules/@capacitor/app/android')

include ':capacitor-geolocation'
project(':capacitor-geolocation').projectDir = new File('../node_modules/@capacitor/geolocation/android')

include ':capacitor-haptics'
project(':capacitor-haptics').projectDir = new File('../node_modules/@capacitor/haptics/android')

include ':capacitor-preferences'
project(':capacitor-preferences').projectDir = new File('../node_modules/@capacitor/preferences/android')

include ':capacitor-status-bar'
project(':capacitor-status-bar').projectDir = new File('../node_modules/@capacitor/status-bar/android')
</file>

<file path="android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="android/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="android/settings.gradle">
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
</file>

<file path="android/variables.gradle">
ext {
    minSdkVersion = 23
    compileSdkVersion = 35
    targetSdkVersion = 35
    androidxActivityVersion = '1.9.2'
    androidxAppCompatVersion = '1.7.0'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.15.0'
    androidxFragmentVersion = '1.8.4'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.12.1'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.2.1'
    androidxEspressoCoreVersion = '3.6.1'
    cordovaAndroidVersion = '10.1.1'
}
</file>

<file path="capacitor.config.ts">
import { CapacitorConfig } from "@capacitor/cli";

const config: CapacitorConfig = {
  appId: "com.guardiansafe.mobile",
  appName: "Guardian Safe Driver",
  webDir: "dist",
  android: {
    allowMixedContent: true,
  },
  plugins: {
    BluetoothLe: {
      displayStrings: {
        scanning: "Scanning for Guardian Safe...",
        cancel: "Cancel",
        availableDevices: "Available Safes",
        noDeviceFound: "No Guardian Safe found",
      },
    },
    Geolocation: {
      permissions: {
        location: "always",
      },
    },
    Preferences: {
      group: "com.guardiansafe.mobile.prefs",
    },
  },
};

export default config;
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guardian Safe - Mobile</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "mobile",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@capacitor-community/bluetooth-le": "^7.2.0",
    "@capacitor/android": "^7.4.3",
    "@capacitor/app": "^7.1.0",
    "@capacitor/core": "^7.4.3",
    "@capacitor/geolocation": "^7.1.5",
    "@capacitor/haptics": "^7.0.2",
    "@capacitor/preferences": "^7.0.2",
    "@capacitor/status-bar": "^7.0.3",
    "@preact/signals": "^2.3.1",
    "@supabase/supabase-js": "^2.57.4",
    "@tailwindcss/vite": "^4.1.13",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-preact": "^0.544.0",
    "preact": "^10.26.5",
    "tailwindcss": "^4.1.13"
  },
  "devDependencies": {
    "@capacitor/cli": "^7.4.3",
    "@preact/preset-vite": "^2.10.1",
    "typescript": "~5.8.3",
    "vite": "^6.3.5"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/app.tsx">
import { useEffect } from "preact/hooks";
import { App as CapacitorApp } from "@capacitor/app";
import { mobileAuthService } from "./services/auth";
import { isAuthenticated, isLoading } from "./store/auth";
import { LoginScreen } from "./screens/LoginScreen";
import { DashboardScreen } from "./screens/DashboardScreen";
import { LoadingSpinner } from "./components/LoadingSpinner";

export function App() {
  const authenticated = isAuthenticated.value;
  const loading = isLoading.value;

  useEffect(() => {
    // Initialize auth on app start - only run once
    mobileAuthService.initialize();

    let listener: any = null;

    // Set up app state listener
    const setupListener = async () => {
      listener = await CapacitorApp.addListener('appStateChange', async ({ isActive }) => {
        console.log('App state changed. Active:', isActive);

        if (isActive) {
          // App came to foreground, validate session
          console.log('App became active, validating session...');
          const sessionToken = await mobileAuthService.getSessionToken();
          const currentlyAuthenticated = isAuthenticated.value;

          if (!sessionToken && currentlyAuthenticated) {
            console.log('Session expired while app was in background, logging out');
            await mobileAuthService.logout();
          }
        }
      });
    };

    setupListener();

    // Cleanup listener on unmount
    return () => {
      if (listener) {
        listener.remove();
      }
    };
  }, []); // Empty dependency array - only run once on mount

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="mt-4 text-gray-600">Connecting to Khluys...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return <LoginScreen />;
  }

  // Show main dashboard
  return <DashboardScreen />;
}

export default App;
</file>

<file path="src/components/LoadingSpinner.tsx">
import { clsx } from "clsx";

interface LoadingSpinnerProps {
  size?: "small" | "medium" | "large";
  className?: string;
}

export function LoadingSpinner({
  size = "medium",
  className,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    small: "w-4 h-4",
    medium: "w-6 h-6",
    large: "w-8 h-8",
  };

  return (
    <div
      className={clsx(
        "animate-spin rounded-full border-2 border-gray-300 border-t-blue-600",
        sizeClasses[size],
        className
      )}
    />
  );
}
</file>

<file path="src/components/OTPGenerator.tsx">
import { MapPin, Send } from "lucide-preact";
import { LoadingSpinner } from "./LoadingSpinner";

interface OTPGeneratorProps {
  onOTPRequested: () => void;
  loading: boolean;
}

export function OTPGenerator({ onOTPRequested, loading }: OTPGeneratorProps) {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-gray-200 p-6 text-center">
      <div className="bg-orange-50 rounded-full p-4 w-16 h-16 mx-auto mb-4 flex items-center justify-center">
        <Send className="h-8 w-8 text-brand" />
      </div>
      <h3 className="text-xl font-semibold text-gray-900 mb-2">
        Request Delivery Code
      </h3>
      <p className="text-gray-500 text-sm mb-6">
        Confirm your location to send the unlock code to the recipient.
      </p>

      <button
        onClick={onOTPRequested}
        disabled={loading}
        className="w-full btn btn-primary py-3 rounded-lg flex items-center justify-center gap-2"
      >
        {loading ? (
          <>
            <LoadingSpinner size="small" className="text-white" />
            <span>Verifying Location...</span>
          </>
        ) : (
          <>
            <MapPin className="h-4 w-4" />
            <span>Verify & Send Code</span>
          </>
        )}
      </button>
    </div>
  );
}
</file>

<file path="src/components/TripCard.tsx">
import {
  // MapPin,
  Calendar,
  // Clock,
  AlertTriangle,
  ArrowRight,
} from "lucide-preact";
import { format, isPast } from "date-fns";

interface TripCardProps {
  trip: {
    id: string;
    client_name: string;
    pickup_address: string;
    delivery_address: string;
    status: string;
    scheduled_pickup: string;
    scheduled_delivery: string;
    priority?: string;
  };
  onStartTrip?: () => void;
  onViewDetails?: () => void;
  variant?: "default" | "active";
}

export function TripCard({
  trip,
  onStartTrip,
  onViewDetails,
  variant = "default",
}: TripCardProps) {
  const isOverdue =
    isPast(new Date(trip.scheduled_pickup)) && trip.status === "pending";
  const isHighPriority = trip.priority === "high" || trip.priority === "urgent";

  if (variant === "active") {
    return (
      <div className="bg-brand text-white rounded-xl p-5 shadow-lg shadow-brand/30 relative overflow-hidden">
        <div className="absolute top-0 right-0 -mt-4 -mr-4 w-24 h-24 bg-white/10 rounded-full blur-xl pointer-events-none"></div>

        <div className="relative z-10">
          <div className="flex justify-between items-start mb-4">
            <span className="bg-white/20 text-white text-[10px] font-bold px-2 py-1 rounded uppercase tracking-wider backdrop-blur-sm">
              In Progress
            </span>
            <span className="text-white/80 font-mono text-xs">
              #{trip.id.slice(-4)}
            </span>
          </div>

          <h3 className="text-xl font-bold mb-1 truncate">
            {trip.client_name}
          </h3>
          <p className="text-white/90 text-sm mb-6 line-clamp-2">
            {trip.delivery_address}
          </p>

          <button className="w-full bg-white text-brand font-bold py-3 rounded-lg shadow-sm flex items-center justify-center gap-2 active:scale-[0.98] transition-transform">
            Continue <ArrowRight className="h-4 w-4" />
          </button>
        </div>
      </div>
    );
  }

  return (
    <div
      onClick={onViewDetails}
      className="bg-white rounded-xl border border-gray-200 p-4 shadow-sm active:bg-gray-50 transition-colors relative overflow-hidden"
    >
      {/* Priority Stripe */}
      {isHighPriority && (
        <div className="absolute left-0 top-0 bottom-0 w-1 bg-red-500"></div>
      )}

      <div className="flex justify-between items-start mb-3 pl-2">
        <div>
          <h3 className="font-semibold text-gray-900">{trip.client_name}</h3>
          {isOverdue && (
            <div className="flex items-center gap-1 text-red-600 text-xs font-medium mt-0.5">
              <AlertTriangle className="h-3 w-3" /> Overdue
            </div>
          )}
        </div>
        <div className="text-right">
          <span className="text-xs font-mono text-gray-400">
            #{trip.id.slice(-4)}
          </span>
        </div>
      </div>

      <div className="space-y-2 pl-2 mb-4">
        <div className="flex items-start gap-2">
          <div className="mt-0.5 w-1.5 h-1.5 rounded-full bg-gray-300 flex-shrink-0"></div>
          <p className="text-xs text-gray-500 line-clamp-1">
            {trip.pickup_address}
          </p>
        </div>
        <div className="flex items-start gap-2">
          <div className="mt-0.5 w-1.5 h-1.5 rounded-full bg-brand flex-shrink-0"></div>
          <p className="text-xs text-gray-900 font-medium line-clamp-1">
            {trip.delivery_address}
          </p>
        </div>
      </div>

      <div className="flex items-center justify-between pl-2 pt-3 border-t border-gray-50">
        <div className="flex items-center gap-1.5 text-xs text-gray-500">
          <Calendar className="h-3.5 w-3.5" />
          {format(new Date(trip.scheduled_pickup), "MMM d, HH:mm")}
        </div>

        {onStartTrip && (
          <button
            onClick={(e) => {
              e.stopPropagation();
              onStartTrip();
            }}
            className="bg-gray-900 text-white text-xs font-medium px-3 py-1.5 rounded-md shadow-sm hover:bg-gray-800 transition-colors"
          >
            Start Trip
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/index.css">
@import "tailwindcss";

@theme {
  /* Kluys Brand Colors */
  --color-brand: #ff6b35;
  --color-brand-hover: #ff5722;
  --color-brand-light: #fff1ec;

  /* Semantic Borders & Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem; /* 6px - Crisp */
  --radius-lg: 0.5rem; /* 8px */

  /* Animations */
  --animate-fade-in: fade-in 0.2s ease-out;
  --animate-slide-up: slide-up 0.3s cubic-bezier(0.16, 1, 0.3, 1);

  @keyframes fade-in {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  @keyframes slide-up {
    from {
      transform: translateY(10px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
}

@layer base {
  body {
    @apply bg-gray-50 text-gray-900 antialiased;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
      Roboto, sans-serif;
  }

  ::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  ::-webkit-scrollbar-track {
    @apply bg-transparent;
  }
  ::-webkit-scrollbar-thumb {
    @apply bg-gray-300 rounded-full hover:bg-gray-400;
  }
}

@layer components {
  /* --- Buttons --- */
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-1 focus:ring-brand disabled:opacity-50 disabled:cursor-not-allowed cursor-pointer active:scale-[0.98];
  }

  .btn-primary {
    @apply bg-brand text-white border border-transparent hover:bg-brand-hover shadow-sm;
  }

  .btn-secondary {
    @apply bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 hover:text-gray-900 shadow-sm;
  }

  .btn-ghost {
    @apply bg-transparent text-gray-500 hover:text-gray-900 hover:bg-gray-100;
  }

  .btn-danger {
    @apply bg-white text-red-600 border border-red-200 hover:bg-red-50 hover:border-red-300;
  }

  /* --- Inputs --- */
  .input {
    @apply block w-full px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-900 placeholder-gray-400
    transition-colors duration-200
    focus:outline-none focus:border-brand focus:ring-1 focus:ring-brand
    disabled:bg-gray-50 disabled:text-gray-500;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 mb-1.5;
  }

  /* --- Cards & Layout (Fixed Padding) --- */
  .card {
    @apply bg-white rounded-lg border border-gray-200 shadow-[0_1px_3px_rgba(0,0,0,0.05)] p-6;
  }

  /* --- Badges --- */
  .badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border;
  }
  .badge-success {
    @apply bg-green-50 text-green-700 border-green-200;
  }
  .badge-warning {
    @apply bg-orange-50 text-orange-700 border-orange-200;
  }
  .badge-error {
    @apply bg-red-50 text-red-700 border-red-200;
  }
  .badge-neutral {
    @apply bg-gray-100 text-gray-700 border-gray-200;
  }
  .badge-brand {
    @apply bg-brand-light text-brand border-brand-light;
  }
}
</file>

<file path="src/main.tsx">
import { render } from "preact";
import { App } from "./app.tsx";
import "./index.css";

render(<App />, document.getElementById("app")!);
</file>

<file path="src/screens/DashboardScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  LogOut,
  Shield,
  // Bell,
  Package,
  AlertTriangle,
  Phone,
  RefreshCw,
  Unlock,
  Bluetooth,
} from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { tripsService } from "../services/trips";
import { currentUser, currentSafe } from "../store/auth";
import {
  currentTrips,
  pendingTrips,
  inTransitTrip,
  isLoading,
  error,
} from "../store/trips";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { TripCard } from "../components/TripCard";
import { DeliveryScreen } from "./DeliveryScreen";
import { bluetoothService } from "../services/bluetooth";

export function DashboardScreen() {
  const user = currentUser.value;
  const safe = currentSafe.value;
  const trips = currentTrips.value;
  const pending = pendingTrips.value;
  const inTransit = inTransitTrip.value;
  const loading = isLoading.value;
  const tripsError = error.value;

  const [selectedTrip, setSelectedTrip] = useState<any>(null);
  const [btConnected, setBtConnected] = useState(false);

  // Pi Status State
  const [piStatus, setPiStatus] = useState<{
    verified: boolean;
    lockOpen: boolean;
    batteryPercent: number;
    safeStatus: string;
    voltage: number;
  } | null>(null);

  // 1. Initialize Bluetooth
  useEffect(() => {
    const initBluetooth = async () => {
      await bluetoothService.initialize();
      // Try auto-connect
      const scanResult = await bluetoothService.scanForPi();
      if (scanResult.success) {
        const connectResult = await bluetoothService.connectToPi();
        if (connectResult.success) {
          setBtConnected(true);
          // Initial status read
          const statusResult = await bluetoothService.readPiStatus();
          if (statusResult.success && statusResult.status) {
            updateStatusState(statusResult.status);
          }
        }
      }
    };
    initBluetooth();
    return () => bluetoothService.disconnect();
  }, []);

  // 2. Poll Status
  useEffect(() => {
    if (!btConnected) return;
    const pollStatus = async () => {
      const result = await bluetoothService.readPiStatus();
      if (result.success && result.status) {
        updateStatusState(result.status);
      }
    };
    const interval = setInterval(pollStatus, 30000);
    return () => clearInterval(interval);
  }, [btConnected]);

  // Helper to update status safely
  const updateStatusState = (status: any) => {
    setPiStatus({
      verified: status.verified,
      lockOpen: status.lockOpen,
      batteryPercent: status.batteryPercent,
      safeStatus: status.safeStatus,
      voltage: status.voltage,
    });
  };

  // Subscribe to real-time status updates
  useEffect(() => {
    if (!btConnected) return;

    bluetoothService.subscribeToPiStatus((status) => {
      console.log("Real-time status update:", status);
      // Merge notification with existing state to preserve all fields
      setPiStatus((prev) => ({
        verified: status.verified,
        lockOpen: status.lockOpen,
        batteryPercent: status.batteryPercent,
        voltage: status.voltage,
        safeStatus: prev?.safeStatus || "active", // Preserve or default
      }));
    });
  }, [btConnected]);

  // 3. Load Trips
  useEffect(() => {
    tripsService.loadTrips();
    tripsService.setupRealtimeSubscriptions();
    return () => tripsService.cleanup();
  }, []);

  const handleStartTrip = async (tripId: string) => {
    const result = await tripsService.startTrip(tripId);
    if (result.success) {
      const trip = trips.find((t) => t.id === tripId);
      if (trip) setSelectedTrip(trip);
    } else {
      alert(`Error: ${result.error}`);
    }
  };

  const handleLogout = async () => {
    if (confirm("Sign out of driver session?")) {
      await mobileAuthService.logout();
    }
  };

  const handleSOS = () => {
    alert("SOS ACTIVATED: Emergency services notified.");
  };

  // If a trip is selected or in progress, show Delivery Screen
  if (selectedTrip) {
    return (
      <DeliveryScreen
        trip={selectedTrip}
        onBack={() => setSelectedTrip(null)}
      />
    );
  }

  // Main Dashboard UI
  return (
    <div className="min-h-screen bg-gray-50 pb-safe">
      {/* Header */}
      <div className="bg-white pt-safe px-4 py-4 pt-6 border-b border-gray-200 sticky top-0 z-20 shadow-sm">
        <div className="flex justify-between items-center">
          <div>
            <h1 className="text-xl font-bold text-gray-900">
              Hi, {user?.driver_name || user?.username}
            </h1>
            <p className="text-xs text-gray-500 mt-0.5">
              Safe ID:{" "}
              <span className="font-mono font-medium">
                {safe?.serial_number}
              </span>
            </p>
          </div>
          <button
            onClick={handleSOS}
            className="bg-red-50 text-red-600 p-2.5 rounded-full border border-red-100 active:scale-95 transition-transform shadow-sm"
          >
            <Phone className="h-5 w-5" />
          </button>
        </div>
      </div>

      {/* Safe Status Scroll */}
      <div className="bg-gray-50 pt-4 pb-2 px-4">
        <div className="flex gap-3 overflow-x-auto no-scrollbar pb-2">
          {/* Status Card: Connection */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <div className="flex items-center gap-2 text-xs text-gray-500 mb-2">
              <Bluetooth className="h-3.5 w-3.5" /> Connection
            </div>
            <div className="flex items-center gap-2">
              <div
                className={`w-2.5 h-2.5 rounded-full ${
                  btConnected ? "bg-green-500 animate-pulse" : "bg-gray-300"
                }`}
              ></div>
              <span className="text-sm font-medium text-gray-900">
                {btConnected ? "Connected" : "Offline"}
              </span>
            </div>
          </div>

          {/* Status Card: Battery */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <p className="text-xs text-gray-500 mb-2">Battery Level</p>
            <div className="flex items-baseline gap-1">
              <span
                className={`text-xl font-bold ${
                  (piStatus?.batteryPercent ?? safe?.battery_level ?? 0) < 20
                    ? "text-red-600"
                    : "text-gray-900"
                }`}
              >
                {piStatus?.batteryPercent ?? safe?.battery_level ?? 0}%
              </span>
              {piStatus?.voltage && (
                <span className="text-xs text-gray-400">
                  {piStatus.voltage.toFixed(1)}V
                </span>
              )}
            </div>
          </div>

          {/* Status Card: Lock */}
          <div className="bg-white p-3 rounded-lg border border-gray-200 shadow-sm min-w-[130px] flex flex-col justify-between">
            <p className="text-xs text-gray-500 mb-2">Lock State</p>
            <div className="flex items-center gap-1.5">
              {piStatus?.lockOpen || safe?.is_locked === false ? (
                <>
                  <Unlock className="h-4 w-4 text-red-600" />
                  <span className="text-sm font-medium text-red-600">
                    Unlocked
                  </span>
                </>
              ) : (
                <>
                  <Shield className="h-4 w-4 text-green-600" />
                  <span className="text-sm font-medium text-green-600">
                    Secured
                  </span>
                </>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Warnings */}
      <div className="px-4 space-y-2">
        {!btConnected && (
          <div className="bg-gray-900 text-white px-4 py-3 rounded-lg flex items-center justify-between shadow-sm">
            <div className="flex items-center gap-3">
              <Bluetooth className="h-5 w-5 text-gray-400" />
              <span className="text-sm font-medium">Safe disconnected</span>
            </div>
          </div>
        )}
        {tripsError && (
          <div className="bg-red-50 border border-red-100 text-red-700 px-4 py-3 rounded-lg flex items-center gap-2 text-sm">
            <AlertTriangle className="h-4 w-4" /> {tripsError}
          </div>
        )}
      </div>

      {/* Main Content */}
      <div className="px-4 py-4 space-y-6 pb-24">
        {loading ? (
          <div className="py-12 text-center">
            <LoadingSpinner size="large" />
            <p className="mt-3 text-sm text-gray-500">Syncing trips...</p>
          </div>
        ) : (
          <>
            {/* In Transit Section */}
            {inTransit && (
              <section>
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-3 flex items-center gap-2">
                  <Package className="h-4 w-4" /> Current Job
                </h2>
                <div
                  onClick={() => setSelectedTrip(inTransit)}
                  className="cursor-pointer active:scale-[0.98] transition-transform"
                >
                  <TripCard trip={inTransit} variant="active" />
                </div>
              </section>
            )}

            {/* Pending Section */}
            <section>
              <div className="flex items-center justify-between mb-3">
                <h2 className="text-sm font-semibold text-gray-500 uppercase tracking-wider">
                  Up Next ({pending.length})
                </h2>
                <button
                  onClick={() => tripsService.loadTrips()}
                  className="text-brand text-xs font-medium p-1"
                >
                  Refresh
                </button>
              </div>

              {pending.length === 0 && !inTransit ? (
                <div className="text-center py-10 bg-white rounded-xl border border-dashed border-gray-200">
                  <Package className="h-10 w-10 text-gray-300 mx-auto mb-2" />
                  <p className="text-sm text-gray-500">No trips assigned.</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {pending.map((trip) => (
                    <TripCard
                      key={trip.id}
                      trip={trip}
                      onStartTrip={() => handleStartTrip(trip.id)}
                      onViewDetails={() => setSelectedTrip(trip)}
                    />
                  ))}
                </div>
              )}
            </section>
          </>
        )}
      </div>

      {/* Bottom Navigation */}
      <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 pb-safe px-6 py-3 pb-8 flex justify-between items-center z-30 shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)]">
        <button className="flex flex-col items-center gap-1 text-brand w-16">
          <Shield className="h-6 w-6" />
          <span className="text-[10px] font-medium">Home</span>
        </button>
        <button
          className="flex flex-col items-center gap-1 text-gray-400 hover:text-gray-600 active:text-gray-800 w-16"
          onClick={() => tripsService.loadTrips()}
        >
          <RefreshCw className="h-6 w-6" />
          <span className="text-[10px] font-medium">Sync</span>
        </button>
        <button
          className="flex flex-col items-center gap-1 text-gray-400 hover:text-red-600 active:text-red-700 w-16"
          onClick={handleLogout}
        >
          <LogOut className="h-6 w-6" />
          <span className="text-[10px] font-medium">Exit</span>
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/screens/DeliveryScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  ArrowLeft,
  Navigation,
  Key,
  CheckCircle,
  AlertCircle,
  Mail,
  // Package,
} from "lucide-preact";
import { tripsService } from "../services/trips";
import { otpService } from "../services/otp";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { bluetoothService } from "../services/bluetooth";
import { geolocationService } from "../services/geolocation";

interface DeliveryScreenProps {
  trip: any;
  onBack: () => void;
}

export function DeliveryScreen({ trip, onBack }: DeliveryScreenProps) {
  const [step, setStep] = useState<
    "travel" | "otp_req" | "otp_enter" | "unlocking" | "summary" | "success"
  >("travel");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [otpCode, setOtpCode] = useState("");
  const [deliveryNotes, setDeliveryNotes] = useState("");

  useEffect(() => {
    const saved = localStorage.getItem(`trip_state_${trip.id}`);
    if (saved) setStep(saved as any);
  }, [trip.id]);

  useEffect(() => {
    if (step === "success") localStorage.removeItem(`trip_state_${trip.id}`);
    else localStorage.setItem(`trip_state_${trip.id}`, step);
  }, [step, trip.id]);

  const handleArrived = async () => {
    setLoading(true);
    setError("");
    try {
      const locResult = await geolocationService.getCurrentPosition();
      if (!locResult.success) throw new Error(locResult.error);

      const updateResult = await tripsService.updateTripStatus(
        trip.id,
        "at_location"
      );
      if (!updateResult.success) throw new Error(updateResult.error);

      setStep("otp_req");
    } catch (err: any) {
      setError(err.message || "Failed to verify location.");
    } finally {
      setLoading(false);
    }
  };

  const handleRequestOTP = async () => {
    setLoading(true);
    setError("");
    try {
      const locResult = await geolocationService.getCurrentPosition();
      if (!locResult.success || !locResult.location)
        throw new Error("Location required for OTP.");

      const result = await otpService.requestOTP(trip.id, locResult.location);
      if (result.success) {
        setStep("otp_enter");
      } else {
        throw new Error(result.error);
      }
    } catch (err: any) {
      setError(err.message || "OTP Request failed.");
    } finally {
      setLoading(false);
    }
  };

  const handleUnlock = async () => {
    if (otpCode.length !== 6) return setError("Enter 6-digit code.");

    setLoading(true);
    setError("");

    try {
      const verifyResult = await otpService.verifyOTP(trip.id, otpCode);
      if (!verifyResult.success) throw new Error(verifyResult.error);

      if (!bluetoothService.isConnectedToPi()) {
        await bluetoothService.initialize();
        const scan = await bluetoothService.scanForPi();
        if (!scan.success) throw new Error("Safe not found. Move closer.");
        const conn = await bluetoothService.connectToPi();
        if (!conn.success) throw new Error("Bluetooth connection failed.");
      }

      setStep("unlocking");
      const btResult = await bluetoothService.sendOTPToPi(otpCode);
      if (!btResult.success) throw new Error(btResult.error);

      const completeResult = await tripsService.completeTrip(trip.id);
      if (!completeResult.success) throw new Error(completeResult.error);

      setStep("summary");
    } catch (err: any) {
      setError(err.message || "Unlock process failed.");
      setStep("otp_enter");
    } finally {
      setLoading(false);
    }
  };

  const handleConfirmDelivery = async () => {
    if (deliveryNotes.trim()) {
      await tripsService.addDeliveryNotes(trip.id, deliveryNotes);
    }
    setStep("success");
  };

  return (
    <div className="min-h-screen bg-white flex flex-col pb-safe">
      <div className="px-4 py-4 pt-5 border-b border-gray-100 flex items-center bg-white sticky top-0 z-10">
        <button
          onClick={onBack}
          className="p-2 -ml-2 text-gray-500 hover:bg-gray-50 rounded-full"
        >
          <ArrowLeft className="h-6 w-6" />
        </button>
        <div className="ml-2 flex-1">
          <h1 className="font-semibold text-gray-900 text-lg">Delivery</h1>
          <p className="text-xs text-gray-500 truncate w-48">
            {trip.delivery_address}
          </p>
        </div>
        <div className="ml-auto">
          <span className="bg-brand/10 text-brand text-xs font-bold px-2 py-1 rounded uppercase">
            {step === "success" ? "Done" : "Active"}
          </span>
        </div>
      </div>

      {error && (
        <div className="mx-4 mt-4 bg-red-50 border border-red-100 p-3 rounded-lg flex items-start gap-3">
          <AlertCircle className="h-5 w-5 text-red-600 flex-shrink-0 mt-0.5" />
          <p className="text-sm text-red-800">{error}</p>
        </div>
      )}

      <div className="flex-1 flex flex-col items-center justify-center p-6 text-center">
        {step === "travel" && (
          <div className="w-full max-w-sm">
            <div className="w-20 h-20 bg-blue-50 text-blue-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Navigation className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">En Route</h2>
            <p className="text-gray-500 mb-8">
              Navigate to the delivery location. Confirm arrival to proceed.
            </p>

            <div className="bg-gray-50 p-4 rounded-xl border border-gray-100 mb-8 text-left">
              <p className="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-1">
                Destination
              </p>
              <p className="text-gray-900 font-medium">
                {trip.delivery_address}
              </p>
              {trip.delivery_contact_name && (
                <p className="text-sm text-gray-500 mt-1">
                  {trip.delivery_contact_name}
                </p>
              )}
            </div>

            <button
              onClick={handleArrived}
              disabled={loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "I have Arrived"
              )}
            </button>
          </div>
        )}

        {step === "otp_req" && (
          <div className="w-full max-w-sm">
            <div className="w-20 h-20 bg-orange-50 text-orange-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Mail className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              Authorize Unlock
            </h2>
            <p className="text-gray-500 mb-8">
              Send the secure 6-digit code to the recipient to confirm identity.
            </p>

            <div className="bg-gray-50 p-4 rounded-xl border border-gray-100 mb-8 text-left">
              <p className="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2">
                Recipient
              </p>
              <p className="text-gray-900 font-medium text-lg">
                {trip.recipient_name || trip.client_name}
              </p>
              <p className="text-gray-500 flex items-center gap-2 mt-1">
                <Mail className="h-3 w-3" />
                {trip.recipient_email || trip.client_email}
              </p>
            </div>

            <button
              onClick={handleRequestOTP}
              disabled={loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "Send OTP Code"
              )}
            </button>
          </div>
        )}

        {step === "otp_enter" && (
          <div className="w-full max-w-sm">
            <div className="w-20 h-20 bg-gray-900 text-brand rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <Key className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              Enter Code
            </h2>
            <p className="text-gray-500 mb-8">
              Ask the recipient for the 6-digit PIN sent to their email.
            </p>

            <input
              type="text"
              inputMode="numeric"
              pattern="[0-9]*"
              maxLength={6}
              className="w-full text-center text-5xl tracking-[0.2em] font-mono border-b-2 border-gray-200 focus:border-brand outline-none py-4 mb-8 bg-transparent transition-colors"
              placeholder="••••••"
              value={otpCode}
              onInput={(e) => setOtpCode((e.target as HTMLInputElement).value)}
              autoFocus
            />

            <button
              onClick={handleUnlock}
              disabled={otpCode.length !== 6 || loading}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              {loading ? (
                <LoadingSpinner className="text-white" />
              ) : (
                "Verify & Unlock"
              )}
            </button>

            <button
              onClick={() => setStep("otp_req")}
              className="mt-4 text-sm text-gray-400 underline"
            >
              Resend Code
            </button>
          </div>
        )}

        {step === "unlocking" && (
          <div className="w-full max-w-sm text-center">
            <LoadingSpinner size="large" className="mx-auto mb-6 text-brand" />
            <h2 className="text-xl font-bold text-gray-900">
              Unlocking Safe...
            </h2>
            <p className="text-gray-500 mt-2">Communicating via Bluetooth</p>
          </div>
        )}

        {step === "summary" && (
          <div className="w-full max-w-sm">
            <div className="w-20 h-20 bg-blue-50 text-blue-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <CheckCircle className="h-10 w-10" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-2">
              Delivery Confirmation
            </h2>
            <p className="text-gray-500 mb-8">
              Review delivery details before finalizing
            </p>

            <div className="space-y-4 mb-8 text-left">
              <div className="bg-gray-50 p-4 rounded-lg border border-gray-200">
                <p className="text-xs text-gray-400 uppercase tracking-wider font-semibold mb-2">
                  Delivery Summary
                </p>
                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span className="text-gray-500">Client:</span>
                    <span className="font-medium text-gray-900">
                      {trip.client_name}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Recipient:</span>
                    <span className="font-medium text-gray-900">
                      {trip.recipient_name || trip.client_name}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-gray-500">Time:</span>
                    <span className="font-medium text-gray-900">
                      {new Date().toLocaleTimeString()}
                    </span>
                  </div>
                </div>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Additional Notes (Optional)
                </label>
                <textarea
                  className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-brand focus:border-transparent resize-none"
                  rows={3}
                  placeholder="Any issues, observations, or comments..."
                  value={deliveryNotes}
                  onInput={(e) =>
                    setDeliveryNotes((e.target as HTMLTextAreaElement).value)
                  }
                />
              </div>
            </div>

            <button
              onClick={handleConfirmDelivery}
              className="w-full btn btn-primary py-4 text-lg rounded-xl shadow-lg shadow-brand/20"
            >
              Confirm Delivery
            </button>
          </div>
        )}

        {step === "success" && (
          <div className="w-full max-w-sm">
            <div className="w-24 h-24 bg-green-50 text-green-600 rounded-full flex items-center justify-center mx-auto mb-6 shadow-sm">
              <CheckCircle className="h-12 w-12" />
            </div>
            <h2 className="text-3xl font-bold text-gray-900 mb-2">
              Delivery Done
            </h2>
            <p className="text-gray-600 mb-8">Safe unlocked. Job closed.</p>

            <button
              onClick={onBack}
              className="w-full btn btn-secondary py-4 text-lg rounded-xl border-gray-300"
            >
              Back to Dashboard
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/screens/LoginScreen.tsx">
import { useState } from "preact/hooks";
import { Shield, Eye, EyeOff, AlertTriangle, ArrowRight } from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { validateUsername, validatePassword } from "../utils/validation";

export function LoginScreen() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [validationErrors, setValidationErrors] = useState<{
    username?: string;
    password?: string;
  }>({});

  const validateForm = (): boolean => {
    const errors: { username?: string; password?: string } = {};

    const usernameValidation = validateUsername(username);
    if (!usernameValidation.valid) {
      errors.username = usernameValidation.error;
    }

    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      errors.password = passwordValidation.error;
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleLogin = async (e: Event) => {
    e.preventDefault();
    setError("");
    setValidationErrors({});

    // Client-side validation
    if (!validateForm()) {
      return;
    }

    setLoading(true);

    try {
      const result = await mobileAuthService.login(username, password);

      if (!result.success) {
        setError(result.error || "Login failed");
      }
    } catch (err) {
      setError("Network error. Please check your connection.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center px-6 py-12 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-sm text-center">
        <div className="mx-auto h-16 w-16 bg-gray-900 rounded-xl flex items-center justify-center shadow-sm mb-6">
          <Shield className="h-8 w-8 text-brand" />
        </div>
        <h2 className="text-2xl font-semibold tracking-tight text-gray-900">
          Driver Access
        </h2>
        <p className="mt-2 text-sm text-gray-500">Khluys</p>
      </div>

      <div className="mt-10 sm:mx-auto sm:w-full sm:max-w-sm">
        <form className="space-y-6" onSubmit={handleLogin}>
          {error && (
            <div className="bg-red-50 border border-red-100 rounded-lg p-3 flex items-center space-x-3">
              <AlertTriangle className="h-5 w-5 text-red-600 flex-shrink-0" />
              <p className="text-sm text-red-700">{error}</p>
            </div>
          )}

          <div>
            <label htmlFor="username" className="label">
              Username
            </label>
            <div className="mt-1">
              <input
                id="username"
                name="username"
                type="text"
                autoComplete="username"
                required
                className={`input ${
                  validationErrors.username
                    ? "border-red-300 focus:border-red-500 focus:ring-red-200"
                    : ""
                }`}
                placeholder="Enter username"
                value={username}
                onInput={(e) => {
                  setUsername((e.target as HTMLInputElement).value);
                  setValidationErrors({
                    ...validationErrors,
                    username: undefined,
                  });
                }}
              />
              {validationErrors.username && (
                <p className="mt-1 text-sm text-red-600">
                  {validationErrors.username}
                </p>
              )}
            </div>
          </div>

          <div>
            <label htmlFor="password" className="label">
              Password
            </label>
            <div className="mt-1 relative">
              <input
                id="password"
                name="password"
                type={showPassword ? "text" : "password"}
                autoComplete="current-password"
                required
                className={`input pr-10 ${
                  validationErrors.password
                    ? "border-red-300 focus:border-red-500 focus:ring-red-200"
                    : ""
                }`}
                placeholder="Enter password"
                value={password}
                onInput={(e) => {
                  setPassword((e.target as HTMLInputElement).value);
                  setValidationErrors({
                    ...validationErrors,
                    password: undefined,
                  });
                }}
              />
              <button
                type="button"
                className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600 transition-colors"
                onClick={() => setShowPassword(!showPassword)}
              >
                {showPassword ? (
                  <EyeOff className="h-5 w-5" />
                ) : (
                  <Eye className="h-5 w-5" />
                )}
              </button>
            </div>
            {validationErrors.password && (
              <p className="mt-1 text-sm text-red-600">
                {validationErrors.password}
              </p>
            )}
          </div>

          <button
            type="submit"
            disabled={loading}
            className="w-full btn btn-primary py-3 text-base shadow-md"
          >
            {loading ? (
              <div className="flex items-center justify-center space-x-2">
                <LoadingSpinner
                  size="small"
                  className="text-white border-white"
                />
                <span>Authenticating...</span>
              </div>
            ) : (
              <div className="flex items-center justify-center">
                <span>Sign In</span>
                <ArrowRight className="ml-2 h-4 w-4" />
              </div>
            )}
          </button>
        </form>

        <p className="mt-10 text-center text-xs text-gray-400">
          V0.2 • For Authorized Personnel Only
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/services/audit.ts">
import { supabase } from "./supabase";
import { currentUser, currentSafe } from "../store/auth";

class AuditService {
  async log(
    event: string,
    details: string,
    success: boolean = true,
    tripId?: string
  ) {
    try {
      await supabase.from("activity_log").insert({
        event,
        user_type: "driver",
        user_id: currentUser.value?.username || "unknown",
        safe_id: currentSafe.value?.id,
        trip_id: tripId,
        details,
        success,
        created_at: new Date().toISOString(),
      });

      console.log(`Logged: ${event} - ${details}`);
    } catch (err) {
      console.error("Audit log failed:", err);
      // Don't block on logging failures
    }
  }
}

export const auditService = new AuditService();
</file>

<file path="src/services/auth.ts">
import { supabase } from "./supabase";
import { authActions } from "../store/auth";
import { storageService } from "./storage";

interface StoredSession {
  token: string;
  expires_at: string;
}

class MobileAuthService {
  private readonly STORAGE_KEY = "guardian_mobile_user";
  private readonly SESSION_KEY = "guardian_mobile_session";
  private sessionCheckInterval: number | null = null;

  async initialize() {
    console.log("Initializing mobile auth service...");
    authActions.setLoading(true);

    try {
      const storedUser = await this.getStoredUser();
      const session = await this.getStoredSession();

      console.log("Stored user:", storedUser ? "Found" : "Not found");
      console.log("Stored session:", session ? "Found" : "Not found");

      if (storedUser && session) {
        const sessionExpiry = new Date(session.expires_at);
        const now = new Date();

        console.log("Session expires at:", sessionExpiry.toISOString());
        console.log("Current time:", now.toISOString());
        console.log("Session valid:", sessionExpiry > now);

        if (sessionExpiry > now) {
          console.log("Validating and refreshing user data...");
          const isValid = await this.validateAndRefreshUser(storedUser);
          if (isValid) {
            console.log("Session restored successfully");
            this.startSessionMonitoring();
            authActions.setLoading(false);
            return;
          }
        } else {
          console.log("Session expired, clearing...");
        }
      }

      console.log("No valid session found, clearing storage");
      await this.clearStoredUser();
      await this.clearSession();
    } catch (error) {
      console.error("Error during auth initialization:", error);
      await this.clearStoredUser();
      await this.clearSession();
    } finally {
      authActions.setLoading(false);
    }
  }

  private startSessionMonitoring() {
    if (this.sessionCheckInterval) {
      clearInterval(this.sessionCheckInterval);
    }

    // Check session validity every 5 minutes
    this.sessionCheckInterval = window.setInterval(async () => {
      const session = await this.getStoredSession();
      if (!session || new Date(session.expires_at) < new Date()) {
        console.log("Session expired during monitoring, logging out");
        await this.logout();
      }
    }, 5 * 60 * 1000);
  }

  private stopSessionMonitoring() {
    if (this.sessionCheckInterval) {
      clearInterval(this.sessionCheckInterval);
      this.sessionCheckInterval = null;
    }
  }

  async login(username: string, password: string) {
    console.log("Attempting mobile login for:", username);

    try {
      // Call the mobile-auth Edge Function
      const { data, error } = await supabase.functions.invoke("mobile-auth", {
        body: {
          username: username.trim(),
          password: password,
        },
      });

      if (error) {
        console.error("Mobile auth error:", error);
        return { success: false, error: "Login failed. Please try again." };
      }

      if (!data.success) {
        console.log("Login failed:", data.error);
        return { success: false, error: data.error || "Invalid credentials" };
      }

      console.log("Login successful for:", data.user.username);

      // Store session token
      await this.storeSession(data.session.token, data.session.expires_at);

      // Create mobile user object with proper typing
      const mobileUser = {
        id: data.user.id as string,
        username: data.user.username as string,
        driver_name: data.user.driver_name as string | undefined,
        safe_id: data.user.safe_id as string,
        safe: data.safe
          ? {
              id: data.safe.id as string,
              serial_number: data.safe.serial_number as string,
              status: data.safe.status as string,
              battery_level: data.safe.battery_level as number,
              is_locked: data.safe.is_locked as boolean,
              tracking_device_id: (data.safe.tracking_device_id ||
                data.safe.tracknetics_device_id) as string | undefined,
            }
          : null,
        is_active: true,
        created_at: new Date().toISOString(),
      };

      await this.storeUser(mobileUser);
      authActions.setUser(mobileUser);

      // Start session monitoring after a short delay to allow everything to settle
      setTimeout(() => {
        this.startSessionMonitoring();
      }, 1000);

      console.log("Login completed, session stored successfully");
      return { success: true };
    } catch (error: any) {
      console.error("Login exception:", error);
      return { success: false, error: "Network error. Please try again." };
    }
  }

  async logout() {
    console.log("Logging out...");
    this.stopSessionMonitoring();
    await this.clearStoredUser();
    await this.clearSession();
    authActions.logout();
  }

  private async validateAndRefreshUser(storedUser: any): Promise<boolean> {
    try {
      const session = await this.getStoredSession();
      if (!session || new Date(session.expires_at) < new Date()) {
        console.log("Session invalid or expired");
        return false;
      }

      console.log("Fetching user data from database...");
      const { data: user, error: userError } = await supabase
        .from("mobile_users")
        .select("*")
        .eq("username", storedUser.username)
        .eq("is_active", true)
        .single();

      if (userError || !user) {
        console.error("Failed to fetch user:", userError);
        return false;
      }

      console.log("Fetching safe data from database...");
      const { data: safe, error: safeError } = await supabase
        .from("safes")
        .select("*")
        .eq("id", user.safe_id)
        .single();

      if (safeError) {
        console.error("Failed to fetch safe:", safeError);
        return false;
      }

      const refreshedUser = {
        id: user.id,
        username: user.username,
        driver_name: user.driver_name,
        safe_id: user.safe_id,
        safe: safe
          ? {
              id: safe.id,
              serial_number: safe.serial_number,
              status: safe.status,
              battery_level: safe.battery_level,
              is_locked: safe.is_locked,
              tracking_device_id:
                safe.tracking_device_id || safe.tracknetics_device_id,
            }
          : null,
        is_active: true,
        created_at: user.created_at,
      };

      await this.storeUser(refreshedUser);
      authActions.setUser(refreshedUser);

      console.log("User data refreshed successfully");
      return true;
    } catch (error) {
      console.error("Error validating user:", error);
      return false;
    }
  }

  private async getStoredUser(): Promise<any> {
    return await storageService.get(this.STORAGE_KEY);
  }

  private async storeUser(user: any): Promise<void> {
    await storageService.set(this.STORAGE_KEY, user);
  }

  private async clearStoredUser(): Promise<void> {
    await storageService.remove(this.STORAGE_KEY);
  }

  private async getStoredSession(): Promise<StoredSession | null> {
    return await storageService.get<StoredSession>(this.SESSION_KEY);
  }

  private async storeSession(token: string, expires_at: string): Promise<void> {
    await storageService.set(this.SESSION_KEY, { token, expires_at });
  }

  private async clearSession(): Promise<void> {
    await storageService.remove(this.SESSION_KEY);
  }

  // Get current session token for authenticated requests
  async getSessionToken(): Promise<string | null> {
    const session = await this.getStoredSession();
    if (!session) {
      console.log("getSessionToken: No session found in storage");
      return null;
    }

    const expiresAt = new Date(session.expires_at);
    const now = new Date();

    if (expiresAt < now) {
      console.log("getSessionToken: Session expired", {
        expiresAt: expiresAt.toISOString(),
        now: now.toISOString()
      });
      return null;
    }

    console.log("getSessionToken: Valid session found, expires in", Math.floor((expiresAt.getTime() - now.getTime()) / 1000 / 60), "minutes");
    return session.token;
  }
}

export const mobileAuthService = new MobileAuthService();
</file>

<file path="src/services/bluetooth.ts">
import { BleClient } from "@capacitor-community/bluetooth-le";
import { mobileAuthService } from "./auth";

// Service UUIDs for Pi communication
const PI_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const OTP_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const STATUS_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";

interface BluetoothConfig {
  phoneMac: string;
  piMac: string;
  trackerMac: string;
}

class BluetoothService {
  private config: BluetoothConfig;
  private isConnected = false;
  private deviceId: string | null = null;
  private connectionAttempts = 0;
  private readonly MAX_CONNECTION_ATTEMPTS = 3;
  private reconnectTimer: number | null = null;

  constructor() {
    // Load MAC addresses from environment
    this.config = {
      phoneMac: import.meta.env.VITE_PHONE_MAC_1 || "",
      piMac: import.meta.env.VITE_PI_MAC || "",
      trackerMac: import.meta.env.VITE_TRACKER_IMEI || "",
    };
  }

  // Initialize Bluetooth
  async initialize() {
    try {
      // Check if user is authenticated
      const sessionToken = await mobileAuthService.getSessionToken();
      if (!sessionToken) {
        console.error("Cannot initialize Bluetooth: User not authenticated");
        return { success: false, error: "Authentication required" };
      }

      await BleClient.initialize();
      console.log("Bluetooth initialized");
      return { success: true };
    } catch (err: any) {
      console.error("Bluetooth init failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Validate phone MAC (optional security check)
  async validatePhoneMAC(): Promise<boolean> {
    // In production, you could implement device fingerprinting here
    // For now, we trust the authenticated session
    return true;
  }

  // Scan for Pi Bluetooth device with timeout
  async scanForPi(timeoutMs: number = 10000): Promise<{
    success: boolean;
    device?: any;
    error?: string;
  }> {
    try {
      console.log("Scanning for Pi with MAC:", this.config.piMac);

      let foundDevice = false;

      await BleClient.requestLEScan(
        { services: [PI_SERVICE_UUID] },
        (result) => {
          console.log("Device found:", result);

          // Check if this is our Pi by MAC address or name
          const deviceMac = result.device.deviceId.toUpperCase();
          const configMac = this.config.piMac.toUpperCase();

          if (
            deviceMac === configMac ||
            result.localName?.includes("GuardianSafe")
          ) {
            console.log("Found Guardian Safe Pi");
            BleClient.stopLEScan();
            this.deviceId = result.device.deviceId;
            foundDevice = true;
          }
        }
      );

      // Wait for scan timeout
      await new Promise((resolve) => setTimeout(resolve, timeoutMs));

      if (!foundDevice) {
        await BleClient.stopLEScan();
      }

      if (this.deviceId) {
        return { success: true, device: { deviceId: this.deviceId } };
      } else {
        return {
          success: false,
          error:
            "Guardian Safe not found. Make sure you are near the safe and it is powered on.",
        };
      }
    } catch (err: any) {
      console.error("Scan error:", err);
      await BleClient.stopLEScan().catch(() => {});
      return { success: false, error: err.message };
    }
  }

  // Connect to Pi with retry logic
  async connectToPi(): Promise<{ success: boolean; error?: string }> {
    if (!this.deviceId) {
      return { success: false, error: "No Pi device found. Scan first." };
    }

    // Check connection attempts
    if (this.connectionAttempts >= this.MAX_CONNECTION_ATTEMPTS) {
      return {
        success: false,
        error: "Maximum connection attempts reached. Please restart the app.",
      };
    }

    this.connectionAttempts++;

    try {
      console.log(
        `Connecting to Pi... (attempt ${this.connectionAttempts}/${this.MAX_CONNECTION_ATTEMPTS})`
      );

      await BleClient.connect(this.deviceId, (deviceId) => {
        console.log("Disconnected from Pi:", deviceId);
        this.handleDisconnection();
      });

      this.isConnected = true;
      this.connectionAttempts = 0; // Reset on success
      console.log("Connected to Pi");

      return { success: true };
    } catch (err: any) {
      console.error("Connection failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Handle unexpected disconnection
  private handleDisconnection() {
    this.isConnected = false;
    console.warn("Bluetooth connection lost");

    // Attempt to reconnect after delay
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    this.reconnectTimer = setTimeout(async () => {
      console.log("Attempting to reconnect...");
      const result = await this.connectToPi();
      if (!result.success) {
        console.error("Reconnection failed:", result.error);
      }
    }, 5000) as unknown as number;
  }

  // Send OTP to Pi for verification with validation
  async sendOTPToPi(
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    // Validate OTP format
    if (!/^\d{6}$/.test(otpCode)) {
      return { success: false, error: "Invalid OTP format" };
    }

    try {
      console.log("Sending OTP to Pi...");

      // Convert OTP string to bytes
      const encoder = new TextEncoder();
      const otpBytes = encoder.encode(otpCode);

      // Write OTP to characteristic with timeout
      const writePromise = BleClient.write(
        this.deviceId,
        PI_SERVICE_UUID,
        OTP_CHARACTERISTIC_UUID,
        new DataView(otpBytes.buffer)
      );

      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Write timeout")), 10000)
      );

      await Promise.race([writePromise, timeout]);

      console.log("OTP sent to Pi successfully");
      return { success: true };
    } catch (err: any) {
      console.error("Failed to send OTP:", err);

      // If write failed, connection might be lost
      if (
        err.message?.includes("disconnected") ||
        err.message?.includes("timeout")
      ) {
        this.isConnected = false;
      }

      return { success: false, error: err.message };
    }
  }

  // Read Pi status with enhanced error handling
  async readPiStatus(): Promise<{
    success: boolean;
    status?: {
      verified: boolean;
      lockOpen: boolean;
      batteryPercent: number;
      safeStatus: "inactive" | "active" | "maintenance" | "offline";
      voltage: number;
    };
    error?: string;
  }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    try {
      console.log("Reading Pi status...");

      const readPromise = BleClient.read(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID
      );

      const timeout = new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Read timeout")), 10000)
      );

      const result = (await Promise.race([readPromise, timeout])) as DataView;

      // Parse status bytes
      const statusArray = new Uint8Array(result.buffer);

      // Validate response length - expecting 6 bytes
      if (statusArray.length < 6) {
        return {
          success: false,
          error: "Invalid status response from safe",
        };
      }

      const verified = statusArray[0] === 1;
      const lockOpen = statusArray[1] === 1;
      const batteryPercent = Math.min(100, Math.max(0, statusArray[2]));
      const statusCode = statusArray[3];

      // Reconstruct voltage from two bytes
      const voltageInt = (statusArray[4] << 8) | statusArray[5];
      const voltage = voltageInt / 10.0;

      // Map status code to string
      const statusMap: Record<
        number,
        "inactive" | "active" | "maintenance" | "offline"
      > = {
        0: "inactive",
        1: "active",
        2: "maintenance",
        3: "offline",
      };
      const safeStatus = statusMap[statusCode] || "active";

      console.log("Pi status:", {
        verified,
        lockOpen,
        batteryPercent,
        safeStatus,
        voltage: `${voltage.toFixed(2)}V`,
      });

      return {
        success: true,
        status: {
          verified,
          lockOpen,
          batteryPercent,
          safeStatus,
          voltage,
        },
      };
    } catch (err: any) {
      console.error("Failed to read status:", err);

      // Check if connection was lost
      if (
        err.message?.includes("disconnected") ||
        err.message?.includes("timeout")
      ) {
        this.isConnected = false;
      }

      return { success: false, error: err.message };
    }
  }

  // Subscribe to Pi status changes with reconnection
  async subscribeToPiStatus(
    callback: (status: {
      verified: boolean;
      lockOpen: boolean;
      batteryPercent: number;
      voltage: number;
    }) => void
  ) {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to safe" };
    }

    try {
      await BleClient.startNotifications(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID,
        (value) => {
          try {
            const statusArray = new Uint8Array(value.buffer);

            // Expecting 6 bytes: [verified, lock_open, battery, status, voltage_high, voltage_low]
            if (statusArray.length >= 6) {
              const verified = statusArray[0] === 1;
              const lockOpen = statusArray[1] === 1;
              const batteryPercent = Math.min(100, Math.max(0, statusArray[2]));
              const voltageInt = (statusArray[4] << 8) | statusArray[5];
              const voltage = voltageInt / 10.0;

              console.log("Status notification received:", {
                verified,
                lockOpen,
                batteryPercent,
                voltage: `${voltage.toFixed(1)}V`,
              });
              callback({ verified, lockOpen, batteryPercent, voltage });
            } else {
              console.warn(
                "Invalid status notification length:",
                statusArray.length
              );
            }
          } catch (parseError) {
            console.error("Error parsing notification:", parseError);
          }
        }
      );

      console.log("Subscribed to Pi status updates");
      return { success: true };
    } catch (err: any) {
      console.error("Failed to subscribe:", err);
      return { success: false, error: err.message };
    }
  }

  // Disconnect from Pi with cleanup
  async disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.deviceId) {
      try {
        await BleClient.disconnect(this.deviceId);
        this.isConnected = false;
        this.deviceId = null;
        this.connectionAttempts = 0;
        console.log("Disconnected from Pi");
      } catch (err) {
        console.error("Disconnect error:", err);
      }
    }
  }

  // Get connection status
  isConnectedToPi(): boolean {
    return this.isConnected;
  }

  // Get device configuration
  getConfig(): BluetoothConfig {
    return this.config;
  }

  // Reset connection state (for retry)
  resetConnection() {
    this.connectionAttempts = 0;
    this.deviceId = null;
    this.isConnected = false;
  }
}

export const bluetoothService = new BluetoothService();
</file>

<file path="src/services/geolocation.ts">
interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  timestamp: number;
}

class GeolocationService {
  // Check if we're running in a Capacitor environment
  private isCapacitorAvailable(): boolean {
    return !!(window as any).Capacitor;
  }

  // Get current position with high accuracy
  async getCurrentPosition(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      console.log(
        "Getting location - is Capacitor available?",
        this.isCapacitorAvailable()
      );

      if (this.isCapacitorAvailable()) {
        return await this.getCapacitorLocation();
      } else {
        return await this.getBrowserLocation();
      }
    } catch (err: any) {
      console.error("Geolocation error:", err);
      return { success: false, error: "Failed to get current location" };
    }
  }

  // Use Capacitor geolocation (for mobile apps)
  private async getCapacitorLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      // Import Capacitor dynamically to avoid errors in browser
      const { Geolocation } = await import("@capacitor/geolocation");

      // Check permissions first
      const permissions = await Geolocation.checkPermissions();

      if (permissions.location !== "granted") {
        const requestResult = await Geolocation.requestPermissions();
        if (requestResult.location !== "granted") {
          return { success: false, error: "Location permission denied" };
        }
      }

      // Get position with high accuracy
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000,
      });

      return {
        success: true,
        location: {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy,
          timestamp: position.timestamp,
        },
      };
    } catch (err: any) {
      console.error("Capacitor geolocation error:", err);

      let errorMessage = "Failed to get current location";
      if (err.message.includes("denied")) {
        errorMessage = "Location access denied";
      } else if (err.message.includes("timeout")) {
        errorMessage = "Location request timed out";
      } else if (err.message.includes("unavailable")) {
        errorMessage = "Location services unavailable";
      }

      return { success: false, error: errorMessage };
    }
  }

  // Use browser geolocation API (for web testing)
  private async getBrowserLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    return new Promise((resolve) => {
      if (!navigator.geolocation) {
        resolve({
          success: false,
          error: "Geolocation is not supported by this browser",
        });
        return;
      }

      console.log("Using browser geolocation...");

      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Browser location success:", position.coords);
          resolve({
            success: true,
            location: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            },
          });
        },
        (error) => {
          console.error("Browser location error:", error);

          let errorMessage = "Failed to get current location";
          switch (error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = "Location access denied by user";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = "Location information is unavailable";
              break;
            case error.TIMEOUT:
              errorMessage = "Location request timed out";
              break;
          }

          resolve({ success: false, error: errorMessage });
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 60000,
        }
      );
    });
  }

  // Watch position for continuous tracking
  async watchPosition(
    callback: (location: LocationData) => void
  ): Promise<string | null> {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");

        const watchId = await Geolocation.watchPosition(
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          },
          (position, err) => {
            if (err) {
              console.error("Location watch error:", err);
              return;
            }

            if (position) {
              callback({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp,
              });
            }
          }
        );

        return watchId;
      } else {
        // Browser fallback
        const watchId = navigator.geolocation.watchPosition(
          (position) => {
            callback({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            });
          },
          (error) => {
            console.error("Browser location watch error:", error);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          }
        );

        return watchId.toString();
      }
    } catch (err) {
      console.error("Failed to start location watching:", err);
      return null;
    }
  }

  // Stop watching position
  async clearWatch(watchId: string) {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");
        await Geolocation.clearWatch({ id: watchId });
      } else {
        navigator.geolocation.clearWatch(parseInt(watchId));
      }
    } catch (err) {
      console.error("Failed to clear location watch:", err);
    }
  }
}

export const geolocationService = new GeolocationService();
</file>

<file path="src/services/otp.ts">
import { supabase } from "./supabase";
import { mobileAuthService } from "./auth";

interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}

class OTPService {
  private lastOTPRequest: number = 0;
  private readonly MIN_REQUEST_INTERVAL = 30000; // 30 seconds

  async requestOTP(
    tripId: string,
    location: { latitude: number; longitude: number; accuracy: number }
  ): Promise<OTPResponse> {
    try {
      const now = Date.now();
      if (now - this.lastOTPRequest < this.MIN_REQUEST_INTERVAL) {
        const waitTime = Math.ceil(
          (this.MIN_REQUEST_INTERVAL - (now - this.lastOTPRequest)) / 1000
        );
        return {
          success: false,
          error: `Please wait ${waitTime} seconds before requesting another code`,
        };
      }

      console.log("Requesting OTP for trip:", tripId);

      const sessionToken = await mobileAuthService.getSessionToken();

      console.log("Session token retrieved:", sessionToken ? "YES" : "NO");

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke("mobile-otp", {
        body: {
          session_token: sessionToken, // Pass in body instead of header
          action: "request_otp",
          trip_id: tripId,
          location: location,
        },
      });

      console.log("Edge function response:", data);
      console.log("Edge function error:", error);

      if (error) {
        console.error("OTP request error:", error);
        // Try to extract the error message from the response body if available
        const errorMessage = data?.error || error.message || "Failed to request OTP";
        return {
          success: false,
          error: errorMessage,
        };
      }

      if (!data.success) {
        console.error("OTP request failed:", data.error);
        return { success: false, error: data.error || "Failed to request OTP" };
      }

      this.lastOTPRequest = now;

      console.log("OTP request completed successfully");
      return {
        success: true,
        expires_at: data.expires_at,
      };
    } catch (err: any) {
      console.error("OTP request exception:", err);
      return {
        success: false,
        error: `Failed to request OTP: ${err.message}`,
      };
    }
  }

  async verifyOTP(
    tripId: string,
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      console.log("Verifying OTP for trip:", tripId);

      if (!/^\d{6}$/.test(otpCode)) {
        return { success: false, error: "Invalid OTP format" };
      }

      const sessionToken = await mobileAuthService.getSessionToken();

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke("mobile-otp", {
        body: {
          session_token: sessionToken, // Pass in body instead of header
          action: "verify_otp",
          trip_id: tripId,
          otp_code: otpCode,
        },
      });

      if (error) {
        console.error("OTP verification error:", error);
        // Try to extract the error message from the response body if available
        const errorMessage = data?.error || error.message || "Failed to verify OTP";
        return {
          success: false,
          error: errorMessage,
        };
      }

      if (!data.success) {
        console.error("OTP verification failed:", data.error);
        return {
          success: false,
          error: data.error || "Invalid or expired OTP code",
        };
      }

      console.log("OTP verified successfully");
      return { success: true };
    } catch (err: any) {
      console.error("OTP verification exception:", err);
      return { success: false, error: `Verification failed: ${err.message}` };
    }
  }

  async cleanupExpiredOTPs() {
    try {
      const { error } = await supabase
        .from("trip_otps")
        .delete()
        .lt("expires_at", new Date().toISOString());

      if (error) {
        console.error("OTP cleanup error:", error);
      } else {
        console.log("Expired OTPs cleaned up");
      }
    } catch (err) {
      console.error("OTP cleanup exception:", err);
    }
  }
}

export const otpService = new OTPService();
</file>

<file path="src/services/storage.ts">
import { Preferences } from "@capacitor/preferences";
import { Capacitor } from "@capacitor/core";

/**
 * Secure storage service using Capacitor Preferences
 * Provides persistent storage that works across app restarts
 */
class StorageService {
  async get<T>(key: string): Promise<T | null> {
    try {
      console.log(`[Storage] Getting key: ${key} (platform: ${Capacitor.getPlatform()})`);
      const { value } = await Preferences.get({ key });
      console.log(`[Storage] Got value for ${key}:`, value ? `EXISTS (${value.length} chars)` : "NULL");
      if (value) {
        console.log(`[Storage] First 100 chars:`, value.substring(0, 100));
      }
      return value ? JSON.parse(value) : null;
    } catch (error) {
      console.error(`[Storage] Failed to get ${key} from storage:`, error);
      return null;
    }
  }

  async set(key: string, value: any): Promise<void> {
    try {
      const stringValue = JSON.stringify(value);
      console.log(`[Storage] Setting key: ${key}, value length: ${stringValue.length} (platform: ${Capacitor.getPlatform()})`);
      console.log(`[Storage] First 100 chars:`, stringValue.substring(0, 100));

      await Preferences.set({ key, value: stringValue });
      console.log(`[Storage] Successfully set ${key}`);

      // Verify write immediately
      const { value: verifyValue } = await Preferences.get({ key });

      if (verifyValue === stringValue) {
        console.log(`[Storage] ✓ Verified ${key} was written correctly`);
      } else if (verifyValue) {
        console.error(`[Storage] ✗ WARNING: ${key} was written but data mismatch!`);
      } else {
        console.error(`[Storage] ✗ CRITICAL: ${key} was not persisted at all!`);
      }
    } catch (error) {
      console.error(`[Storage] Failed to set ${key} in storage:`, error);
      throw error; // Re-throw to let caller know
    }
  }

  async remove(key: string): Promise<void> {
    try {
      console.log(`[Storage] Removing key: ${key}`);
      await Preferences.remove({ key });
      console.log(`[Storage] Successfully removed ${key}`);
    } catch (error) {
      console.error(`[Storage] Failed to remove ${key} from storage:`, error);
    }
  }

  async clear(): Promise<void> {
    try {
      console.log(`[Storage] Clearing all storage`);
      await Preferences.clear();
      console.log(`[Storage] Successfully cleared storage`);
    } catch (error) {
      console.error("[Storage] Failed to clear storage:", error);
    }
  }
}

export const storageService = new StorageService();
</file>

<file path="src/services/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables");
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
  },
});
</file>

<file path="src/services/tracknetics.ts">
import { supabase } from "./supabase";

// Credentials are now handled server-side in Supabase Edge Function
// No need to store them client-side anymore

interface LoginResponse {
  state: string;
  userInfo?: {
    userID: string;
    userName: string;
    loginName: string;
    timeZone: string;
    address: string;
    cellPhone: string;
    key: string;
  };
}

interface DeviceInfo {
  id: string;
  sn: string; // IMEI
  name: string;
  status: string;
  speed?: string;
}

interface LocationData {
  state: string;
  positionTime?: string;
  lat?: string;
  lng?: string;
  speed?: string;
  course?: string;
  isStop?: string;
  stm?: string;
  isGPS?: string;
  status?: string;
}

class TrackneticsService {
  // Credentials removed - now handled server-side in Supabase Edge Function
  private currentSession: { userID?: string; key?: string } | null = null;

  constructor() {
    // No credentials needed client-side anymore
  }

  // Make API call through Supabase Edge Function proxy
  private async apiCall(
    operation: string,
    params: Record<string, any> = {}
  ): Promise<any> {
    try {
      const { data, error } = await supabase.functions.invoke(
        "tracknetics-proxy",
        {
          body: {
            operation,
            params,
          },
        }
      );

      if (error) {
        console.error("Proxy call error:", error);
        throw new Error(`Proxy error: ${error.message}`);
      }

      return data;
    } catch (err) {
      console.error("API call failed:", err);
      throw err;
    }
  }

  // Login and get authentication key
  // Credentials are now handled by the Supabase Edge Function
  async login(): Promise<{ success: boolean; error?: string }> {
    try {
      // Edge Function handles credentials server-side
      const data: LoginResponse = await this.apiCall("Login", {});

      if (data.state === "0" && data.userInfo) {
        this.currentSession = {
          userID: data.userInfo.userID,
          key: data.userInfo.key,
        };
        return { success: true };
      } else {
        console.error("Tracknetics login failed:", data);
        const errorMessage = this.getErrorMessage(data.state);
        return { success: false, error: `Login failed: ${errorMessage}` };
      }
    } catch (error: any) {
      console.error("Tracknetics login error:", error);
      return {
        success: false,
        error: error.message || "Network error during login",
      };
    }
  }

  // Ensure we have a valid session
  private async ensureAuthenticated(): Promise<boolean> {
    if (!this.currentSession?.key) {
      const loginResult = await this.login();
      return loginResult.success;
    }
    return true;
  }

  // Get list of devices
  async getDeviceList(): Promise<{
    success: boolean;
    devices?: DeviceInfo[];
    error?: string;
  }> {
    if (
      !(await this.ensureAuthenticated()) ||
      !this.currentSession?.userID ||
      !this.currentSession?.key
    ) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceList", {
        ID: this.currentSession.userID,
        PageNo: 1,
        PageCount: 100,
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, devices: data.arr || [] };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get devices: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device list:", error);
      return {
        success: false,
        error: error.message || "Network error getting device list",
      };
    }
  }

  // Get real-time location for a device by ID
  async getDeviceLocation(
    deviceId: string
  ): Promise<{ success: boolean; location?: LocationData; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data: LocationData = await this.apiCall("GetTracking", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        MapType: "google",
        Language: "en-us",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, location: data };
      } else if (data.state === "2002") {
        return { success: false, error: "No location data available" };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get location: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device location:", error);
      return {
        success: false,
        error: error.message || "Network error getting location",
      };
    }
  }

  // Get location by device ID (simplified method for direct calls)
  async getLocationByDeviceId(deviceId: string): Promise<{
    success: boolean;
    location?: {
      lat: number;
      lng: number;
      accuracy: number;
      timestamp: number;
    };
    error?: string;
  }> {
    const locationResult = await this.getDeviceLocation(deviceId);

    if (!locationResult.success || !locationResult.location) {
      return { success: false, error: locationResult.error };
    }

    const location = locationResult.location;

    // Convert to standard format
    if (location.lat && location.lng) {
      const standardLocation = {
        lat: parseFloat(location.lat),
        lng: parseFloat(location.lng),
        accuracy: location.isGPS === "1" ? 10 : 100, // GPS vs LBS accuracy estimate
        timestamp: location.positionTime
          ? new Date(location.positionTime).getTime()
          : Date.now(),
      };

      return {
        success: true,
        location: standardLocation,
      };
    }

    return { success: false, error: "Invalid location data received" };
  }

  // Create geofence for delivery location
  async createDeliveryGeofence(
    deviceId: string,
    name: string,
    lat: number,
    lng: number,
    radiusMeters: number = 100
  ): Promise<{ success: boolean; geofenceId?: string; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("SaveGeofence", {
        DeviceID: deviceId,
        GeofenceName: name,
        Remark: "Delivery Location",
        Lat: lat,
        Lng: lng,
        Radius: radiusMeters,
        GeofenceID: 0,
        MapType: "google",
        Key: this.currentSession.key,
      });

      if (data.state === "0") {
        return { success: true, geofenceId: data.geofenceID };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to create geofence: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error creating geofence:", error);
      return {
        success: false,
        error: error.message || "Network error creating geofence",
      };
    }
  }

  // Get device details by ID
  async getDeviceDetails(
    deviceId: string
  ): Promise<{ success: boolean; device?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDeviceDetail", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        Key: this.currentSession.key,
      });
      if (data.state === "0") {
        return { success: true, device: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device details: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device details:", error);
      return {
        success: false,
        error: error.message || "Network error getting device details",
      };
    }
  }

  // Get device history/playback
  async getDeviceHistory(
    deviceId: string,
    startTime: string,
    endTime: string
  ): Promise<{ success: boolean; history?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      const data = await this.apiCall("GetDevicesHistory", {
        DeviceID: deviceId,
        StartTime: startTime,
        EndTime: endTime,
        TimeZones: "South Africa Standard Time",
        ShowLBS: 0,
        MapType: "google",
        SelectCount: 1000,
        Key: this.currentSession.key,
      });
      if (data.state === "0") {
        return { success: true, history: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device history: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device history:", error);
      return {
        success: false,
        error: error.message || "Network error getting device history",
      };
    }
  }

  // Logout
  async logout(): Promise<void> {
    if (this.currentSession?.userID && this.currentSession?.key) {
      try {
        await this.apiCall("Exit", {
          ID: this.currentSession.userID,
          Key: this.currentSession.key,
        });
      } catch (error) {
        console.error("Error during logout:", error);
      }
    }
    this.currentSession = null;
  }

  // Helper to decode Tracknetics error states
  private getErrorMessage(state: string): string {
    const errorCodes: Record<string, string> = {
      "0": "Success",
      "1001": "Parameter error",
      "1002": "Program error",
      "2001": "Username or password error",
      "2002": "No result",
      "2003": "Car number already exists",
      "2004": "Fail to modify",
      "2005": "Modify success",
      "2020": "Username already exists",
      "2021": "It has sub account, cannot be deleted",
      "2022": "It has device, cannot be deleted",
      "2023": "Username does not exist",
      "3001": "KEY incorrect",
      "3004": "Maintenance...",
    };

    return errorCodes[state] || `Unknown error (${state})`;
  }
}

export const trackneticsService = new TrackneticsService();
</file>

<file path="src/services/trips.ts">
import { supabase } from "./supabase";
import { currentUser } from "../store/auth";
import { tripsActions } from "../store/trips";
import { mobileAuthService } from "./auth";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  recipient_name?: string;
  recipient_email?: string;
  recipient_phone?: string;
  recipient_is_client?: boolean;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

class TripsService {
  private subscription: any = null;

  async loadTrips() {
    const user = currentUser.value;
    if (!user?.safe_id) {
      console.log("No user or safe_id found:", user);
      return;
    }

    const sessionToken = await mobileAuthService.getSessionToken();
    if (!sessionToken) {
      console.log("Session expired, logging out");
      await mobileAuthService.logout();
      return;
    }

    console.log("Loading trips for safe_id:", user.safe_id);
    tripsActions.setLoading(true);

    try {
      const { data, error } = await supabase
        .from("trips")
        .select("*")
        .eq("safe_id", user.safe_id)
        .in("status", ["pending", "in_transit", "at_location"])
        .order("scheduled_pickup", { ascending: true });

      console.log("Trips query result:", data);
      console.log("Trips query error:", error);

      if (error) {
        console.error("Failed to load trips:", error);

        if (error.code === "PGRST301" || error.message?.includes("JWT")) {
          console.log("Session invalid, logging out");
          await mobileAuthService.logout();
          return;
        }

        tripsActions.setError("Failed to load trips");
        return;
      }

      console.log(`Found ${data?.length || 0} trips`);
      tripsActions.setTrips(data || []);
    } catch (err) {
      console.error("Exception loading trips:", err);
      tripsActions.setError("Failed to load trips");
    } finally {
      tripsActions.setLoading(false);
    }
  }
  async startTrip(tripId: string) {
    try {
      const sessionToken = await mobileAuthService.getSessionToken();

      const { data, error } = await supabase.functions.invoke(
        "mobile-trip-action",
        {
          headers: {
            "x-session-token": sessionToken || "",
          },
          body: {
            action: "start_trip",
            trip_id: tripId,
          },
        }
      );

      if (error || !data.success) {
        console.error("Failed to start trip:", error || data.error);
        return {
          success: false,
          error: data?.error || error?.message || "Failed to start trip",
        };
      }

      tripsActions.updateTrip(tripId, data.trip);
      await this.logActivity("trip_started", tripId, "Trip started");

      return { success: true, trip: data.trip };
    } catch (err: any) {
      console.error("Error starting trip:", err);
      return { success: false, error: "Failed to start trip" };
    }
  }

  async completeTrip(tripId: string) {
    console.log("Attempting to complete trip:", tripId);

    try {
      const sessionToken = await mobileAuthService.getSessionToken();

      if (!sessionToken) {
        return {
          success: false,
          error: "Session expired. Please login again.",
        };
      }

      const { data, error } = await supabase.functions.invoke(
        "mobile-trip-action",
        {
          headers: {
            "x-session-token": sessionToken,
          },
          body: {
            action: "complete_trip",
            trip_id: tripId,
          },
        }
      );

      console.log("Complete trip response:", data);
      console.log("Complete trip error:", error);

      if (error) {
        console.error("Edge function error:", error);
        return {
          success: false,
          error: error.message || "Failed to complete trip",
        };
      }

      if (!data.success) {
        console.error("Failed to complete trip:", data.error);
        return {
          success: false,
          error: data.error || "Failed to complete trip",
        };
      }

      console.log("Trip completed successfully!");

      // Send delivery confirmation to CLIENT
      if (data.trip.client_email) {
        console.log(
          "Sending delivery confirmation to client:",
          data.trip.client_email
        );

        try {
          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
          const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

          const response = await fetch(
            `${supabaseUrl}/functions/v1/send-delivery-confirmation`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
              body: JSON.stringify({
                to: data.trip.client_email,
                client_name: data.trip.client_name,
                recipient_name:
                  data.trip.recipient_name || data.trip.client_name,
                trip_id: data.trip.id,
                delivery_address: data.trip.delivery_address,
                delivered_at: data.trip.actual_delivery_time,
              }),
            }
          );

          if (response.ok) {
            console.log("Delivery confirmation sent to client");
          } else {
            console.warn(
              "Delivery confirmation failed:",
              await response.text()
            );
          }
        } catch (emailError) {
          console.warn("Could not send delivery confirmation:", emailError);
          // Don't block on email failure
        }
      }

      tripsActions.updateTrip(tripId, data.trip);

      // Log audit trail
      await this.logActivity(
        "trip_completed",
        tripId,
        "Trip completed and safe unlocked"
      );

      return { success: true, trip: data.trip };
    } catch (err: any) {
      console.error("Exception completing trip:", err);
      return {
        success: false,
        error: "Failed to complete trip. Please try again.",
      };
    }
  }

  async updateTripStatus(tripId: string, status: string) {
    try {
      const sessionToken = await mobileAuthService.getSessionToken();
      if (!sessionToken) {
        return { success: false, error: "Session expired" };
      }

      const { data, error } = await supabase.functions.invoke(
        "mobile-trip-action",
        {
          headers: {
            "x-session-token": sessionToken,
          },
          body: {
            action: "update_status",
            trip_id: tripId,
            status: status,
          },
        }
      );

      if (error || !data.success) {
        return { success: false, error: data?.error || error?.message };
      }

      tripsActions.updateTrip(tripId, data.trip);
      return { success: true, trip: data.trip };
    } catch (err: any) {
      return { success: false, error: err.message };
    }
  }

  async addDeliveryNotes(tripId: string, notes: string) {
    try {
      const sessionToken = await mobileAuthService.getSessionToken();
      if (!sessionToken) {
        return { success: false, error: "Session expired" };
      }

      const { error } = await supabase
        .from("trips")
        .update({
          delivery_notes: notes.trim(),
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId);

      if (error) {
        return { success: false, error: error.message };
      }

      return { success: true };
    } catch (err: any) {
      return { success: false, error: err.message };
    }
  }

  private async logActivity(event: string, tripId: string, details: string) {
    try {
      const user = currentUser.value;
      await supabase.from("activity_log").insert({
        event,
        user_type: "mobile",
        user_id: user?.username || "unknown",
        safe_id: user?.safe_id,
        trip_id: tripId,
        details,
        success: true,
        created_at: new Date().toISOString(),
      });
    } catch (err) {
      console.error("Failed to log activity:", err);
    }
  }

  setupRealtimeSubscriptions() {
    const user = currentUser.value;
    if (!user?.safe_id) return;

    console.log("Setting up trip subscriptions for safe:", user.safe_id);

    this.subscription = supabase
      .channel("trips-updates")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "trips",
          filter: `safe_id=eq.${user.safe_id}`,
        },
        (payload) => {
          console.log("Trip update received:", payload);

          if (payload.eventType === "INSERT") {
            tripsActions.addTrip(payload.new as TripData);
            this.showTripNotification(payload.new as TripData);
          } else if (payload.eventType === "UPDATE") {
            tripsActions.updateTrip(
              payload.new.id,
              payload.new as Partial<TripData>
            );
          }
        }
      )
      .subscribe((status) => {
        console.log("Realtime subscription status:", status);

        if (status === "CHANNEL_ERROR") {
          console.error("Realtime subscription error");
        }
      });
  }

  private showTripNotification(trip: TripData) {
    if ("Notification" in window && Notification.permission === "granted") {
      new Notification("New Trip Assigned!", {
        body: `Delivery for ${trip.client_name} - ${trip.pickup_address}`,
        icon: "/vite.svg",
      });
    }

    console.log("NEW TRIP ASSIGNED:", trip);
  }

  async requestNotificationPermission() {
    if ("Notification" in window) {
      const permission = await Notification.requestPermission();
      console.log("Notification permission:", permission);
      return permission === "granted";
    }
    return false;
  }

  cleanup() {
    if (this.subscription) {
      supabase.removeChannel(this.subscription);
    }
  }
}

export const tripsService = new TripsService();
</file>

<file path="src/store/auth.ts">
import { signal, computed } from "@preact/signals";

interface MobileUser {
  id: string;
  username: string;
  driver_name?: string;
  safe_id: string;
  safe: {
    id: string;
    serial_number: string;
    status: string;
    battery_level: number;
    is_locked: boolean;
    tracking_device_id?: string;
  } | null; // Allow null
  is_active: boolean;
  created_at: string;
}

interface MobileAuthState {
  user: MobileUser | null;
  loading: boolean;
  isAuthenticated: boolean;
}

// Auth state signal
export const authState = signal<MobileAuthState>({
  user: null,
  loading: true,
  isAuthenticated: false,
});

// Computed values
export const currentUser = computed(() => authState.value.user);
export const currentSafe = computed(() => authState.value.user?.safe || null);
export const isAuthenticated = computed(() => authState.value.isAuthenticated);
export const isLoading = computed(() => authState.value.loading);

// Auth actions
export const authActions = {
  setUser: (user: MobileUser | null) => {
    authState.value = {
      user,
      loading: false,
      isAuthenticated: !!user,
    };
  },

  setLoading: (loading: boolean) => {
    authState.value = {
      ...authState.value,
      loading,
    };
  },

  logout: () => {
    authState.value = {
      user: null,
      loading: false,
      isAuthenticated: false,
    };
  },

  updateUser: (updates: Partial<MobileUser>) => {
    if (authState.value.user) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          ...updates,
        },
      };
    }
  },

  updateSafe: (safeUpdates: Partial<NonNullable<MobileUser["safe"]>>) => {
    if (authState.value.user && authState.value.user.safe) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          safe: {
            ...authState.value.user.safe,
            ...safeUpdates,
          },
        },
      };
    }
  },
};
</file>

<file path="src/store/trips.ts">
import { signal, computed } from "@preact/signals";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "at_location" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

interface TripsState {
  trips: TripData[];
  loading: boolean;
  error: string | null;
  activeTrip: TripData | null;
}

// Trips state
export const tripsState = signal<TripsState>({
  trips: [],
  loading: false,
  error: null,
  activeTrip: null,
});

// Computed values
export const currentTrips = computed(() => tripsState.value.trips);
export const activeTrip = computed(() => tripsState.value.activeTrip);
export const isLoading = computed(() => tripsState.value.loading);
export const error = computed(() => tripsState.value.error);

// Get pending trips (not started yet)
export const pendingTrips = computed(() =>
  tripsState.value.trips.filter((trip) => trip.status === "pending")
);

// Get in-transit trip (should only be one)
export const inTransitTrip = computed(() =>
  tripsState.value.trips.find(
    (trip) => trip.status === "in_transit" || trip.status === "at_location"
  )
);

// Actions
export const tripsActions = {
  setTrips: (trips: TripData[]) => {
    tripsState.value = {
      ...tripsState.value,
      trips,
      error: null,
      // Set active trip to in-transit or next pending
      activeTrip:
        trips.find((t) => t.status === "in_transit") ||
        trips.find((t) => t.status === "pending") ||
        null,
    };
  },

  addTrip: (trip: TripData) => {
    const newTrips = [...tripsState.value.trips, trip];
    tripsState.value = {
      ...tripsState.value,
      trips: newTrips,
      activeTrip:
        trip.status === "pending" && !tripsState.value.activeTrip
          ? trip
          : tripsState.value.activeTrip,
    };
  },

  updateTrip: (tripId: string, updates: Partial<TripData>) => {
    const updatedTrips = tripsState.value.trips.map((trip) =>
      trip.id === tripId ? { ...trip, ...updates } : trip
    );

    tripsState.value = {
      ...tripsState.value,
      trips: updatedTrips,
      activeTrip:
        tripsState.value.activeTrip?.id === tripId
          ? { ...tripsState.value.activeTrip, ...updates }
          : tripsState.value.activeTrip,
    };
  },

  setActiveTrip: (trip: TripData | null) => {
    tripsState.value = {
      ...tripsState.value,
      activeTrip: trip,
    };
  },

  setLoading: (loading: boolean) => {
    tripsState.value = {
      ...tripsState.value,
      loading,
    };
  },

  setError: (error: string | null) => {
    tripsState.value = {
      ...tripsState.value,
      error,
      loading: false,
    };
  },

  clearError: () => {
    tripsState.value = {
      ...tripsState.value,
      error: null,
    };
  },
};
</file>

<file path="src/types/index.ts">
export type UserRole = "owner" | "admin";

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
}

export interface Safe {
  id: string;
  serial_number: string;
  device_hash: string;
  status: "active" | "inactive" | "maintenance" | "offline";
  battery_level: number;
  is_locked: boolean;
  tracking_device_id?: string;
  assigned_to: string;
  last_update?: string;
}

export interface Trip {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "at_location" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

// Mobile-specific types
export interface BluetoothDevice {
  deviceId: string;
  name: string;
  connected: boolean;
}

export interface OTPRequest {
  trip_id: string;
  location: {
    latitude: number;
    longitude: number;
    accuracy: number;
  };
  timestamp: string;
}

export interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}
</file>

<file path="src/utils/validation.ts">
// OTP validation
export function validateOTP(otp: string): { valid: boolean; error?: string } {
  if (!otp || typeof otp !== "string") {
    return { valid: false, error: "OTP is required" };
  }

  const cleaned = otp.trim();

  if (!/^\d{6}$/.test(cleaned)) {
    return { valid: false, error: "OTP must be exactly 6 digits" };
  }

  return { valid: true };
}

// Username validation
export function validateUsername(username: string): {
  valid: boolean;
  error?: string;
} {
  if (!username || typeof username !== "string") {
    return { valid: false, error: "Username is required" };
  }

  const trimmed = username.trim();

  if (trimmed.length < 3) {
    return { valid: false, error: "Username must be at least 3 characters" };
  }

  if (trimmed.length > 50) {
    return { valid: false, error: "Username is too long" };
  }

  return { valid: true };
}

// Password validation
export function validatePassword(password: string): {
  valid: boolean;
  error?: string;
} {
  if (!password || typeof password !== "string") {
    return { valid: false, error: "Password is required" };
  }

  if (password.length < 4) {
    return { valid: false, error: "Password must be at least 4 characters" };
  }

  if (password.length > 128) {
    return { valid: false, error: "Password is too long" };
  }

  return { valid: true };
}

// Sanitize text input
export function sanitizeText(text: string, maxLength: number = 500): string {
  if (!text || typeof text !== "string") {
    return "";
  }

  return text.trim().slice(0, maxLength).replace(/[<>]/g, ""); // Remove angle brackets
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import preact from "@preact/preset-vite";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact(), tailwindcss()],
  define: {
    global: "globalThis",
  },
  server: {
    host: "0.0.0.0",
    port: 5174,
  },
});
</file>

</files>
