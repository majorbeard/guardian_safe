This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
android/.gitignore
android/app/.gitignore
android/app/build.gradle
android/app/capacitor.build.gradle
android/app/proguard-rules.pro
android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java
android/app/src/main/AndroidManifest.xml
android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java
android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml
android/app/src/main/res/drawable/ic_launcher_background.xml
android/app/src/main/res/layout/activity_main.xml
android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
android/app/src/main/res/values/ic_launcher_background.xml
android/app/src/main/res/values/strings.xml
android/app/src/main/res/values/styles.xml
android/app/src/main/res/xml/file_paths.xml
android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java
android/build.gradle
android/capacitor.settings.gradle
android/gradle.properties
android/gradle/wrapper/gradle-wrapper.properties
android/gradlew
android/gradlew.bat
android/settings.gradle
android/variables.gradle
capacitor.config.ts
index.html
package.json
public/vite.svg
src/app.tsx
src/components/LoadingSpinner.tsx
src/components/OTPGenerator.tsx
src/components/TripCard.tsx
src/index.css
src/main.tsx
src/screens/DashboardScreen.tsx
src/screens/DeliveryScreen.tsx
src/screens/LoginScreen.tsx
src/services/audit.ts
src/services/auth.ts
src/services/bluetooth.ts
src/services/geolocation.ts
src/services/otp.ts
src/services/supabase.ts
src/services/tracknetics.ts
src/services/trips.ts
src/store/auth.ts
src/store/trips.ts
src/types/index.ts
src/vite-env.d.ts
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Environment variables
.env
.env.local
.env.production

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="android/.gitignore">
# Using Android gitignore template: https://github.com/github/gitignore/blob/HEAD/Android.gitignore

# Built application files
*.apk
*.aar
*.ap_
*.aab

# Files for the ART/Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/
out/
#  Uncomment the following line in case you need and you don't have the release build type files in your app
# release/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
proguard/

# Log Files
*.log

# Android Studio Navigation editor temp files
.navigation/

# Android Studio captures folder
captures/

# IntelliJ
*.iml
.idea/workspace.xml
.idea/tasks.xml
.idea/gradle.xml
.idea/assetWizardSettings.xml
.idea/dictionaries
.idea/libraries
# Android Studio 3 in .gitignore file.
.idea/caches
.idea/modules.xml
# Comment next line if keeping position of elements in Navigation Editor is relevant for you
.idea/navEditor.xml

# Keystore files
# Uncomment the following lines if you do not want to check your keystore files in.
#*.jks
#*.keystore

# External native build folder generated in Android Studio 2.2 and later
.externalNativeBuild
.cxx/

# Google Services (e.g. APIs or Firebase)
# google-services.json

# Freeline
freeline.py
freeline/
freeline_project_description.json

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots
fastlane/test_output
fastlane/readme.md

# Version control
vcs.xml

# lint
lint/intermediates/
lint/generated/
lint/outputs/
lint/tmp/
# lint/reports/

# Android Profiling
*.hprof

# Cordova plugins for Capacitor
capacitor-cordova-android-plugins

# Copied web assets
app/src/main/assets/public

# Generated Config files
app/src/main/assets/capacitor.config.json
app/src/main/assets/capacitor.plugins.json
app/src/main/res/xml/config.xml
</file>

<file path="android/app/.gitignore">
/build/*
!/build/.npmkeep
</file>

<file path="android/app/build.gradle">
apply plugin: 'com.android.application'

android {
    namespace "com.guardiansafe.mobile"
    compileSdk rootProject.ext.compileSdkVersion
    defaultConfig {
        applicationId "com.guardiansafe.mobile"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        aaptOptions {
             // Files and dirs to omit from the packaged assets dir, modified to accommodate modern web apps.
             // Default: https://android.googlesource.com/platform/frameworks/base/+/282e181b58cf72b6ca770dc7ca5f91f135444502/tools/aapt/AaptAssets.cpp#61
            ignoreAssetsPattern '!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~'
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

repositories {
    flatDir{
        dirs '../capacitor-cordova-android-plugins/src/main/libs', 'libs'
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation "androidx.appcompat:appcompat:$androidxAppCompatVersion"
    implementation "androidx.coordinatorlayout:coordinatorlayout:$androidxCoordinatorLayoutVersion"
    implementation "androidx.core:core-splashscreen:$coreSplashScreenVersion"
    implementation project(':capacitor-android')
    testImplementation "junit:junit:$junitVersion"
    androidTestImplementation "androidx.test.ext:junit:$androidxJunitVersion"
    androidTestImplementation "androidx.test.espresso:espresso-core:$androidxEspressoCoreVersion"
    implementation project(':capacitor-cordova-android-plugins')
}

apply from: 'capacitor.build.gradle'

try {
    def servicesJSON = file('google-services.json')
    if (servicesJSON.text) {
        apply plugin: 'com.google.gms.google-services'
    }
} catch(Exception e) {
    logger.info("google-services.json not found, google-services plugin not applied. Push Notifications won't work")
}
</file>

<file path="android/app/capacitor.build.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

android {
  compileOptions {
      sourceCompatibility JavaVersion.VERSION_21
      targetCompatibility JavaVersion.VERSION_21
  }
}

apply from: "../capacitor-cordova-android-plugins/cordova.variables.gradle"
dependencies {
    implementation project(':capacitor-community-bluetooth-le')
    implementation project(':capacitor-geolocation')
    implementation project(':capacitor-haptics')
    implementation project(':capacitor-status-bar')

}


if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
</file>

<file path="android/app/proguard-rules.pro">
# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile
</file>

<file path="android/app/src/androidTest/java/com/getcapacitor/myapp/ExampleInstrumentedTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import android.content.Context;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Instrumented test, which will execute on an Android device.
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
@RunWith(AndroidJUnit4.class)
public class ExampleInstrumentedTest {

    @Test
    public void useAppContext() throws Exception {
        // Context of the app under test.
        Context appContext = InstrumentationRegistry.getInstrumentation().getTargetContext();

        assertEquals("com.getcapacitor.app", appContext.getPackageName());
    }
}
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme">

        <activity
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|locale|smallestScreenSize|screenLayout|uiMode|navigation"
            android:name=".MainActivity"
            android:label="@string/title_activity_main"
            android:theme="@style/AppTheme.NoActionBarLaunch"
            android:launchMode="singleTask"
            android:exported="true">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

        </activity>

        <provider
            android:name="androidx.core.content.FileProvider"
            android:authorities="${applicationId}.fileprovider"
            android:exported="false"
            android:grantUriPermissions="true">
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/file_paths"></meta-data>
        </provider>
    </application>

    <!-- Permissions -->

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
</manifest>
</file>

<file path="android/app/src/main/java/com/guardiansafe/mobile/MainActivity.java">
package com.guardiansafe.mobile;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {}
</file>

<file path="android/app/src/main/res/drawable-v24/ic_launcher_foreground.xml">
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:aapt="http://schemas.android.com/aapt"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillType="evenOdd"
        android:pathData="M32,64C32,64 38.39,52.99 44.13,50.95C51.37,48.37 70.14,49.57 70.14,49.57L108.26,87.69L108,109.01L75.97,107.97L32,64Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1">
        <aapt:attr name="android:fillColor">
            <gradient
                android:endX="78.5885"
                android:endY="90.9159"
                android:startX="48.7653"
                android:startY="61.0927"
                android:type="linear">
                <item
                    android:color="#44000000"
                    android:offset="0.0" />
                <item
                    android:color="#00000000"
                    android:offset="1.0" />
            </gradient>
        </aapt:attr>
    </path>
    <path
        android:fillColor="#FFFFFF"
        android:fillType="nonZero"
        android:pathData="M66.94,46.02L66.94,46.02C72.44,50.07 76,56.61 76,64L32,64C32,56.61 35.56,50.11 40.98,46.06L36.18,41.19C35.45,40.45 35.45,39.3 36.18,38.56C36.91,37.81 38.05,37.81 38.78,38.56L44.25,44.05C47.18,42.57 50.48,41.71 54,41.71C57.48,41.71 60.78,42.57 63.68,44.05L69.11,38.56C69.84,37.81 70.98,37.81 71.71,38.56C72.44,39.3 72.44,40.45 71.71,41.19L66.94,46.02ZM62.94,56.92C64.08,56.92 65,56.01 65,54.88C65,53.76 64.08,52.85 62.94,52.85C61.8,52.85 60.88,53.76 60.88,54.88C60.88,56.01 61.8,56.92 62.94,56.92ZM45.06,56.92C46.2,56.92 47.13,56.01 47.13,54.88C47.13,53.76 46.2,52.85 45.06,52.85C43.92,52.85 43,53.76 43,54.88C43,56.01 43.92,56.92 45.06,56.92Z"
        android:strokeColor="#00000000"
        android:strokeWidth="1" />
</vector>
</file>

<file path="android/app/src/main/res/drawable/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportHeight="108"
    android:viewportWidth="108">
    <path
        android:fillColor="#26A69A"
        android:pathData="M0,0h108v108h-108z" />
    <path
        android:fillColor="#00000000"
        android:pathData="M9,0L9,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,0L19,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,0L29,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,0L39,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,0L49,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,0L59,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,0L69,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,0L79,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M89,0L89,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M99,0L99,108"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,9L108,9"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,19L108,19"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,29L108,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,39L108,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,49L108,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,59L108,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,69L108,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,79L108,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,89L108,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M0,99L108,99"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,29L89,29"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,39L89,39"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,49L89,49"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,59L89,59"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,69L89,69"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M19,79L89,79"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M29,19L29,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M39,19L39,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M49,19L49,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M59,19L59,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M69,19L69,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
    <path
        android:fillColor="#00000000"
        android:pathData="M79,19L79,89"
        android:strokeColor="#33FFFFFF"
        android:strokeWidth="0.8" />
</vector>
</file>

<file path="android/app/src/main/res/layout/activity_main.xml">
<?xml version="1.0" encoding="utf-8"?>
<androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <WebView
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</androidx.coordinatorlayout.widget.CoordinatorLayout>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@mipmap/ic_launcher_foreground"/>
</adaptive-icon>
</file>

<file path="android/app/src/main/res/values/ic_launcher_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#FFFFFF</color>
</resources>
</file>

<file path="android/app/src/main/res/values/strings.xml">
<?xml version='1.0' encoding='utf-8'?>
<resources>
    <string name="app_name">guardian-safe-mobile</string>
    <string name="title_activity_main">guardian-safe-mobile</string>
    <string name="package_name">com.guardiansafe.mobile</string>
    <string name="custom_url_scheme">com.guardiansafe.mobile</string>
</resources>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!-- Base application theme. -->
    <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
        <!-- Customize your theme here. -->
        <item name="colorPrimary">@color/colorPrimary</item>
        <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
        <item name="colorAccent">@color/colorAccent</item>
    </style>

    <style name="AppTheme.NoActionBar" parent="Theme.AppCompat.DayNight.NoActionBar">
        <item name="windowActionBar">false</item>
        <item name="windowNoTitle">true</item>
        <item name="android:background">@null</item>
    </style>


    <style name="AppTheme.NoActionBarLaunch" parent="Theme.SplashScreen">
        <item name="android:background">@drawable/splash</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/xml/file_paths.xml">
<?xml version="1.0" encoding="utf-8"?>
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path name="my_images" path="." />
    <cache-path name="my_cache_images" path="." />
</paths>
</file>

<file path="android/app/src/test/java/com/getcapacitor/myapp/ExampleUnitTest.java">
package com.getcapacitor.myapp;

import static org.junit.Assert.*;

import org.junit.Test;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {

    @Test
    public void addition_isCorrect() throws Exception {
        assertEquals(4, 2 + 2);
    }
}
</file>

<file path="android/build.gradle">
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.7.2'
        classpath 'com.google.gms:google-services:4.4.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

apply from: "variables.gradle"

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</file>

<file path="android/capacitor.settings.gradle">
// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
include ':capacitor-android'
project(':capacitor-android').projectDir = new File('../node_modules/@capacitor/android/capacitor')

include ':capacitor-community-bluetooth-le'
project(':capacitor-community-bluetooth-le').projectDir = new File('../node_modules/@capacitor-community/bluetooth-le/android')

include ':capacitor-geolocation'
project(':capacitor-geolocation').projectDir = new File('../node_modules/@capacitor/geolocation/android')

include ':capacitor-haptics'
project(':capacitor-haptics').projectDir = new File('../node_modules/@capacitor/haptics/android')

include ':capacitor-status-bar'
project(':capacitor-status-bar').projectDir = new File('../node_modules/@capacitor/status-bar/android')
</file>

<file path="android/gradle.properties">
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx1536m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app's APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="android/gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/platforms/jvm/plugins-application/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd -P "${APP_HOME:-./}" > /dev/null && printf '%s
' "$PWD" ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="android/gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="android/settings.gradle">
include ':app'
include ':capacitor-cordova-android-plugins'
project(':capacitor-cordova-android-plugins').projectDir = new File('./capacitor-cordova-android-plugins/')

apply from: 'capacitor.settings.gradle'
</file>

<file path="android/variables.gradle">
ext {
    minSdkVersion = 23
    compileSdkVersion = 35
    targetSdkVersion = 35
    androidxActivityVersion = '1.9.2'
    androidxAppCompatVersion = '1.7.0'
    androidxCoordinatorLayoutVersion = '1.2.0'
    androidxCoreVersion = '1.15.0'
    androidxFragmentVersion = '1.8.4'
    coreSplashScreenVersion = '1.0.1'
    androidxWebkitVersion = '1.12.1'
    junitVersion = '4.13.2'
    androidxJunitVersion = '1.2.1'
    androidxEspressoCoreVersion = '3.6.1'
    cordovaAndroidVersion = '10.1.1'
}
</file>

<file path="capacitor.config.ts">
import { CapacitorConfig } from "@capacitor/cli";

const config: CapacitorConfig = {
  appId: "com.guardiansafe.mobile",
  appName: "guardian-safe-mobile",
  webDir: "dist",
  server: {
    androidScheme: "https",
    // Add this for development
    // url: "http://localhost:5174", // Updated port
    // cleartext: true,
  },
  plugins: {
    BluetoothLe: {
      displayStrings: {
        scanning: "Scanning for Guardian Safe...",
        cancel: "Cancel",
        availableDevices: "Available Safes",
        noDeviceFound: "No Guardian Safe found",
      },
    },
    Geolocation: {
      permissions: {
        location: "always",
      },
    },
  },
};

export default config;
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Guardian Safe - Mobile</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="package.json">
{
  "name": "mobile",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@capacitor-community/bluetooth-le": "^7.2.0",
    "@capacitor/android": "^7.4.3",
    "@capacitor/core": "^7.4.3",
    "@capacitor/geolocation": "^7.1.5",
    "@capacitor/haptics": "^7.0.2",
    "@capacitor/status-bar": "^7.0.3",
    "@preact/signals": "^2.3.1",
    "@supabase/supabase-js": "^2.57.4",
    "@tailwindcss/vite": "^4.1.13",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-preact": "^0.544.0",
    "preact": "^10.26.5",
    "tailwindcss": "^4.1.13"
  },
  "devDependencies": {
    "@capacitor/cli": "^7.4.3",
    "@preact/preset-vite": "^2.10.1",
    "typescript": "~5.8.3",
    "vite": "^6.3.5"
  }
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/app.tsx">
import { useEffect } from "preact/hooks";
// import { Shield } from "lucide-preact";
import { mobileAuthService } from "./services/auth";
import {
  isAuthenticated,
  isLoading,
  // currentUser,
  // currentSafe,
} from "./store/auth";
import { LoginScreen } from "./screens/LoginScreen";
import { DashboardScreen } from "./screens/DashboardScreen";
import { LoadingSpinner } from "./components/LoadingSpinner";

export function App() {
  const authenticated = isAuthenticated.value;
  const loading = isLoading.value;
  // const user = currentUser.value;
  // const safe = currentSafe.value;

  useEffect(() => {
    mobileAuthService.initialize();
  }, []);

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="mt-4 text-gray-600">Connecting to Guardian Safe...</p>
        </div>
      </div>
    );
  }

  if (!authenticated) {
    return <LoginScreen />;
  }

  // Show main dashboard - it handles everything now
  return <DashboardScreen />;
}

export default App;
</file>

<file path="src/components/LoadingSpinner.tsx">
import { clsx } from "clsx";

interface LoadingSpinnerProps {
  size?: "small" | "medium" | "large";
  className?: string;
}

export function LoadingSpinner({
  size = "medium",
  className,
}: LoadingSpinnerProps) {
  const sizeClasses = {
    small: "w-4 h-4",
    medium: "w-6 h-6",
    large: "w-8 h-8",
  };

  return (
    <div
      className={clsx(
        "animate-spin rounded-full border-2 border-gray-300 border-t-blue-600",
        sizeClasses[size],
        className
      )}
    />
  );
}
</file>

<file path="src/components/OTPGenerator.tsx">
import { useState } from "preact/hooks";
import { MapPin, Send, AlertTriangle } from "lucide-preact";
import { LoadingSpinner } from "./LoadingSpinner";

interface OTPGeneratorProps {
  tripId: string;
  onOTPRequested: (expiresAt: string) => void;
  onError: (error: string) => void;
}

export function OTPGenerator({
  // tripId,
  onOTPRequested,
  onError,
}: OTPGeneratorProps) {
  const [requesting, setRequesting] = useState(false);
  const [locationStatus, setLocationStatus] = useState<
    "unknown" | "checking" | "valid" | "invalid"
  >("unknown");

  const handleRequestOTP = async () => {
    setRequesting(true);
    setLocationStatus("checking");

    try {
      // Get current location (placeholder for now)
      /*       const location = {
        latitude: -33.9249,
        longitude: 18.4241,
        accuracy: 10,
      };
 */
      setLocationStatus("valid");

      // Simulate OTP request
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Success callback
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000).toISOString();
      onOTPRequested(expiresAt);
    } catch (error) {
      setLocationStatus("invalid");
      onError("Failed to request OTP. Please try again.");
    } finally {
      setRequesting(false);
    }
  };

  return (
    <div className="bg-white rounded-lg shadow-lg p-6">
      <div className="text-center mb-6">
        <div className="bg-blue-100 rounded-full p-4 w-16 h-16 mx-auto mb-4">
          <Send className="h-8 w-8 text-blue-600" />
        </div>
        <h3 className="text-xl font-semibold text-gray-900 mb-2">
          Request Delivery Code
        </h3>
        <p className="text-gray-600">Send unlock code to recipient via email</p>
      </div>

      {/* Location Status */}
      <div className="bg-gray-50 rounded-lg p-4 mb-6">
        <div className="flex items-center space-x-3">
          <MapPin className="h-5 w-5 text-gray-600" />
          <div className="flex-1">
            <p className="font-medium text-gray-900">Location Status</p>
            <div className="flex items-center space-x-2 mt-1">
              {locationStatus === "checking" && (
                <>
                  <LoadingSpinner size="small" />
                  <span className="text-sm text-gray-600">
                    Checking location...
                  </span>
                </>
              )}
              {locationStatus === "valid" && (
                <span className="text-sm text-green-600">
                  At delivery location
                </span>
              )}
              {locationStatus === "invalid" && (
                <span className="text-sm text-red-600">
                  Location verification failed
                </span>
              )}
              {locationStatus === "unknown" && (
                <span className="text-sm text-gray-600">
                  Location not checked
                </span>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Security Notice */}
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
        <div className="flex items-start space-x-3">
          <AlertTriangle className="h-5 w-5 text-yellow-600 mt-0.5" />
          <div>
            <p className="text-sm font-medium text-yellow-800">
              Security Requirements
            </p>
            <ul className="text-sm text-yellow-700 mt-2 space-y-1">
              <li>• Must be at delivery location</li>
              <li>• Recipient will receive 6-digit code via email</li>
              <li>• Code expires in 10 minutes</li>
              <li>• Verify recipient identity before opening safe</li>
            </ul>
          </div>
        </div>
      </div>

      {/* Request Button */}
      <button
        onClick={handleRequestOTP}
        disabled={requesting}
        className="w-full bg-blue-600 text-white py-4 px-6 rounded-lg font-semibold hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
      >
        {requesting ? (
          <div className="flex items-center justify-center space-x-2">
            <LoadingSpinner size="small" />
            <span>Requesting Code...</span>
          </div>
        ) : (
          <div className="flex items-center justify-center space-x-2">
            <Send className="h-5 w-5" />
            <span>Request Delivery Code</span>
          </div>
        )}
      </button>
    </div>
  );
}
</file>

<file path="src/components/TripCard.tsx">
import { MapPin, Calendar, Clock, AlertTriangle, User } from "lucide-preact";
import { format } from "date-fns";

interface TripCardProps {
  trip: {
    id: string;
    client_name: string;
    pickup_address: string;
    delivery_address: string;
    status: string;
    scheduled_pickup: string;
    scheduled_delivery: string;
    special_instructions?: string;
    priority?: string;
    requires_signature?: boolean;
  };
  onStartTrip?: () => void;
  onViewDetails?: () => void;
}

export function TripCard({ trip, onStartTrip, onViewDetails }: TripCardProps) {
  const getStatusColor = (status: string) => {
    switch (status) {
      case "pending":
        return "bg-blue-100 text-blue-800";
      case "in_transit":
        return "bg-yellow-100 text-yellow-800";
      case "delivered":
        return "bg-green-100 text-green-800";
      default:
        return "bg-gray-100 text-gray-800";
    }
  };

  const getPriorityColor = (priority?: string) => {
    switch (priority) {
      case "urgent":
        return "text-red-600";
      case "high":
        return "text-orange-600";
      case "normal":
        return "text-blue-600";
      case "low":
        return "text-gray-600";
      default:
        return "text-gray-600";
    }
  };

  const isOverdue =
    new Date(trip.scheduled_pickup) < new Date() && trip.status === "pending";

  return (
    <div className="bg-white rounded-lg shadow-md border border-gray-200 overflow-hidden">
      {/* Header */}
      <div className="p-4 bg-gray-50 border-b">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="bg-blue-100 rounded-full p-2">
              <User className="h-5 w-5 text-blue-600" />
            </div>
            <div>
              <h3 className="font-semibold text-gray-900">
                {trip.client_name}
              </h3>
              <p className="text-sm text-gray-500">
                ID: {trip.id.slice(-8).toUpperCase()}
              </p>
            </div>
          </div>
          <div className="text-right">
            <span
              className={`px-2 py-1 rounded-full text-xs font-medium ${getStatusColor(
                trip.status
              )}`}
            >
              {trip.status.replace("_", " ").toUpperCase()}
            </span>
            {trip.priority && trip.priority !== "normal" && (
              <p
                className={`text-xs font-medium mt-1 ${getPriorityColor(
                  trip.priority
                )}`}
              >
                {trip.priority.toUpperCase()} PRIORITY
              </p>
            )}
          </div>
        </div>
      </div>

      {/* Overdue Warning */}
      {isOverdue && (
        <div className="bg-red-50 border-b border-red-200 px-4 py-2">
          <div className="flex items-center space-x-2 text-red-700">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-sm font-medium">
              OVERDUE - Scheduled pickup passed
            </span>
          </div>
        </div>
      )}

      {/* Trip Details */}
      <div className="p-4 space-y-4">
        {/* Pickup */}
        <div className="flex items-start space-x-3">
          <MapPin className="h-5 w-5 text-green-600 mt-0.5 flex-shrink-0" />
          <div className="flex-1">
            <p className="font-medium text-gray-900">Pickup</p>
            <p className="text-sm text-gray-600">{trip.pickup_address}</p>
            <div className="flex items-center space-x-2 mt-1">
              <Calendar className="h-4 w-4 text-gray-400" />
              <span className="text-xs text-gray-500">
                {format(new Date(trip.scheduled_pickup), "MMM d, yyyy")}
              </span>
              <Clock className="h-4 w-4 text-gray-400" />
              <span className="text-xs text-gray-500">
                {format(new Date(trip.scheduled_pickup), "HH:mm")}
              </span>
            </div>
          </div>
        </div>

        {/* Delivery */}
        <div className="flex items-start space-x-3">
          <MapPin className="h-5 w-5 text-red-600 mt-0.5 flex-shrink-0" />
          <div className="flex-1">
            <p className="font-medium text-gray-900">Delivery</p>
            <p className="text-sm text-gray-600">{trip.delivery_address}</p>
            <div className="flex items-center space-x-2 mt-1">
              <Calendar className="h-4 w-4 text-gray-400" />
              <span className="text-xs text-gray-500">
                {format(new Date(trip.scheduled_delivery), "MMM d, yyyy")}
              </span>
              <Clock className="h-4 w-4 text-gray-400" />
              <span className="text-xs text-gray-500">
                {format(new Date(trip.scheduled_delivery), "HH:mm")}
              </span>
            </div>
          </div>
        </div>

        {/* Special Instructions */}
        {trip.special_instructions && (
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3">
            <p className="text-sm font-medium text-yellow-800 mb-1">
              Special Instructions:
            </p>
            <p className="text-sm text-yellow-700">
              {trip.special_instructions}
            </p>
          </div>
        )}

        {/* Requirements */}
        {trip.requires_signature && (
          <div className="flex items-center space-x-2 text-blue-700 bg-blue-50 px-3 py-2 rounded">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-sm font-medium">
              Signature required upon delivery
            </span>
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="p-4 bg-gray-50 border-t space-y-2">
        {trip.status === "pending" && onStartTrip && (
          <button
            onClick={onStartTrip}
            className="w-full bg-blue-600 text-white py-3 px-4 rounded-lg font-medium hover:bg-blue-700 transition-colors"
          >
            Start Trip
          </button>
        )}

        {trip.status === "in_transit" && (
          <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 text-center">
            <p className="text-yellow-800 font-medium">Trip In Progress</p>
            <p className="text-yellow-700 text-sm">
              Proceed to delivery location
            </p>
          </div>
        )}

        {onViewDetails && (
          <button
            onClick={onViewDetails}
            className="w-full bg-gray-100 text-gray-700 py-2 px-4 rounded-lg font-medium hover:bg-gray-200 transition-colors"
          >
            View Details
          </button>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/index.css">
@import "tailwindcss";

@layer base {
  body {
    font-family: system-ui, -apple-system, sans-serif;
    margin: 0;
    padding: 0;
  }
}

/* Mobile-specific styles */
@layer utilities {
  .safe-area-top {
    padding-top: env(safe-area-inset-top);
  }

  .safe-area-bottom {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .mobile-container {
    min-height: 100vh;
    min-height: 100dvh; /* Dynamic viewport height */
  }
}

/* Custom button styles for mobile */
@layer components {
  .btn {
    @apply inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed;
  }

  .btn-primary {
    @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500;
  }

  .btn-secondary {
    @apply bg-gray-100 text-gray-900 hover:bg-gray-200 focus:ring-gray-500;
  }

  .input {
    @apply block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500;
  }
}
</file>

<file path="src/main.tsx">
import { render } from "preact";
import { App } from "./app.tsx";
import "./index.css";

render(<App />, document.getElementById("app")!);
</file>

<file path="src/screens/DashboardScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  LogOut,
  Shield,
  Bell,
  Package,
  AlertTriangle,
  Phone,
} from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { tripsService } from "../services/trips";
import { currentUser, currentSafe } from "../store/auth";
import {
  currentTrips,
  // activeTrip,
  pendingTrips,
  inTransitTrip,
  isLoading,
  error,
} from "../store/trips";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { TripCard } from "../components/TripCard";
import { DeliveryScreen } from "./DeliveryScreen";
import { RefreshCw, Unlock } from "lucide-preact";
import { bluetoothService } from "../services/bluetooth";

export function DashboardScreen() {
  const user = currentUser.value;
  const safe = currentSafe.value;
  const trips = currentTrips.value;
  // const active = activeTrip.value;
  const pending = pendingTrips.value;
  const inTransit = inTransitTrip.value;
  const loading = isLoading.value;
  const tripsError = error.value;

  const [notificationsEnabled, setNotificationsEnabled] = useState(false);
  const [selectedTrip, setSelectedTrip] = useState<any>(null);
  const [, setShowSOS] = useState(false);

  const [piStatus, setPiStatus] = useState<{
    batteryPercent: number;
    safeStatus: string;
    voltage: number;
    lockOpen: boolean;
  } | null>(null);

  const [btConnected, setBtConnected] = useState(false);

  // Effect to initialize Bluetooth and poll status:
  useEffect(() => {
    const initBluetooth = async () => {
      await bluetoothService.initialize();

      // Try to auto-connect if already paired
      const scanResult = await bluetoothService.scanForPi();
      if (scanResult.success) {
        const connectResult = await bluetoothService.connectToPi();
        if (connectResult.success) {
          setBtConnected(true);

          // Get initial status
          const statusResult = await bluetoothService.readPiStatus();
          if (statusResult.success && statusResult.status) {
            setPiStatus({
              batteryPercent: statusResult.status.batteryPercent,
              safeStatus: statusResult.status.safeStatus,
              voltage: statusResult.status.voltage,
              lockOpen: statusResult.status.lockOpen,
            });
          }
        }
      }
    };

    initBluetooth();

    return () => bluetoothService.disconnect();
  }, []);

  // Reffect to poll status every 30 seconds when connected:
  useEffect(() => {
    if (!btConnected) return;

    const pollStatus = async () => {
      const result = await bluetoothService.readPiStatus();
      if (result.success && result.status) {
        setPiStatus({
          batteryPercent: result.status.batteryPercent,
          safeStatus: result.status.safeStatus,
          voltage: result.status.voltage,
          lockOpen: result.status.lockOpen,
        });
      }
    };

    const interval = setInterval(pollStatus, 30000); // Every 30 seconds

    return () => clearInterval(interval);
  }, [btConnected]);

  // Effect to poll Pi status every 30 seconds
  useEffect(() => {
    const pollPiStatus = async () => {
      const result = await bluetoothService.readPiStatus();
      if (result.success && result.status) {
        setPiStatus({
          batteryPercent: result.status.batteryPercent,
          safeStatus: result.status.safeStatus,
          voltage: result.status.voltage,
          lockOpen: result.status.lockOpen,
        });

        // TODO:
        // Update safe in store
        // Dispatch to update the safe state
      }
    };

    // Poll immediately and then every 30 seconds
    pollPiStatus();
    const interval = setInterval(pollPiStatus, 30000);

    return () => clearInterval(interval);
  }, [btConnected]);

  useEffect(() => {
    // Initialize trips service
    tripsService.loadTrips();
    tripsService.setupRealtimeSubscriptions();

    // Request notification permission
    tripsService.requestNotificationPermission().then(setNotificationsEnabled);

    // Cleanup on unmount
    return () => tripsService.cleanup();
  }, []);

  const handleStartTrip = async (tripId: string) => {
    const result = await tripsService.startTrip(tripId);
    if (result.success) {
      console.log("Trip started successfully!");
      // Auto-open delivery screen for in-transit trips
      const trip = trips.find((t) => t.id === tripId);
      if (trip) {
        setSelectedTrip(trip);
      }
    } else {
      console.error("Failed to start trip:", result.error);
    }
  };

  const handleLogout = async () => {
    if (confirm("Are you sure you want to sign out?")) {
      await mobileAuthService.logout();
    }
  };

  const handleSOS = () => {
    setShowSOS(true);
    // In production, this would trigger emergency protocols
    alert(
      "SOS ACTIVATED!\n\nEmergency services have been notified.\nStay safe and follow emergency procedures."
    );
  };

  // Show delivery screen if trip is selected
  if (selectedTrip) {
    return (
      <DeliveryScreen
        trip={selectedTrip}
        onBack={() => setSelectedTrip(null)}
      />
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 safe-area-top safe-area-bottom">
      {/* Header */}
      <div className="bg-white shadow-sm border-b">
        <div className="px-4 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <div className="bg-blue-600 rounded-lg p-2">
                <Shield className="h-6 w-6 text-white" />
              </div>
              <div>
                <h1 className="text-lg font-semibold text-gray-900">
                  Safe {safe?.serial_number}
                </h1>
                <p className="text-sm text-gray-500">
                  {user?.driver_name || user?.username} • {trips.length} Active
                  Trip(s)
                </p>
              </div>
            </div>

            <div className="flex items-center space-x-2">
              {/* SOS Button */}
              <button
                onClick={handleSOS}
                className="bg-red-600 text-white p-2 rounded-lg hover:bg-red-700 transition-colors"
                title="Emergency SOS"
              >
                <Phone className="h-5 w-5" />
              </button>

              {/* Notification Status */}
              <div
                className={`p-2 rounded-lg ${
                  notificationsEnabled ? "bg-green-100" : "bg-gray-100"
                }`}
              >
                <Bell
                  className={`h-5 w-5 ${
                    notificationsEnabled ? "text-green-600" : "text-gray-600"
                  }`}
                />
              </div>

              <button
                onClick={handleLogout}
                className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors"
              >
                <LogOut className="h-5 w-5 text-gray-600" />
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Safe Status */}
      <div className="px-4 py-3 border-b bg-gradient-to-r from-gray-50 to-gray-100">
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4 flex-wrap gap-y-2">
            {/* Bluetooth Connection Status */}
            <div className="flex items-center space-x-2">
              <div
                className={`w-2 h-2 rounded-full ${
                  btConnected ? "bg-blue-500 animate-pulse" : "bg-gray-400"
                }`}
              ></div>
              <span className="text-xs text-gray-600">
                {btConnected ? "Connected" : "Disconnected"}
              </span>
            </div>

            {/* Safe Status */}
            <div className="text-sm">
              <span className="font-medium text-gray-900">Status: </span>
              <span
                className={`font-semibold ${
                  (piStatus?.safeStatus || safe?.status) === "active"
                    ? "text-green-700"
                    : (piStatus?.safeStatus || safe?.status) === "maintenance"
                    ? "text-yellow-700"
                    : (piStatus?.safeStatus || safe?.status) === "inactive"
                    ? "text-gray-700"
                    : "text-red-700"
                }`}
              >
                {(piStatus?.safeStatus || safe?.status)?.toUpperCase()}
              </span>
            </div>

            {/* Battery Level */}
            <div className="text-sm">
              <span className="font-medium text-gray-900">Battery: </span>
              <span
                className={`font-semibold ${
                  (piStatus?.batteryPercent ?? safe?.battery_level ?? 0) > 50
                    ? "text-green-700"
                    : (piStatus?.batteryPercent ?? safe?.battery_level ?? 0) >
                      20
                    ? "text-yellow-700"
                    : "text-red-700"
                }`}
              >
                {piStatus?.batteryPercent ?? safe?.battery_level ?? 0}%
              </span>
              {piStatus?.voltage && (
                <span className="text-gray-500 text-xs ml-1">
                  ({piStatus.voltage.toFixed(2)}V)
                </span>
              )}
            </div>

            {/* Lock Status */}
            <div className="text-sm">
              <span className="font-medium text-gray-900">Lock: </span>
              <span
                className={`font-semibold ${
                  piStatus?.lockOpen ?? safe?.is_locked === false
                    ? "text-red-700"
                    : "text-green-700"
                }`}
              >
                {piStatus?.lockOpen ?? safe?.is_locked === false
                  ? "OPEN"
                  : "SECURED"}
              </span>
            </div>
          </div>

          {/* Refresh Button */}
          {btConnected && (
            <button
              onClick={async () => {
                const result = await bluetoothService.readPiStatus();
                if (result.success && result.status) {
                  setPiStatus({
                    batteryPercent: result.status.batteryPercent,
                    safeStatus: result.status.safeStatus,
                    voltage: result.status.voltage,
                    lockOpen: result.status.lockOpen,
                  });
                }
              }}
              className="text-xs text-blue-600 hover:text-blue-800 flex items-center space-x-1"
            >
              <RefreshCw className="h-3 w-3" />
              <span className="hidden sm:inline">Refresh</span>
            </button>
          )}
        </div>

        {/* Low Battery Warning */}
        {(piStatus?.batteryPercent ?? safe?.battery_level ?? 100) < 20 && (
          <div className="mt-2 bg-red-50 border border-red-200 rounded px-3 py-2 flex items-center space-x-2">
            <AlertTriangle className="h-4 w-4 text-red-600" />
            <span className="text-sm text-red-700 font-medium">
              ⚠️ Low Battery Warning -{" "}
              {piStatus?.batteryPercent ?? safe?.battery_level}% remaining
              {piStatus?.voltage && ` (${piStatus.voltage.toFixed(2)}V)`}
            </span>
          </div>
        )}

        {/* Lock Open Warning */}
        {piStatus?.lockOpen && (
          <div className="mt-2 bg-yellow-50 border border-yellow-200 rounded px-3 py-2 flex items-center space-x-2">
            <Unlock className="h-4 w-4 text-yellow-600" />
            <span className="text-sm text-yellow-700 font-medium">
              ⚠️ Safe is currently UNLOCKED
            </span>
          </div>
        )}

        {/* Not Connected to Pi Warning */}
        {!btConnected && (
          <div className="mt-2 bg-gray-50 border border-gray-200 rounded px-3 py-2 flex items-center space-x-2">
            <AlertTriangle className="h-4 w-4 text-gray-600" />
            <span className="text-sm text-gray-700">
              Not connected to safe. Real-time status unavailable.
            </span>
          </div>
        )}
      </div>

      {/* Content */}
      <div className="px-4 py-6 space-y-6">
        {loading ? (
          <div className="flex items-center justify-center py-12">
            <div className="text-center">
              <LoadingSpinner size="large" />
              <p className="mt-4 text-gray-600">Loading trips...</p>
            </div>
          </div>
        ) : (
          <>
            {/* Error Display */}
            {tripsError && (
              <div className="bg-red-50 border border-red-200 rounded-lg p-4">
                <div className="flex items-center space-x-2 text-red-700">
                  <AlertTriangle className="h-4 w-4" />
                  <span className="text-sm font-medium">{tripsError}</span>
                </div>
              </div>
            )}

            {/* In Transit Trip */}
            {inTransit && (
              <div>
                <h2 className="text-lg font-semibold text-gray-900 mb-3 flex items-center">
                  <Package className="h-5 w-5 text-yellow-600 mr-2" />
                  Current Delivery
                </h2>
                <TripCard
                  trip={inTransit}
                  onViewDetails={() => setSelectedTrip(inTransit)}
                />
              </div>
            )}

            {/* Pending Trips */}
            {pending.length > 0 && (
              <div>
                <h2 className="text-lg font-semibold text-gray-900 mb-3 flex items-center">
                  <Package className="h-5 w-5 text-blue-600 mr-2" />
                  Assigned Trips ({pending.length})
                </h2>
                <div className="space-y-4">
                  {pending.map((trip) => (
                    <TripCard
                      key={trip.id}
                      trip={trip}
                      onStartTrip={() => handleStartTrip(trip.id)}
                      onViewDetails={() => setSelectedTrip(trip)}
                    />
                  ))}
                </div>
              </div>
            )}

            {/* No Trips */}
            {trips.length === 0 && !loading && (
              <div className="text-center py-12">
                <Package className="h-16 w-16 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 mb-2">
                  No Active Trips
                </h3>
                <p className="text-gray-500 mb-4">
                  Waiting for trip assignment from dispatch.
                </p>
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <p className="text-sm text-blue-700">
                    You'll receive a notification when a new trip is assigned to
                    your safe.
                  </p>
                </div>
              </div>
            )}

            {/* Quick Actions */}
            <div className="bg-white rounded-lg shadow p-4">
              <h3 className="font-medium text-gray-900 mb-3 flex items-center">
                <Shield className="h-4 w-4 text-blue-600 mr-2" />
                Quick Actions
              </h3>
              <div className="grid grid-cols-2 gap-3">
                <button
                  onClick={() => tripsService.loadTrips()}
                  className="bg-blue-50 text-blue-700 py-2 px-3 rounded-lg text-sm font-medium hover:bg-blue-100 transition-colors"
                >
                  Refresh Trips
                </button>
                <button
                  onClick={handleSOS}
                  className="bg-red-50 text-red-700 py-2 px-3 rounded-lg text-sm font-medium hover:bg-red-100 transition-colors"
                >
                  Emergency SOS
                </button>
              </div>
            </div>

            {/* Status & Tips */}
            <div className="bg-gray-100 rounded-lg p-4">
              <h3 className="font-medium text-gray-900 mb-2 flex items-center">
                <AlertTriangle className="h-4 w-4 text-gray-600 mr-2" />
                Driver Guidelines
              </h3>
              <ul className="text-sm text-gray-600 space-y-1">
                <li>
                  • Ensure safe battery is above 20% before starting trips
                </li>
                <li>• Keep phone charged and connected for GPS tracking</li>
                <li>
                  • Always verify recipient identity before unlocking safe
                </li>
                <li>• Use SOS button for any emergency situations</li>
                <li>• Contact dispatch: +27 (61) 140 2806</li>
              </ul>
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/screens/DeliveryScreen.tsx">
import { useState, useEffect } from "preact/hooks";
import {
  ArrowLeft,
  MapPin,
  Clock,
  User,
  AlertTriangle,
  CheckCircle,
  Mail,
  Smartphone,
  Shield,
} from "lucide-preact";
import { tripsService } from "../services/trips";
// import { geolocationService } from "../services/geolocation";
import { otpService } from "../services/otp";
import { LoadingSpinner } from "../components/LoadingSpinner";
import { format } from "date-fns";
import { bluetoothService } from "../services/bluetooth";

interface DeliveryScreenProps {
  trip: {
    id: string;
    client_name: string;
    client_email?: string;
    pickup_address: string;
    delivery_address: string;
    status: string;
    scheduled_pickup: string;
    scheduled_delivery: string;
    special_instructions?: string;
    priority?: string;
    requires_signature?: boolean;
  };
  onBack: () => void;
}

export function DeliveryScreen({ trip, onBack }: DeliveryScreenProps) {
  // State management
  const [currentStep, setCurrentStep] = useState<
    "travel" | "location" | "otp_request" | "otp_enter" | "complete"
  >("travel");
  const [location, setLocation] = useState<{
    latitude: number;
    longitude: number;
    accuracy: number;
  } | null>(null);
  const [otpCode, setOtpCode] = useState("");
  const [otpExpires, setOtpExpires] = useState<Date | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<number>(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [btConnected, setBtConnected] = useState(false);
  /*   const [piStatus, setPiStatus] = useState<{
    verified: boolean;
    lockOpen: boolean;
  } | null>(null); */

  // Bluetooth initialization
  useEffect(() => {
    initializeBluetooth();
    return () => bluetoothService.disconnect();
  }, []);

  // Timer for OTP expiration
  useEffect(() => {
    if (otpExpires) {
      const timer = setInterval(() => {
        const remaining = Math.max(0, otpExpires.getTime() - Date.now());
        setTimeRemaining(remaining);

        if (remaining === 0) {
          setCurrentStep("otp_request");
          setOtpExpires(null);
          setError("OTP expired. Please request a new code.");
        }
      }, 1000);

      return () => clearInterval(timer);
    }
  }, [otpExpires]);

  // Step 1: Driver says they've arrived
  // Step 1: Driver says they've arrived
  const handleArrived = async () => {
    console.log("✅ Driver says they've arrived at delivery location");

    // Show location verification step
    setCurrentStep("location");
    setLoading(true);

    try {
      // Get current location first
      await getCurrentLocation();

      // Send arrival notification to recipient
      if (trip.recipient_email) {
        console.log(
          "📧 Sending arrival notification to recipient:",
          trip.recipient_email
        );

        try {
          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
          const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

          const response = await fetch(
            `${supabaseUrl}/functions/v1/send-recipient-arrival`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
              body: JSON.stringify({
                to: trip.recipient_email,
                recipient_name: trip.recipient_name || trip.client_name,
                client_name: trip.client_name,
                delivery_address: trip.delivery_address,
                trip_id: trip.id,
                driver_name: user?.driver_name || user?.username,
                safe_serial: safe?.serial_number,
              }),
            }
          );

          if (response.ok) {
            const result = await response.json();
            console.log("✅ Arrival notification sent:", result);
          } else {
            console.warn(
              "⚠️ Arrival notification failed:",
              await response.text()
            );
            // Don't block on email failure
          }
        } catch (emailError) {
          console.warn("⚠️ Could not send arrival notification:", emailError);
          // Don't block delivery flow if email fails
        }
      } else {
        console.log("ℹ️ No recipient email - skipping arrival notification");
      }
    } catch (err) {
      console.error("❌ Error in arrival flow:", err);
      setError("Failed to verify location. Please try again.");
      setCurrentStep("travel");
    } finally {
      setLoading(false);
    }
  };

  // Step 2: Get current location
  // Step 2: Get current location
  const getCurrentLocation = async () => {
    console.log("📍 Getting current location...");
    setLoading(true);
    setError("");

    try {
      // Simulate loading delay
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // FOR TESTING: Use mock Cape Town coordinates
      const mockLocation = {
        latitude: -33.9249, // Cape Town
        longitude: 18.4241,
        accuracy: 10, // 10 meter accuracy
        timestamp: Date.now(),
      };

      console.log("📍 Using mock location for testing:", mockLocation);
      setLocation(mockLocation);

      // Move to OTP request step
      setCurrentStep("otp_request");

      console.log("✅ Location verified, ready for OTP request");

      // TODO: Replace with real location when testing on HTTPS:
      /*
    const result = await geolocationService.getCurrentPosition()
    
    if (result.success && result.location) {
      console.log("Location obtained:", result.location)
      setLocation(result.location)
      setCurrentStep('otp_request')
    } else {
      console.error("Location failed:", result.error)
      setError(result.error || 'Failed to get location')
      setCurrentStep('travel')
    }
    */
    } catch (err) {
      console.error("📍 Location exception:", err);
      setError("Location access required for delivery");
      setCurrentStep("travel");
    } finally {
      setLoading(false);
    }
  };

  // Step 3: Request OTP via email
  const handleRequestOTP = async () => {
    if (!location) {
      setError("Location required to request OTP");
      return;
    }

    console.log("🔐 Requesting OTP for trip:", trip.id);
    console.log(
      "📧 OTP will be sent to:",
      trip.recipient_email || trip.client_email
    );

    setLoading(true);
    setError("");

    try {
      const result = await otpService.requestOTP(trip.id, location);

      if (result.success) {
        console.log("✅ OTP requested successfully");
        setCurrentStep("otp_enter");
        if (result.expires_at) {
          setOtpExpires(new Date(result.expires_at));
        }
      } else {
        console.error("❌ OTP request failed:", result.error);
        setError(result.error || "Failed to request OTP");
      }
    } catch (err) {
      console.error("💥 OTP request exception:", err);
      setError("Failed to request OTP. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  // Step 4: Verify OTP and complete delivery
  const handleVerifyOTP = async () => {
    if (otpCode.length !== 6) {
      setError("Please enter a 6-digit code");
      return;
    }

    setLoading(true);
    setError("");

    try {
      // Step 1: Check Bluetooth connection
      if (!bluetoothService.isConnectedToPi()) {
        setError("Connecting to safe...");

        // Initialize if needed
        await bluetoothService.initialize();

        // Scan for Pi
        const scanResult = await bluetoothService.scanForPi();
        if (!scanResult.success) {
          setError("Cannot find safe. Make sure you are near the safe.");
          setLoading(false);
          return;
        }

        // Connect
        const connectResult = await bluetoothService.connectToPi();
        if (!connectResult.success) {
          setError("Failed to connect to safe via Bluetooth");
          setLoading(false);
          return;
        }
        setBtConnected(true);
      }

      // Step 2: Verify OTP with server
      const otpResult = await otpService.verifyOTP(trip.id, otpCode);

      if (!otpResult.success) {
        setError(otpResult.error || "Invalid OTP code");
        setOtpCode("");
        setLoading(false);
        return;
      }

      console.log("Server verified OTP!");

      // Step 3: Send OTP to Pi for physical unlock
      console.log("Sending OTP to safe...");
      const piResult = await bluetoothService.sendOTPToPi(otpCode);

      if (!piResult.success) {
        setError("Failed to unlock safe");
        setLoading(false);
        return;
      }

      // Step 4: Wait for Pi to verify and open lock
      await new Promise((resolve) => setTimeout(resolve, 2000));

      const statusResult = await bluetoothService.readPiStatus();
      if (!statusResult.success || !statusResult.status) {
        setError("Failed to verify safe status");
        setLoading(false);
        return;
      }

      if (!statusResult.status.verified || !statusResult.status.lockOpen) {
        setError("Safe failed to unlock. Please try again.");
        setLoading(false);
        return;
      }

      console.log("Safe unlocked!");

      // Step 5: Complete the trip in database
      const tripResult = await tripsService.completeTrip(trip.id);

      if (tripResult.success) {
        console.log("Delivery completed!");
        setCurrentStep("complete");
      } else {
        setError(tripResult.error || "Failed to complete delivery");
      }
    } catch (err) {
      console.error("Verify OTP exception:", err);
      setError("Failed to complete delivery");
    } finally {
      setLoading(false);
    }
  };

  // Utility functions
  const formatTime = (ms: number): string => {
    const minutes = Math.floor(ms / 60000);
    const seconds = Math.floor((ms % 60000) / 1000);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  const handleOTPInput = (value: string) => {
    const cleanValue = value.replace(/\D/g, "").slice(0, 6);
    setOtpCode(cleanValue);
    setError("");
  };

  // Render functions for each step
  const renderTravelStep = () => (
    <div className="text-center space-y-6">
      <div className="bg-blue-100 rounded-full p-4 w-16 h-16 mx-auto flex items-center justify-center">
        <MapPin className="h-8 w-8 text-blue-600" />
      </div>
      <h3 className="text-lg font-semibold text-gray-900">
        En Route to Delivery
      </h3>
      <p className="text-gray-600">
        Proceed to the delivery location. When you arrive, tap the button below.
      </p>
      <button
        onClick={handleArrived}
        className="bg-blue-600 text-white py-3 px-8 rounded-lg font-medium hover:bg-blue-700 transition-colors"
      >
        I've Arrived at Delivery Location
      </button>
    </div>
  );

  const renderLocationStep = () => (
    <div className="text-center space-y-4">
      <div className="bg-green-100 rounded-full p-4 w-16 h-16 mx-auto flex items-center justify-center">
        <MapPin className="h-8 w-8 text-green-600" />
      </div>
      <h3 className="text-lg font-semibold text-gray-900">
        Verifying Location
      </h3>
      <p className="text-gray-600">Getting your GPS coordinates...</p>
      <div className="flex items-center justify-center space-x-2">
        <LoadingSpinner size="small" />
        <span className="text-gray-600">Please wait...</span>
      </div>
    </div>
  );

  const renderOTPRequestStep = () => {
    const recipientName = trip.recipient_name || trip.client_name;
    const recipientEmail = trip.recipient_email || trip.client_email;
    const isClientReceiving =
      trip.recipient_is_client || trip.recipient_email === trip.client_email;

    return (
      <div className="text-center space-y-6">
        {/* Location Verified Badge */}
        <div className="bg-green-50 border-2 border-green-500 rounded-lg p-4 mb-4">
          <div className="flex items-center justify-center space-x-2 mb-2">
            <MapPin className="h-6 w-6 text-green-600" />
            <CheckCircle className="h-6 w-6 text-green-600" />
          </div>
          <h4 className="font-bold text-green-800 mb-1">✓ Location Verified</h4>
          <p className="text-sm text-green-700">
            You are at the delivery location
          </p>
          {location && (
            <p className="text-xs text-green-600 mt-2">
              GPS Accuracy: ±{Math.round(location.accuracy)}m
            </p>
          )}
        </div>

        <div className="bg-orange-100 rounded-full p-4 w-16 h-16 mx-auto flex items-center justify-center">
          <Mail className="h-8 w-8 text-orange-600" />
        </div>

        <h3 className="text-lg font-semibold text-gray-900">
          Ready to Request Unlock Code
        </h3>

        {/* Show who will receive the OTP */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <p className="text-sm font-medium text-blue-800 mb-2">
            📧 OTP Will Be Sent To:
          </p>
          <p className="text-blue-900 font-semibold">{recipientName}</p>
          <p className="text-sm text-blue-700">{recipientEmail}</p>
          {!isClientReceiving && (
            <p className="text-xs text-blue-600 mt-2">
              (Recipient is different from client: {trip.client_name})
            </p>
          )}
        </div>

        {/* Arrival notification confirmation */}
        <div className="bg-green-50 border border-green-200 rounded-lg p-3">
          <p className="text-sm text-green-700">
            ✅ Arrival notification sent to recipient
          </p>
        </div>

        <button
          onClick={handleRequestOTP}
          disabled={loading}
          className="bg-orange-600 text-white py-3 px-8 rounded-lg font-medium hover:bg-orange-700 transition-colors disabled:opacity-50 w-full"
        >
          {loading ? (
            <div className="flex items-center justify-center space-x-2">
              <LoadingSpinner size="small" />
              <span>Sending Code to {recipientName}...</span>
            </div>
          ) : (
            <div className="flex items-center justify-center space-x-2">
              <Mail className="h-5 w-5" />
              <span>Send Unlock Code to Recipient</span>
            </div>
          )}
        </button>

        <p className="text-xs text-gray-500">
          The recipient will receive a 6-digit code to verify delivery
        </p>
      </div>
    );
  };

  const renderOTPEnterStep = () => (
    <div className="text-center space-y-6">
      <div className="bg-red-100 rounded-full p-4 w-16 h-16 mx-auto flex items-center justify-center">
        <Smartphone className="h-8 w-8 text-red-600" />
      </div>

      <h3 className="text-lg font-semibold text-gray-900">Enter Unlock Code</h3>

      <p className="text-gray-600">
        Ask <strong>{recipientName}</strong> for the 6-digit code that was
        emailed to them.
      </p>

      {btConnected && (
        <div className="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
          <div className="flex items-center space-x-2 text-green-700">
            <CheckCircle className="h-4 w-4" />
            <span className="text-sm font-medium">
              Connected to Safe via Bluetooth
            </span>
          </div>
        </div>
      )}

      {!btConnected && (
        <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
          <div className="flex items-center space-x-2 text-yellow-700">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-sm font-medium">Connecting to safe...</span>
          </div>
        </div>
      )}

      {timeRemaining > 0 && (
        <div className="bg-red-50 border border-red-200 rounded-lg p-4">
          <div className="flex items-center justify-center space-x-2 text-red-700">
            <Clock className="h-5 w-5" />
            <span className="font-medium">
              Code expires in: {formatTime(timeRemaining)}
            </span>
          </div>
        </div>
      )}

      <div className="space-y-4">
        <input
          type="text"
          inputMode="numeric"
          pattern="[0-9]*"
          maxLength={6}
          className="w-full text-center text-3xl font-mono tracking-widest py-4 px-4 border-2 border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-red-500"
          placeholder="000000"
          value={otpCode}
          onInput={(e) => handleOTPInput((e.target as HTMLInputElement).value)}
          autoFocus
        />

        <div className="flex space-x-3">
          <button
            onClick={() => setCurrentStep("otp_request")}
            className="flex-1 bg-gray-100 text-gray-700 py-3 px-4 rounded-lg font-medium hover:bg-gray-200 transition-colors"
          >
            Request New Code
          </button>
          <button
            onClick={handleVerifyOTP}
            disabled={loading || otpCode.length !== 6}
            className="flex-1 bg-red-600 text-white py-3 px-4 rounded-lg font-medium hover:bg-red-700 transition-colors disabled:opacity-50"
          >
            {loading ? (
              <div className="flex items-center justify-center space-x-2">
                <LoadingSpinner size="small" />
                <span>Verifying...</span>
              </div>
            ) : (
              "Unlock Safe"
            )}
          </button>
        </div>
      </div>
    </div>
  );

  const renderCompleteStep = () => (
    <div className="text-center space-y-6">
      <div className="bg-green-100 rounded-full p-4 w-20 h-20 mx-auto flex items-center justify-center">
        <CheckCircle className="h-10 w-10 text-green-600" />
      </div>
      <h3 className="text-xl font-bold text-green-900 mb-2">
        Delivery Complete!
      </h3>
      <p className="text-green-700 mb-6">
        Safe has been successfully unlocked and delivery confirmed.
      </p>

      <div className="bg-green-50 border border-green-200 rounded-lg p-4 text-left mb-6">
        <h4 className="font-medium text-green-800 mb-2">Delivery Summary:</h4>
        <div className="text-sm text-green-700 space-y-1">
          <p>✅ Location verified</p>
          <p>✅ OTP authenticated</p>
          <p>✅ Safe unlocked successfully</p>
          <p>✅ Delivery confirmed</p>
          <p>Completed: {format(new Date(), "MMM d, yyyy HH:mm")}</p>
        </div>
      </div>

      <button
        onClick={onBack}
        className="w-full bg-green-600 text-white py-3 px-4 rounded-lg font-medium hover:bg-green-700 transition-colors"
      >
        Return to Dashboard
      </button>
    </div>
  );

  const initializeBluetooth = async () => {
    await bluetoothService.initialize();

    // Auto-connect to Pi if already paired
    const scanResult = await bluetoothService.scanForPi();
    if (scanResult.success) {
      const connectResult = await bluetoothService.connectToPi();
      if (connectResult.success) {
        setBtConnected(true);

        // Subscribe to Pi status updates
        bluetoothService.subscribeToPiStatus((status) => {
          console.log("📊 Pi status update:", status);
          // setPiStatus(status);
        });
      }
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 safe-area-top safe-area-bottom">
      {/* Header */}
      <div className="bg-white shadow-sm border-b">
        <div className="px-4 py-4">
          <div className="flex items-center space-x-3">
            <button
              onClick={onBack}
              className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 transition-colors"
            >
              <ArrowLeft className="h-5 w-5 text-gray-600" />
            </button>
            <div>
              <h1 className="text-lg font-semibold text-gray-900">
                Secure Delivery
              </h1>
              <p className="text-sm text-gray-500">
                {trip.id.slice(-8).toUpperCase()}
              </p>
            </div>
          </div>
        </div>
      </div>

      {/* Trip Info */}
      <div className="bg-white border-b">
        <div className="px-4 py-4">
          <div className="flex items-center space-x-3 mb-3">
            <div className="bg-blue-100 rounded-full p-2">
              <User className="h-5 w-5 text-blue-600" />
            </div>
            <div>
              <h2 className="font-semibold text-gray-900">
                {trip.client_name}
              </h2>
              {trip.client_email && (
                <p className="text-sm text-gray-500">{trip.client_email}</p>
              )}
            </div>
          </div>

          <div className="flex items-start space-x-3">
            <MapPin className="h-5 w-5 text-red-600 mt-0.5 flex-shrink-0" />
            <div>
              <p className="font-medium text-gray-900">Delivery Address</p>
              <p className="text-gray-600">{trip.delivery_address}</p>
            </div>
          </div>

          {trip.special_instructions && (
            <div className="mt-4 bg-yellow-50 border border-yellow-200 rounded-lg p-3">
              <p className="text-sm font-medium text-yellow-800 mb-1">
                Security Instructions:
              </p>
              <p className="text-sm text-yellow-700">
                {trip.special_instructions}
              </p>
            </div>
          )}
        </div>
      </div>

      {/* Error Display */}
      {error && (
        <div className="bg-red-50 border-b border-red-200 px-4 py-3">
          <div className="flex items-center space-x-2 text-red-700">
            <AlertTriangle className="h-4 w-4" />
            <span className="text-sm font-medium">{error}</span>
          </div>
        </div>
      )}

      {/* Main Content */}
      <div className="px-4 py-6">
        <div className="bg-white rounded-lg shadow p-6">
          {currentStep === "travel" && renderTravelStep()}
          {currentStep === "location" && renderLocationStep()}
          {currentStep === "otp_request" && renderOTPRequestStep()}
          {currentStep === "otp_enter" && renderOTPEnterStep()}
          {currentStep === "complete" && renderCompleteStep()}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/screens/LoginScreen.tsx">
import { useState } from "preact/hooks";
import { Shield, Eye, EyeOff } from "lucide-preact";
import { mobileAuthService } from "../services/auth";
import { LoadingSpinner } from "../components/LoadingSpinner";

export function LoginScreen() {
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");

  const handleLogin = async (e: Event) => {
    e.preventDefault();
    setError("");
    setLoading(true);

    try {
      const result = await mobileAuthService.login(username, password);

      if (!result.success) {
        setError(result.error || "Login failed");
      }
      // Success is handled by auth state change
    } catch (err) {
      setError("Network error. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-900 to-blue-700 flex items-center justify-center px-4">
      <div className="max-w-md w-full space-y-8">
        {/* Header */}
        <div className="text-center">
          <div className="flex justify-center">
            <div className="bg-white rounded-full p-3">
              <Shield className="h-12 w-12 text-blue-600" />
            </div>
          </div>
          <h2 className="mt-6 text-3xl font-extrabold text-white">
            Guardian Safe
          </h2>
          <p className="mt-2 text-sm text-blue-100">Mobile Driver App</p>
        </div>

        {/* Login Form */}
        <div className="bg-white rounded-xl shadow-xl p-8">
          <form className="space-y-6" onSubmit={handleLogin}>
            {error && (
              <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded text-sm">
                {error}
              </div>
            )}

            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-gray-700"
              >
                Username
              </label>
              <input
                id="username"
                name="username"
                type="text"
                autoComplete="username"
                required
                className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                placeholder="Enter your username"
                value={username}
                onInput={(e) =>
                  setUsername((e.target as HTMLInputElement).value)
                }
              />
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                Password
              </label>
              <div className="mt-1 relative">
                <input
                  id="password"
                  name="password"
                  type={showPassword ? "text" : "password"}
                  autoComplete="current-password"
                  required
                  className="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 pr-10"
                  placeholder="Enter your password"
                  value={password}
                  onInput={(e) =>
                    setPassword((e.target as HTMLInputElement).value)
                  }
                />
                <button
                  type="button"
                  className="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600"
                  onClick={() => setShowPassword(!showPassword)}
                >
                  {showPassword ? (
                    <EyeOff className="h-5 w-5" />
                  ) : (
                    <Eye className="h-5 w-5" />
                  )}
                </button>
              </div>
            </div>

            <button
              type="submit"
              disabled={loading}
              className="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {loading ? (
                <>
                  <LoadingSpinner size="small" className="mr-2" />
                  Signing in...
                </>
              ) : (
                "Sign In to Safe"
              )}
            </button>
          </form>

          <div className="mt-6 text-center">
            <p className="text-xs text-gray-500">
              Guardian Safe Mobile - Driver Access Only
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/services/audit.ts">
import { supabase } from "./supabase";
import { currentUser, currentSafe } from "../store/auth";

class AuditService {
  async log(
    event: string,
    details: string,
    success: boolean = true,
    tripId?: string
  ) {
    try {
      await supabase.from("activity_log").insert({
        event,
        user_type: "driver",
        user_id: currentUser.value?.username || "unknown",
        safe_id: currentSafe.value?.id,
        trip_id: tripId,
        details,
        success,
        created_at: new Date().toISOString(),
      });

      console.log(`📝 Logged: ${event} - ${details}`);
    } catch (err) {
      console.error("❌ Audit log failed:", err);
      // Don't block on logging failures
    }
  }
}

export const auditService = new AuditService();
</file>

<file path="src/services/auth.ts">
import { supabase } from "./supabase";
import { authActions } from "../store/auth";

class MobileAuthService {
  private readonly STORAGE_KEY = "guardian_mobile_user";

  async initialize() {
    authActions.setLoading(true);

    console.log("🔄 Initializing mobile auth...");

    try {
      const storedUser = this.getStoredUser();

      if (storedUser) {
        console.log("Found stored user:", storedUser.username);
        const isValid = await this.validateAndRefreshUser(storedUser);

        if (isValid) {
          console.log("Stored user is valid");
          return;
        } else {
          console.log("Stored user is invalid, clearing...");
          this.clearStoredUser();
        }
      }

      console.log("No valid stored user found");
    } catch (error) {
      console.error("Auth initialization error:", error);
      this.clearStoredUser();
    } finally {
      authActions.setLoading(false);
    }
  }

  async login(username: string, password: string) {
    console.log("Attempting login for:", username);

    try {
      const passwordHash = await this.hashPassword(password);
      console.log("Generated hash:", passwordHash);

      const { data: users, error: findError } = await supabase
        .from("mobile_users")
        .select("*")
        .eq("username", username)
        .eq("is_active", true);

      console.log("User lookup result:", users);
      console.log("User lookup error:", findError);

      if (findError) {
        console.error("Database error:", findError);
        return { success: false, error: "Database connection error" };
      }

      if (!users || users.length === 0) {
        console.log("No user found with username:", username);
        return { success: false, error: "Invalid username or password" };
      }

      const user = users[0];
      console.log("Found user:", user.username);
      console.log("Stored hash:", user.password_hash);
      console.log("Generated hash:", passwordHash);

      if (user.password_hash !== passwordHash) {
        console.log("Password hash mismatch");
        return { success: false, error: "Invalid username or password" };
      }

      console.log("Password verified!");

      const { data: safe, error: safeError } = await supabase
        .from("safes")
        .select("*")
        .eq("id", user.safe_id)
        .single();

      console.log("Safe lookup result:", safe);
      console.log("Safe lookup error:", safeError);

      if (safeError || !safe) {
        console.error("Safe not found:", safeError);
        return { success: false, error: "Safe not accessible" };
      }

      const mobileUser = {
        id: user.id,
        username: user.username,
        driver_name: user.driver_name,
        safe_id: user.safe_id,
        safe: {
          id: safe.id,
          serial_number: safe.serial_number,
          status: safe.status,
          battery_level: safe.battery_level,
          is_locked: safe.is_locked,
          tracking_device_id: safe.tracking_device_id,
        },
        is_active: user.is_active,
        created_at: user.created_at,
      };

      console.log("Login successful for:", mobileUser.username);

      this.storeUser(mobileUser);
      authActions.setUser(mobileUser);

      return { success: true };
    } catch (error) {
      console.error("Login exception:", error);
      return { success: false, error: "Login failed. Please try again." };
    }
  }

  async logout() {
    console.log("👋 Logging out...");
    this.clearStoredUser();
    authActions.logout();
  }

  private async validateAndRefreshUser(storedUser: any): Promise<boolean> {
    try {
      const { data: user, error: userError } = await supabase
        .from("mobile_users")
        .select("*")
        .eq("username", storedUser.username)
        .eq("is_active", true)
        .single();

      if (userError || !user) {
        return false;
      }

      const { data: safe, error: safeError } = await supabase
        .from("safes")
        .select("*")
        .eq("id", user.safe_id)
        .single();

      if (safeError || !safe) {
        return false;
      }

      const refreshedUser = {
        ...user,
        safe: {
          id: safe.id,
          serial_number: safe.serial_number,
          status: safe.status,
          battery_level: safe.battery_level,
          is_locked: safe.is_locked,
          tracking_device_id: safe.tracking_device_id,
        },
      };

      this.storeUser(refreshedUser);
      authActions.setUser(refreshedUser);

      return true;
    } catch (error) {
      console.error("User validation error:", error);
      return false;
    }
  }

  private getStoredUser(): any {
    try {
      const stored = localStorage.getItem(this.STORAGE_KEY);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  }

  private storeUser(user: any): void {
    try {
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(user));
    } catch (error) {
      console.error("Failed to store user:", error);
    }
  }

  private clearStoredUser(): void {
    try {
      localStorage.removeItem(this.STORAGE_KEY);
    } catch (error) {
      console.error("Failed to clear stored user:", error);
    }
  }

  private async hashPassword(password: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hash))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }
}

export const mobileAuthService = new MobileAuthService();
</file>

<file path="src/services/bluetooth.ts">
import { BleClient } from "@capacitor-community/bluetooth-le";

// Service UUIDs for Pi communication
const PI_SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
const OTP_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
const STATUS_CHARACTERISTIC_UUID = "beb5483e-36e1-4688-b7f5-ea07361b26a9";

interface BluetoothConfig {
  phoneMac: string;
  piMac: string;
  trackerMac: string;
}

class BluetoothService {
  private config: BluetoothConfig;
  private isConnected = false;
  private deviceId: string | null = null;

  constructor() {
    // Load MAC addresses from environment
    this.config = {
      phoneMac: import.meta.env.VITE_PHONE_MAC_1 || "",
      piMac: import.meta.env.VITE_PI_MAC || "",
      trackerMac: import.meta.env.VITE_TRACKER_IMEI || "",
    };
  }

  // Initialize Bluetooth
  async initialize() {
    try {
      await BleClient.initialize();
      console.log("Bluetooth initialized");
      return { success: true };
    } catch (err: any) {
      console.error("Bluetooth init failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Check if this phone matches hardcoded MAC
  async validatePhoneMAC(): Promise<boolean> {
    // Get device Bluetooth MAC address
    // Note: Android 6+ restricts direct MAC access, we'll use device ID
    //const phoneMac1 = import.meta.env.VITE_PHONE_MAC_1;
    //const phoneMac2 = import.meta.env.VITE_PHONE_MAC_2;

    // For now, we'll validate during connection to Pi
    // The Pi will validate the phone's MAC on its end
    console.log("Phone MAC validation: Using hardcoded addresses");
    return true;
  }

  // Scan for Pi Bluetooth device
  async scanForPi(): Promise<{
    success: boolean;
    device?: any;
    error?: string;
  }> {
    try {
      console.log("Scanning for Pi with MAC:", this.config.piMac);

      await BleClient.requestLEScan(
        { services: [PI_SERVICE_UUID] },
        (result) => {
          console.log("Device found:", result);
          // Check if this is our Pi by MAC address
          if (
            result.device.deviceId.toUpperCase() ===
            this.config.piMac.toUpperCase()
          ) {
            console.log("Found Pi");
            BleClient.stopLEScan();
            this.deviceId = result.device.deviceId;
          }
        }
      );

      // Scan for 10 seconds
      await new Promise((resolve) => setTimeout(resolve, 10000));
      await BleClient.stopLEScan();

      if (this.deviceId) {
        return { success: true, device: { deviceId: this.deviceId } };
      } else {
        return { success: false, error: "Pi not found" };
      }
    } catch (err: any) {
      console.error("Scan error:", err);
      return { success: false, error: err.message };
    }
  }

  // Connect to Pi
  async connectToPi(): Promise<{ success: boolean; error?: string }> {
    if (!this.deviceId) {
      return { success: false, error: "No Pi device found. Scan first." };
    }

    try {
      console.log("Connecting to Pi...");

      await BleClient.connect(this.deviceId, (deviceId) => {
        console.log("Disconnected from Pi:", deviceId);
        this.isConnected = false;
        this.deviceId = null;
      });

      this.isConnected = true;
      console.log("Connected to Pi!");

      return { success: true };
    } catch (err: any) {
      console.error("Connection failed:", err);
      return { success: false, error: err.message };
    }
  }

  // Send OTP to Pi for verification
  async sendOTPToPi(
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to Pi" };
    }

    try {
      console.log("Sending OTP to Pi:", otpCode);

      // Convert OTP string to bytes
      const encoder = new TextEncoder();
      const otpBytes = encoder.encode(otpCode);

      // Write OTP to characteristic
      await BleClient.write(
        this.deviceId,
        PI_SERVICE_UUID,
        OTP_CHARACTERISTIC_UUID,
        new DataView(otpBytes.buffer)
      );

      console.log("OTP sent to Pi");
      return { success: true };
    } catch (err: any) {
      console.error("Failed to send OTP:", err);
      return { success: false, error: err.message };
    }
  }

  // Read Pi status (lock state, verification result)
  async readPiStatus(): Promise<{
    success: boolean;
    status?: {
      verified: boolean;
      lockOpen: boolean;
      batteryPercent: number;
      safeStatus: "inactive" | "active" | "maintenance" | "offline";
      voltage: number;
    };
    error?: string;
  }> {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to Pi" };
    }

    try {
      console.log("Reading Pi status...");

      const result = await BleClient.read(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID
      );

      // Parse extended status bytes
      // [verified, lock_open, battery_percent, status_code, voltage_high, voltage_low]
      const statusArray = new Uint8Array(result.buffer);

      const verified = statusArray[0] === 1;
      const lockOpen = statusArray[1] === 1;
      const batteryPercent = statusArray[2];
      const statusCode = statusArray[3];

      // Reconstruct voltage from two bytes
      const voltageInt = (statusArray[4] << 8) | statusArray[5];
      const voltage = voltageInt / 10.0;

      // Map status code to string
      const statusMap: Record<
        number,
        "inactive" | "active" | "maintenance" | "offline"
      > = {
        0: "inactive",
        1: "active",
        2: "maintenance",
        3: "offline",
      };
      const safeStatus = statusMap[statusCode] || "active";

      console.log("Pi status:", {
        verified,
        lockOpen,
        batteryPercent,
        safeStatus,
        voltage: `${voltage.toFixed(2)}V`,
      });

      return {
        success: true,
        status: {
          verified,
          lockOpen,
          batteryPercent,
          safeStatus,
          voltage,
        },
      };
    } catch (err: any) {
      console.error("Failed to read status:", err);
      return { success: false, error: err.message };
    }
  }

  // Subscribe to Pi status changes
  async subscribeToPiStatus(
    callback: (status: { verified: boolean; lockOpen: boolean }) => void
  ) {
    if (!this.isConnected || !this.deviceId) {
      return { success: false, error: "Not connected to Pi" };
    }

    try {
      await BleClient.startNotifications(
        this.deviceId,
        PI_SERVICE_UUID,
        STATUS_CHARACTERISTIC_UUID,
        (value) => {
          const statusArray = new Uint8Array(value.buffer);
          const verified = statusArray[0] === 1;
          const lockOpen = statusArray[1] === 1;
          callback({ verified, lockOpen });
        }
      );

      return { success: true };
    } catch (err: any) {
      console.error("Failed to subscribe:", err);
      return { success: false, error: err.message };
    }
  }

  // Disconnect from Pi
  async disconnect() {
    if (this.deviceId) {
      try {
        await BleClient.disconnect(this.deviceId);
        this.isConnected = false;
        this.deviceId = null;
        console.log("Disconnected from Pi");
      } catch (err) {
        console.error("Disconnect error:", err);
      }
    }
  }

  // Get connection status
  isConnectedToPi(): boolean {
    return this.isConnected;
  }

  // Get device configuration
  getConfig(): BluetoothConfig {
    return this.config;
  }
}

export const bluetoothService = new BluetoothService();
</file>

<file path="src/services/geolocation.ts">
interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  timestamp: number;
}

class GeolocationService {
  // Check if we're running in a Capacitor environment
  private isCapacitorAvailable(): boolean {
    return !!(window as any).Capacitor;
  }

  // Get current position with high accuracy
  async getCurrentPosition(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      console.log(
        "Getting location - is Capacitor available?",
        this.isCapacitorAvailable()
      );

      if (this.isCapacitorAvailable()) {
        return await this.getCapacitorLocation();
      } else {
        return await this.getBrowserLocation();
      }
    } catch (err: any) {
      console.error("Geolocation error:", err);
      return { success: false, error: "Failed to get current location" };
    }
  }

  // Use Capacitor geolocation (for mobile apps)
  private async getCapacitorLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    try {
      // Import Capacitor dynamically to avoid errors in browser
      const { Geolocation } = await import("@capacitor/geolocation");

      // Check permissions first
      const permissions = await Geolocation.checkPermissions();

      if (permissions.location !== "granted") {
        const requestResult = await Geolocation.requestPermissions();
        if (requestResult.location !== "granted") {
          return { success: false, error: "Location permission denied" };
        }
      }

      // Get position with high accuracy
      const position = await Geolocation.getCurrentPosition({
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000,
      });

      return {
        success: true,
        location: {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy,
          timestamp: position.timestamp,
        },
      };
    } catch (err: any) {
      console.error("Capacitor geolocation error:", err);

      let errorMessage = "Failed to get current location";
      if (err.message.includes("denied")) {
        errorMessage = "Location access denied";
      } else if (err.message.includes("timeout")) {
        errorMessage = "Location request timed out";
      } else if (err.message.includes("unavailable")) {
        errorMessage = "Location services unavailable";
      }

      return { success: false, error: errorMessage };
    }
  }

  // Use browser geolocation API (for web testing)
  private async getBrowserLocation(): Promise<{
    success: boolean;
    location?: LocationData;
    error?: string;
  }> {
    return new Promise((resolve) => {
      if (!navigator.geolocation) {
        resolve({
          success: false,
          error: "Geolocation is not supported by this browser",
        });
        return;
      }

      console.log("Using browser geolocation...");

      navigator.geolocation.getCurrentPosition(
        (position) => {
          console.log("Browser location success:", position.coords);
          resolve({
            success: true,
            location: {
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            },
          });
        },
        (error) => {
          console.error("Browser location error:", error);

          let errorMessage = "Failed to get current location";
          switch (error.code) {
            case error.PERMISSION_DENIED:
              errorMessage = "Location access denied by user";
              break;
            case error.POSITION_UNAVAILABLE:
              errorMessage = "Location information is unavailable";
              break;
            case error.TIMEOUT:
              errorMessage = "Location request timed out";
              break;
          }

          resolve({ success: false, error: errorMessage });
        },
        {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 60000,
        }
      );
    });
  }

  // Watch position for continuous tracking
  async watchPosition(
    callback: (location: LocationData) => void
  ): Promise<string | null> {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");

        const watchId = await Geolocation.watchPosition(
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          },
          (position, err) => {
            if (err) {
              console.error("Location watch error:", err);
              return;
            }

            if (position) {
              callback({
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                timestamp: position.timestamp,
              });
            }
          }
        );

        return watchId;
      } else {
        // Browser fallback
        const watchId = navigator.geolocation.watchPosition(
          (position) => {
            callback({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
              accuracy: position.coords.accuracy,
              timestamp: position.timestamp,
            });
          },
          (error) => {
            console.error("Browser location watch error:", error);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 30000,
          }
        );

        return watchId.toString();
      }
    } catch (err) {
      console.error("Failed to start location watching:", err);
      return null;
    }
  }

  // Stop watching position
  async clearWatch(watchId: string) {
    try {
      if (this.isCapacitorAvailable()) {
        const { Geolocation } = await import("@capacitor/geolocation");
        await Geolocation.clearWatch({ id: watchId });
      } else {
        navigator.geolocation.clearWatch(parseInt(watchId));
      }
    } catch (err) {
      console.error("Failed to clear location watch:", err);
    }
  }
}

export const geolocationService = new GeolocationService();
</file>

<file path="src/services/otp.ts">
import { supabase } from "./supabase";

interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}

class OTPService {
  private generateOTP(): string {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  async requestOTP(
    tripId: string,
    location: { latitude: number; longitude: number; accuracy: number }
  ): Promise<OTPResponse> {
    try {
      console.log("🔐 Requesting OTP for trip:", tripId);

      // Step 1: Check if trip is in correct status
      const { data: trip, error: tripError } = await supabase
        .from("trips")
        .select("*")
        .eq("id", tripId)
        .eq("status", "in_transit")
        .single();

      if (tripError || !trip) {
        console.error("❌ Trip lookup error:", tripError);
        return {
          success: false,
          error: "Trip must be in transit to request OTP",
        };
      }

      if (!trip.client_email) {
        return {
          success: false,
          error: "No recipient email found for this trip",
        };
      }

      // Step 2: Generate OTP
      const otp = this.generateOTP();
      const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

      console.log(
        "🔑 Generated OTP:",
        otp,
        "expires:",
        expiresAt.toISOString()
      );

      // Step 3: Store OTP in database
      const otpData = {
        trip_id: tripId,
        otp_code: otp,
        expires_at: expiresAt.toISOString(),
        requested_location: location,
      };

      console.log("💾 Storing OTP...");

      const { data: insertedOTP, error: otpError } = await supabase
        .from("trip_otps")
        .insert(otpData)
        .select()
        .single();

      if (otpError) {
        console.error("💥 OTP insertion error:", otpError);
        return {
          success: false,
          error: `Failed to generate OTP: ${otpError.message}`,
        };
      }

      console.log("✅ OTP stored successfully:", insertedOTP);

      // Step 4: Send OTP via email
      const emailResult = await this.sendOTPEmail(trip, otp);
      if (!emailResult.success) {
        console.warn("⚠️ OTP created but email failed:", emailResult.error);
      }

      console.log("🎉 OTP request completed successfully");
      return {
        success: true,
        expires_at: expiresAt.toISOString(),
      };
    } catch (err: any) {
      console.error("💥 OTP request exception:", err);
      return {
        success: false,
        error: `Failed to request OTP: ${err.message}`,
      };
    }
  }

  private async sendOTPEmail(
    trip: any,
    otp: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      // Send OTP to RECIPIENT (person receiving delivery)
      const recipientEmail = trip.recipient_email || trip.client_email;
      const recipientName = trip.recipient_name || trip.client_name;

      console.log("📧 Sending OTP email to RECIPIENT:", recipientEmail);

      const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
      const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

      const response = await fetch(
        `${supabaseUrl}/functions/v1/send-delivery-otp`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${anonKey}`,
            apikey: anonKey,
          },
          body: JSON.stringify({
            to: recipientEmail,
            recipient_name: recipientName, // Changed from client_name
            client_name: trip.client_name, // Who booked it
            otp_code: otp,
            trip_id: trip.id,
            delivery_address: trip.delivery_address,
            driver_location: "At your delivery location",
          }),
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        console.error(
          "❌ Email service HTTP error:",
          response.status,
          errorText
        );
        return {
          success: false,
          error: `Email service error: ${response.status}`,
        };
      }

      const result = await response.json();
      console.log("📧 Email service response:", result);

      if (result.success) {
        console.log("✅ OTP email sent successfully to recipient!");
        return { success: true };
      } else {
        return {
          success: false,
          error: result.error || "Failed to send OTP email",
        };
      }
    } catch (err: any) {
      console.error("💥 Email send exception:", err);
      return { success: false, error: `Email service error: ${err.message}` };
    }
  }

  async verifyOTP(
    tripId: string,
    otpCode: string
  ): Promise<{ success: boolean; error?: string }> {
    try {
      console.log("🔍 Verifying OTP:", otpCode, "for trip:", tripId);

      const { data: otpRecord, error } = await supabase
        .from("trip_otps")
        .select("*")
        .eq("trip_id", tripId)
        .eq("otp_code", otpCode)
        .eq("used", false)
        .gte("expires_at", new Date().toISOString())
        .order("created_at", { ascending: false })
        .limit(1)
        .single();

      if (error) {
        console.error("❌ OTP lookup error:", error);
        if (error.code === "PGRST116") {
          return { success: false, error: "Invalid or expired OTP code" };
        }
        return { success: false, error: "Failed to verify OTP" };
      }

      if (!otpRecord) {
        return { success: false, error: "Invalid or expired OTP code" };
      }

      console.log("✅ Found valid OTP record:", otpRecord.id);

      // Mark OTP as used
      const { error: updateError } = await supabase
        .from("trip_otps")
        .update({
          used: true,
          used_at: new Date().toISOString(),
        })
        .eq("id", otpRecord.id);

      if (updateError) {
        console.error("❌ Failed to mark OTP as used:", updateError);
        return { success: false, error: "Failed to process OTP" };
      }

      console.log("🎉 OTP verified and marked as used");
      return { success: true };
    } catch (err: any) {
      console.error("💥 OTP verification exception:", err);
      return { success: false, error: `Verification failed: ${err.message}` };
    }
  }

  async cleanupExpiredOTPs() {
    try {
      const { error } = await supabase
        .from("trip_otps")
        .delete()
        .lt("expires_at", new Date().toISOString());

      if (error) {
        console.error("❌ OTP cleanup error:", error);
      } else {
        console.log("🧹 Expired OTPs cleaned up");
      }
    } catch (err) {
      console.error("💥 OTP cleanup exception:", err);
    }
  }
}

export const otpService = new OTPService();
</file>

<file path="src/services/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables");
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
  },
});
</file>

<file path="src/services/tracknetics.ts">
import { supabase } from "./supabase";

interface TrackneticsCredentials {
  username: string;
  password: string;
  apiKey?: string;
}

interface LoginResponse {
  state: string;
  userInfo?: {
    userID: string;
    userName: string;
    loginName: string;
    timeZone: string;
    address: string;
    cellPhone: string;
    key: string;
  };
}

interface DeviceInfo {
  id: string;
  sn: string; // IMEI
  name: string;
  status: string;
  speed?: string;
}

interface LocationData {
  state: string;
  positionTime?: string;
  lat?: string;
  lng?: string;
  speed?: string;
  course?: string;
  isStop?: string;
  stm?: string;
  isGPS?: string;
  status?: string;
}

class TrackneticsService {
  private credentials: TrackneticsCredentials;
  private currentSession: { userID?: string; key?: string } | null = null;

  constructor() {
    this.credentials = {
      username: import.meta.env.VITE_TRACKNETICS_USERNAME || "",
      password: import.meta.env.VITE_TRACKNETICS_PASSWORD || "",
      apiKey: import.meta.env.VITE_TRACKNETICS_API_KEY || "",
    };
  }

  // Make API call through Supabase Edge Function proxy
  private async apiCall(
    operation: string,
    params: Record<string, any> = {}
  ): Promise<any> {
    try {
      const { data, error } = await supabase.functions.invoke(
        "tracknetics-proxy",
        {
          body: {
            operation,
            params,
          },
        }
      );

      if (error) {
        console.error("Proxy call error:", error);
        throw new Error(`Proxy error: ${error.message}`);
      }

      return data;
    } catch (err) {
      console.error("API call failed:", err);
      throw err;
    }
  }

  // Login and get authentication key
  async login(): Promise<{ success: boolean; error?: string }> {
    try {
      console.log("Logging into Tracknetics via proxy...");

      const data: LoginResponse = await this.apiCall("Login", {
        name: this.credentials.username,
        pass: this.credentials.password,
      });

      console.log("Tracknetics login response:", data);

      if (data.state === "0" && data.userInfo) {
        this.currentSession = {
          userID: data.userInfo.userID,
          key: data.userInfo.key,
        };
        console.log("Session key:", data.userInfo.key);
        console.log("Tracknetics login successful");
        return { success: true };
      } else {
        console.error("Tracknetics login failed:", data);
        const errorMessage = this.getErrorMessage(data.state);
        return { success: false, error: `Login failed: ${errorMessage}` };
      }
    } catch (error: any) {
      console.error("Tracknetics login error:", error);
      return {
        success: false,
        error: error.message || "Network error during login",
      };
    }
  }

  // Ensure we have a valid session
  private async ensureAuthenticated(): Promise<boolean> {
    if (!this.currentSession?.key) {
      const loginResult = await this.login();
      return loginResult.success;
    }
    return true;
  }

  // Get list of devices
  async getDeviceList(): Promise<{
    success: boolean;
    devices?: DeviceInfo[];
    error?: string;
  }> {
    if (
      !(await this.ensureAuthenticated()) ||
      !this.currentSession?.userID ||
      !this.currentSession?.key
    ) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      console.log("Getting device list...");

      const data = await this.apiCall("GetDeviceList", {
        ID: this.currentSession.userID,
        PageNo: 1,
        PageCount: 100,
        Key: this.currentSession.key,
      });

      console.log("Device list response:", data);

      if (data.state === "0") {
        return { success: true, devices: data.arr || [] };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get devices: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device list:", error);
      return {
        success: false,
        error: error.message || "Network error getting device list",
      };
    }
  }

  // Get real-time location for a device by ID
  async getDeviceLocation(
    deviceId: string
  ): Promise<{ success: boolean; location?: LocationData; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      console.log("Getting location for device:", deviceId);

      const data: LocationData = await this.apiCall("GetTracking", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        MapType: "google",
        Language: "en-us",
        Key: this.currentSession.key,
      });

      console.log("Location response:", data);

      if (data.state === "0") {
        return { success: true, location: data };
      } else if (data.state === "2002") {
        return { success: false, error: "No location data available" };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get location: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device location:", error);
      return {
        success: false,
        error: error.message || "Network error getting location",
      };
    }
  }

  // Get location by device ID (simplified method for direct calls)
  async getLocationByDeviceId(deviceId: string): Promise<{
    success: boolean;
    location?: {
      lat: number;
      lng: number;
      accuracy: number;
      timestamp: number;
    };
    error?: string;
  }> {
    console.log("Getting location for device ID:", deviceId);

    const locationResult = await this.getDeviceLocation(deviceId);

    if (!locationResult.success || !locationResult.location) {
      return { success: false, error: locationResult.error };
    }

    const location = locationResult.location;

    // Convert to standard format
    if (location.lat && location.lng) {
      const standardLocation = {
        lat: parseFloat(location.lat),
        lng: parseFloat(location.lng),
        accuracy: location.isGPS === "1" ? 10 : 100, // GPS vs LBS accuracy estimate
        timestamp: location.positionTime
          ? new Date(location.positionTime).getTime()
          : Date.now(),
      };

      console.log("Converted location:", standardLocation);
      return {
        success: true,
        location: standardLocation,
      };
    }

    return { success: false, error: "Invalid location data received" };
  }

  // Create geofence for delivery location
  async createDeliveryGeofence(
    deviceId: string,
    name: string,
    lat: number,
    lng: number,
    radiusMeters: number = 100
  ): Promise<{ success: boolean; geofenceId?: string; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      console.log("🚧 Creating geofence:", name, "at", lat, lng);

      const data = await this.apiCall("SaveGeofence", {
        DeviceID: deviceId,
        GeofenceName: name,
        Remark: "Delivery Location",
        Lat: lat,
        Lng: lng,
        Radius: radiusMeters,
        GeofenceID: 0,
        MapType: "google",
        Key: this.currentSession.key,
      });

      console.log("Geofence response:", data);

      if (data.state === "0") {
        return { success: true, geofenceId: data.geofenceID };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to create geofence: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error creating geofence:", error);
      return {
        success: false,
        error: error.message || "Network error creating geofence",
      };
    }
  }

  // Get device details by ID
  async getDeviceDetails(
    deviceId: string
  ): Promise<{ success: boolean; device?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      console.log("Getting device details for:", deviceId);

      const data = await this.apiCall("GetDeviceDetail", {
        DeviceID: deviceId,
        TimeZones: "South Africa Standard Time",
        Key: this.currentSession.key,
      });

      console.log("📋 Device details response:", data);

      if (data.state === "0") {
        return { success: true, device: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device details: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device details:", error);
      return {
        success: false,
        error: error.message || "Network error getting device details",
      };
    }
  }

  // Get device history/playback
  async getDeviceHistory(
    deviceId: string,
    startTime: string,
    endTime: string
  ): Promise<{ success: boolean; history?: any; error?: string }> {
    if (!(await this.ensureAuthenticated()) || !this.currentSession?.key) {
      return { success: false, error: "Authentication failed" };
    }

    try {
      console.log(
        "📊 Getting device history for:",
        deviceId,
        "from",
        startTime,
        "to",
        endTime
      );

      const data = await this.apiCall("GetDevicesHistory", {
        DeviceID: deviceId,
        StartTime: startTime,
        EndTime: endTime,
        TimeZones: "South Africa Standard Time",
        ShowLBS: 0,
        MapType: "google",
        SelectCount: 1000,
        Key: this.currentSession.key,
      });

      console.log("Device history response:", data);

      if (data.state === "0") {
        return { success: true, history: data };
      } else {
        const errorMessage = this.getErrorMessage(data.state);
        return {
          success: false,
          error: `Failed to get device history: ${errorMessage}`,
        };
      }
    } catch (error: any) {
      console.error("Error getting device history:", error);
      return {
        success: false,
        error: error.message || "Network error getting device history",
      };
    }
  }

  // Logout
  async logout(): Promise<void> {
    if (this.currentSession?.userID && this.currentSession?.key) {
      try {
        await this.apiCall("Exit", {
          ID: this.currentSession.userID,
          Key: this.currentSession.key,
        });
      } catch (error) {
        console.error("Error during logout:", error);
      }
    }
    this.currentSession = null;
  }

  // Helper to decode Tracknetics error states
  private getErrorMessage(state: string): string {
    const errorCodes: Record<string, string> = {
      "0": "Success",
      "1001": "Parameter error",
      "1002": "Program error",
      "2001": "Username or password error",
      "2002": "No result",
      "2003": "Car number already exists",
      "2004": "Fail to modify",
      "2005": "Modify success",
      "2020": "Username already exists",
      "2021": "It has sub account, cannot be deleted",
      "2022": "It has device, cannot be deleted",
      "2023": "Username does not exist",
      "3001": "KEY incorrect",
      "3004": "Maintenance...",
    };

    return errorCodes[state] || `Unknown error (${state})`;
  }
}

export const trackneticsService = new TrackneticsService();
</file>

<file path="src/services/trips.ts">
import { supabase } from "./supabase";
import { currentUser } from "../store/auth";
import { tripsActions } from "../store/trips";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

class TripsService {
  private subscription: any = null;

  async loadTrips() {
    const user = currentUser.value;
    if (!user?.safe_id) {
      console.log("No user or safe_id found:", user);
      return;
    }

    console.log("Loading trips for safe_id:", user.safe_id);
    tripsActions.setLoading(true);

    try {
      const { data, error } = await supabase
        .from("trips")
        .select("*")
        .eq("safe_id", user.safe_id)
        .in("status", ["pending", "in_transit"])
        .order("scheduled_pickup", { ascending: true });

      console.log("📋 Trips query result:", data);
      console.log("📋 Trips query error:", error);

      if (error) {
        console.error("Failed to load trips:", error);
        tripsActions.setError("Failed to load trips");
        return;
      }

      console.log(`Found ${data?.length || 0} trips`);
      tripsActions.setTrips(data || []);
    } catch (err) {
      console.error("Exception loading trips:", err);
      tripsActions.setError("Failed to load trips");
    } finally {
      tripsActions.setLoading(false);
    }
  }

  async startTrip(tripId: string) {
    try {
      const { data, error } = await supabase
        .from("trips")
        .update({
          status: "in_transit",
          actual_pickup_time: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId)
        .select()
        .single();

      if (error) {
        return { success: false, error: error.message };
      }

      tripsActions.updateTrip(tripId, data);
      return { success: true, trip: data };
    } catch (err) {
      console.error("Error starting trip:", err);
      return { success: false, error: "Failed to start trip" };
    }
  }

  async completeTrip(tripId: string) {
    console.log("🎯 Attempting to complete trip:", tripId);

    try {
      const { data, error } = await supabase
        .from("trips")
        .update({
          status: "delivered",
          actual_delivery_time: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        })
        .eq("id", tripId)
        .select("*")
        .single();

      console.log("📦 Complete trip result:", data);
      console.log("❌ Complete trip error:", error);

      if (error) {
        console.error("Failed to complete trip:", error);
        return { success: false, error: error.message };
      }

      console.log("✅ Trip completed successfully!");

      // Send delivery confirmation to CLIENT
      if (data.client_email) {
        console.log(
          "📧 Sending delivery confirmation to client:",
          data.client_email
        );

        try {
          const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
          const anonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

          const response = await fetch(
            `${supabaseUrl}/functions/v1/send-delivery-confirmation`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${anonKey}`,
                apikey: anonKey,
              },
              body: JSON.stringify({
                to: data.client_email,
                client_name: data.client_name,
                recipient_name: data.recipient_name || data.client_name,
                trip_id: data.id,
                delivery_address: data.delivery_address,
                delivered_at: data.actual_delivery_time,
              }),
            }
          );

          if (response.ok) {
            console.log("✅ Delivery confirmation sent to client");
          } else {
            console.warn(
              "⚠️ Delivery confirmation failed:",
              await response.text()
            );
          }
        } catch (emailError) {
          console.warn("⚠️ Could not send delivery confirmation:", emailError);
          // Don't block on email failure
        }
      }

      tripsActions.updateTrip(tripId, data);
      return { success: true, trip: data };
    } catch (err) {
      console.error("💥 Exception completing trip:", err);
      return { success: false, error: "Failed to complete trip" };
    }
  }

  setupRealtimeSubscriptions() {
    const user = currentUser.value;
    if (!user?.safe_id) return;

    console.log("Setting up trip subscriptions for safe:", user.safe_id);

    this.subscription = supabase
      .channel("trips-updates")
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "trips",
          filter: `safe_id=eq.${user.safe_id}`,
        },
        (payload) => {
          console.log("Trip update received:", payload);

          if (payload.eventType === "INSERT") {
            tripsActions.addTrip(payload.new as TripData);
            this.showTripNotification(payload.new as TripData);
          } else if (payload.eventType === "UPDATE") {
            tripsActions.updateTrip(
              payload.new.id,
              payload.new as Partial<TripData>
            );
          }
        }
      )
      .subscribe();
  }

  private showTripNotification(trip: TripData) {
    if ("Notification" in window && Notification.permission === "granted") {
      new Notification("New Trip Assigned!", {
        body: `Delivery for ${trip.client_name} - ${trip.pickup_address}`,
        icon: "/favicon.ico",
      });
    }

    console.log("NEW TRIP ASSIGNED:", trip);
  }

  async requestNotificationPermission() {
    if ("Notification" in window) {
      const permission = await Notification.requestPermission();
      console.log("Notification permission:", permission);
      return permission === "granted";
    }
    return false;
  }

  cleanup() {
    if (this.subscription) {
      supabase.removeChannel(this.subscription);
    }
  }
}

export const tripsService = new TripsService();
</file>

<file path="src/store/auth.ts">
import { signal, computed } from "@preact/signals";

interface MobileUser {
  id: string;
  username: string;
  driver_name?: string;
  safe_id: string;
  safe: {
    id: string;
    serial_number: string;
    status: string;
    battery_level: number;
    is_locked: boolean;
    tracking_device_id?: string;
  };
  is_active: boolean;
  created_at: string;
}

interface MobileAuthState {
  user: MobileUser | null;
  loading: boolean;
  isAuthenticated: boolean;
}

// Auth state signal
export const authState = signal<MobileAuthState>({
  user: null,
  loading: true,
  isAuthenticated: false,
});

// Computed values
export const currentUser = computed(() => authState.value.user);
export const currentSafe = computed(() => authState.value.user?.safe);
export const isAuthenticated = computed(() => authState.value.isAuthenticated);
export const isLoading = computed(() => authState.value.loading);

// Auth actions
export const authActions = {
  setUser: (user: MobileUser | null) => {
    authState.value = {
      user,
      loading: false,
      isAuthenticated: !!user,
    };
  },

  setLoading: (loading: boolean) => {
    authState.value = {
      ...authState.value,
      loading,
    };
  },

  logout: () => {
    authState.value = {
      user: null,
      loading: false,
      isAuthenticated: false,
    };
  },

  updateUser: (updates: Partial<MobileUser>) => {
    if (authState.value.user) {
      authState.value = {
        ...authState.value,
        user: {
          ...authState.value.user,
          ...updates,
        },
      };
    }
  },
};
</file>

<file path="src/store/trips.ts">
import { signal, computed } from "@preact/signals";

interface TripData {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  created_at: string;
  updated_at: string;
}

interface TripsState {
  trips: TripData[];
  loading: boolean;
  error: string | null;
  activeTrip: TripData | null;
}

// Trips state
export const tripsState = signal<TripsState>({
  trips: [],
  loading: false,
  error: null,
  activeTrip: null,
});

// Computed values
export const currentTrips = computed(() => tripsState.value.trips);
export const activeTrip = computed(() => tripsState.value.activeTrip);
export const isLoading = computed(() => tripsState.value.loading);
export const error = computed(() => tripsState.value.error);

// Get pending trips (not started yet)
export const pendingTrips = computed(() =>
  tripsState.value.trips.filter((trip) => trip.status === "pending")
);

// Get in-transit trip (should only be one)
export const inTransitTrip = computed(() =>
  tripsState.value.trips.find((trip) => trip.status === "in_transit")
);

// Actions
export const tripsActions = {
  setTrips: (trips: TripData[]) => {
    tripsState.value = {
      ...tripsState.value,
      trips,
      error: null,
      // Set active trip to in-transit or next pending
      activeTrip:
        trips.find((t) => t.status === "in_transit") ||
        trips.find((t) => t.status === "pending") ||
        null,
    };
  },

  addTrip: (trip: TripData) => {
    const newTrips = [...tripsState.value.trips, trip];
    tripsState.value = {
      ...tripsState.value,
      trips: newTrips,
      activeTrip:
        trip.status === "pending" && !tripsState.value.activeTrip
          ? trip
          : tripsState.value.activeTrip,
    };
  },

  updateTrip: (tripId: string, updates: Partial<TripData>) => {
    const updatedTrips = tripsState.value.trips.map((trip) =>
      trip.id === tripId ? { ...trip, ...updates } : trip
    );

    tripsState.value = {
      ...tripsState.value,
      trips: updatedTrips,
      activeTrip:
        tripsState.value.activeTrip?.id === tripId
          ? { ...tripsState.value.activeTrip, ...updates }
          : tripsState.value.activeTrip,
    };
  },

  setActiveTrip: (trip: TripData | null) => {
    tripsState.value = {
      ...tripsState.value,
      activeTrip: trip,
    };
  },

  setLoading: (loading: boolean) => {
    tripsState.value = {
      ...tripsState.value,
      loading,
    };
  },

  setError: (error: string | null) => {
    tripsState.value = {
      ...tripsState.value,
      error,
      loading: false,
    };
  },

  clearError: () => {
    tripsState.value = {
      ...tripsState.value,
      error: null,
    };
  },
};
</file>

<file path="src/types/index.ts">
export type UserRole = "owner" | "admin";

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  is_active: boolean;
  created_at: string;
}

export interface Safe {
  id: string;
  serial_number: string;
  device_hash: string;
  status: "active" | "inactive" | "maintenance" | "offline";
  battery_level: number;
  is_locked: boolean;
  tracking_device_id?: string;
  assigned_to: string;
  last_update?: string;
}

export interface Trip {
  id: string;
  safe_id: string;
  client_name: string;
  client_email?: string;
  pickup_address: string;
  delivery_address: string;
  status: "pending" | "in_transit" | "delivered" | "cancelled";
  scheduled_pickup: string;
  scheduled_delivery: string;
  special_instructions?: string;
  priority?: "low" | "normal" | "high" | "urgent";
  requires_signature?: boolean;
  tracking_token?: string;
  customer_tracking_enabled?: boolean;
  created_by: string;
  created_at: string;
}

// Mobile-specific types
export interface BluetoothDevice {
  deviceId: string;
  name: string;
  connected: boolean;
}

export interface OTPRequest {
  trip_id: string;
  location: {
    latitude: number;
    longitude: number;
    accuracy: number;
  };
  timestamp: string;
}

export interface OTPResponse {
  success: boolean;
  otp?: string;
  error?: string;
  expires_at?: string;
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,
    "paths": {
      "react": ["./node_modules/preact/compat/"],
      "react-dom": ["./node_modules/preact/compat/"]
    },

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",
    "jsxImportSource": "preact",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import preact from "@preact/preset-vite";
import tailwindcss from "@tailwindcss/vite";

// https://vite.dev/config/
export default defineConfig({
  plugins: [preact(), tailwindcss()],
  define: {
    global: "globalThis",
  },
  server: {
    host: "0.0.0.0",
    port: 5174,
  },
});
</file>

</files>
